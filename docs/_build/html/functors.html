
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Functors and C++11 lambdas. &#8212; Hydra 2.0 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="&lt;no title&gt;" href="containers.html" />
    <link rel="prev" title="Introduction" href="introduction.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="containers.html" title="&lt;no title&gt;"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="introduction.html" title="Introduction"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hydra 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="introduction.html"
                        title="previous chapter">Introduction</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="containers.html"
                        title="next chapter">&lt;no title&gt;</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="functors-and-c-11-lambdas">
<h1>Functors and C++11 lambdas.<a class="headerlink" href="#functors-and-c-11-lambdas" title="Permalink to this headline">¶</a></h1>
<p>The user’s code is passed to Hydra’s algorithms through functors and C++11 lambda functions.
Hydra adds type information and functionality to functors and lambdas using CRTP idiom.
Functors and lambdas are  entities and are not attached to a specific back-end.
The signatures conventions adopted for functors and lambdas as well as the added functionality
will be discussed in the following lines.</p>
<div class="section" id="functors">
<h2>Functors<a class="headerlink" href="#functors" title="Permalink to this headline">¶</a></h2>
<p>In C++, a functor, sometimes also referred as a function object, is any class or structure that overloads the function call operator <code class="docutils literal"><span class="pre">òperator()</span></code>. In Hydra, all functors derives from the
class template <code class="docutils literal"><span class="pre">hydra::BaseFunctor&lt;Functor,</span> <span class="pre">ReturnType,</span> <span class="pre">NParameters&gt;</span></code>. The template parameters
are described below:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">Functor</span></code> : the type of the functor.</li>
<li><code class="docutils literal"><span class="pre">ReturnType</span></code>: the type of the functor.</li>
<li><code class="docutils literal"><span class="pre">NParameters</span></code>: the number of parameters the functor has.</li>
</ul>
</div></blockquote>
<p>The user needs only to implement the function <code class="docutils literal"><span class="pre">Evaluate()</span></code> and Hydra will take of implementing the function call operator. The signature of <code class="docutils literal"><span class="pre">Evaluate()</span></code> depends on the type of data that will be passed. There are two possibilities:</p>
<blockquote>
<div><p>1. The functor is supposed to take as arguments data with the same type. In this case
the signature of the function call operator will be</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span>       <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
       <span class="n">__host__</span> <span class="n">__device__</span>
       <span class="n">ReturnType</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>where <code class="docutils literal"><span class="pre">T</span></code> is the data type, <code class="docutils literal"><span class="pre">n</span></code> the number of arguments and <code class="docutils literal"><span class="pre">x</span></code> a pointer to an array of arguments. The symbols <code class="docutils literal"><span class="pre">__host__</span> <span class="pre">__device__</span></code> are the necessary to make the functor callable on host and device memory spaces.</p>
<ol class="arabic simple" start="2">
<li>The functor is supposed to take as arguments data with different types. In this case the signature of the function call operator will be</li>
</ol>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">__host__</span> <span class="n">__device__</span>
<span class="n">ReturnType</span> <span class="n">Evaluate</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>where T is the data type, in this case a <code class="docutils literal"><span class="pre">hydra::tuple</span></code> of arguments.</p>
</div></blockquote>
<p>The parameters are represented by the <code class="docutils literal"><span class="pre">hydra::Parameter</span></code>. The parameters can be named, store maximum and minimum values and error. The objects of the class <code class="docutils literal"><span class="pre">hydra::Parameter</span></code> can be instantiated using named field idiom or field list idiom, like this</p>
<p>Hydra does not check the name of the parameters in any way. It is up to the user to care about the contexts where parameters can have or not the same name.
The parameters of a functor are accessible via the <code class="docutils literal"><span class="pre">_par[]</span></code> subscript operator or invoking the <code class="docutils literal"><span class="pre">GetParameter(unsigned</span> <span class="pre">int</span> <span class="pre">i)</span></code> member function</p>
<p>As an example, let’s consider the Gaussian function with mean <span class="math">\(\mu\)</span> and sigma <span class="math">\(\sigma\)</span></p>
<div class="math">
\[f(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{1}{2}(\frac{x-\mu}{\sigma})^2}\]</div>
<p>and suppose the corresponding functor will take as arguments data with same type and evaluate the Gaussian on the first argument. The code in Hydra would look like this</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hydra::Parameters.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="p">...</span>


<span class="k">struct</span> <span class="nl">Gaussian</span><span class="p">:</span> <span class="k">public</span> <span class="o">&lt;</span><span class="n">Gaussian</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>

        <span class="c1">// delete the default constructor.</span>
        <span class="c1">// user always have to inform mean and and sigma</span>
        <span class="n">Gaussian</span><span class="p">()</span><span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="c1">//constructor</span>
        <span class="n">Gaussian</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">Parameter</span> <span class="n">mean</span><span class="p">,</span> <span class="n">hydra</span><span class="o">::</span><span class="n">Parameter</span> <span class="n">sigma</span><span class="p">)</span><span class="o">:</span>
        <span class="n">hydra</span><span class="o">::</span><span class="n">BaseFunctor</span><span class="p">({</span><span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span><span class="p">})</span>
        <span class="p">{}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
        <span class="n">__host__</span> <span class="n">__device__</span>
        <span class="kt">double</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>

                <span class="kt">double</span> <span class="n">mean</span>  <span class="o">=</span> <span class="n">_par</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="kt">double</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">_par</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

                <span class="kt">double</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">mean</span><span class="p">);</span>
                <span class="kt">double</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">;</span>

                <span class="k">return</span> <span class="nf">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">x2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s2</span> <span class="p">))</span><span class="o">/</span><span class="p">(</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s2</span><span class="o">*</span><span class="n">PI</span><span class="p">));</span>
        <span class="p">}</span>

<span class="p">};</span>

<span class="p">...</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mean_name</span><span class="p">(</span><span class="s">&quot;mean&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">Parameter</span><span class="o">::</span><span class="n">Create</span><span class="p">().</span><span class="n">Name</span><span class="p">(</span><span class="n">mean</span><span class="p">).</span><span class="n">Value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">).</span><span class="n">Limits</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">).</span><span class="n">Error</span><span class="p">(</span><span class="mf">0.01</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sigma_name</span><span class="p">(</span><span class="s">&quot;sigma&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">Parameter</span><span class="o">::</span><span class="n">Create</span><span class="p">().</span><span class="n">Name</span><span class="p">(</span><span class="n">sigma</span><span class="p">).</span><span class="n">Value</span><span class="p">(</span><span class="mf">1.0</span><span class="p">).</span><span class="n">Limits</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">).</span><span class="n">Error</span><span class="p">(</span><span class="mf">0.01</span><span class="p">);</span>

<span class="n">Gaussian</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>The Gaussian implementation can be generalized to allow the functor to operate over any type of arguments overloading the <cite>Evaluate()</cite> method and adding a template parameter
to represent which argument the functor will use to evaluate the Gaussian. Se this implementation below</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hydra::Parameters.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Index</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Gaussian</span><span class="p">:</span> <span class="k">public</span> <span class="o">&lt;</span><span class="n">Gaussian</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>

        <span class="c1">// delete the default constructor.</span>
        <span class="c1">// user always have to inform mean and and sigma</span>
        <span class="n">Gaussian</span><span class="p">()</span><span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="c1">//constructor</span>
        <span class="n">Gaussian</span><span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">Parameter</span> <span class="n">mean</span><span class="p">,</span> <span class="n">hydra</span><span class="o">::</span><span class="n">Parameter</span> <span class="n">sigma</span><span class="p">)</span><span class="o">:</span>
        <span class="n">hydra</span><span class="o">::</span><span class="n">BaseFunctor</span><span class="p">({</span><span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span><span class="p">})</span>
        <span class="p">{}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
        <span class="n">__host__</span> <span class="n">__device__</span>
        <span class="kt">double</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>

                <span class="kt">double</span> <span class="n">mean</span>  <span class="o">=</span> <span class="n">_par</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="kt">double</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">_par</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

                <span class="kt">double</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span><span class="o">-</span><span class="n">mean</span><span class="p">);</span>
                <span class="kt">double</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">;</span>

                <span class="k">return</span> <span class="nf">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">x2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s2</span> <span class="p">))</span><span class="o">/</span><span class="p">(</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s2</span><span class="o">*</span><span class="n">PI</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
        <span class="n">__host__</span> <span class="n">__device__</span>
        <span class="kt">double</span> <span class="n">Evaluate</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>

                <span class="kt">double</span> <span class="n">mean</span>  <span class="o">=</span> <span class="n">_par</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="kt">double</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">_par</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

                <span class="kt">double</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">hydra</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="n">hydra</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">mean</span><span class="p">);</span>
                <span class="kt">double</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">;</span>

                <span class="k">return</span> <span class="nf">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">x2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s2</span> <span class="p">))</span><span class="o">/</span><span class="p">(</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s2</span><span class="o">*</span><span class="n">PI</span><span class="p">));</span>
        <span class="p">}</span>


<span class="p">};</span>

<span class="p">...</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mean_name</span><span class="p">(</span><span class="s">&quot;mean&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">Parameter</span><span class="o">::</span><span class="n">Create</span><span class="p">().</span><span class="n">Name</span><span class="p">(</span><span class="n">mean</span><span class="p">).</span><span class="n">Value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">).</span><span class="n">Limits</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">).</span><span class="n">Error</span><span class="p">(</span><span class="mf">0.01</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sigma_name</span><span class="p">(</span><span class="s">&quot;sigma&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">hydra</span><span class="o">::</span><span class="n">Parameter</span><span class="o">::</span><span class="n">Create</span><span class="p">().</span><span class="n">Name</span><span class="p">(</span><span class="n">sigma</span><span class="p">).</span><span class="n">Value</span><span class="p">(</span><span class="mf">1.0</span><span class="p">).</span><span class="n">Limits</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">).</span><span class="n">Error</span><span class="p">(</span><span class="mf">0.01</span><span class="p">);</span>

<span class="n">Gaussian</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">gauss1</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="n">Gaussian</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">gauss2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="containers.html" title="&lt;no title&gt;"
             >next</a> |</li>
        <li class="right" >
          <a href="introduction.html" title="Introduction"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hydra 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Antonio Augusto Alves Junior.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>