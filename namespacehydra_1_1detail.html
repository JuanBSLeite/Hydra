<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacehydra_1_1detail.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hydra::detail Namespace Reference<div class="ingroups"><a class="el" href="group__policy.html">Policy</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1cpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1device"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1host"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1host.html">host</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1tbb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1tbb.html">tbb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structhydra_1_1detail_1_1__merge__and__renumber"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1__merge__and__renumber">_merge_and_renumber</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1__merge__and__renumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1__merge__and__renumber_3_01index__sequence_3_01I1_8_8_8_01_4_00_01index73e1de0a5394a3c55b32c0d1818a4cc9.html">_merge_and_renumber&lt; index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1AddPdfBase.html">AddPdfBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1AddPdfChecker.html">AddPdfChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AddPdfFunctor.html">AddPdfFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AddStatsPHSP.html">AddStatsPHSP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1append__to__type__seq"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq">append_to_type_seq</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1append__to__type__seq"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4">append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__base__of.html">are_base_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__base__of_3_01Base_00_01T_01_4.html">are_base_of&lt; Base, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AverageMother.html">AverageMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">AverageMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1BackendPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">BackendPolicy</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1BackendPolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Cpp_01_4.html">BackendPolicy&lt; Backend::Cpp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Cuda_01_4.html">BackendPolicy&lt; Backend::Cuda &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Device_01_4.html">BackendPolicy&lt; Backend::Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Host_01_4.html">BackendPolicy&lt; Backend::Host &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Omp_01_4.html">BackendPolicy&lt; Backend::Omp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Tbb_01_4.html">BackendPolicy&lt; Backend::Tbb &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1bool__pack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1bool__pack">bool_pack</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1bool__pack"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CacheEvaluator.html">CacheEvaluator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1CanConvert"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1CanConvert">CanConvert</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1CanConvert"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1Caster.html">Caster</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CheckEnergy.html">CheckEnergy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CompareTuples.html">CompareTuples</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1CompositeBase.html">CompositeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1conditions__and.html">conditions_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1conditions__and_3_01Cond_00_01Conds_8_8_8_01_4.html">conditions_and&lt; Cond, Conds... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CovMatrixBinary.html">CovMatrixBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CovMatrixUnary.html">CovMatrixUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1dimensionality.html">dimensionality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1divide__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1divide__result">divide_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1divide__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalMother.html">EvalMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">EvalMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalOnDaughters.html">EvalOnDaughters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalOnDaughtersBinary.html">EvalOnDaughtersBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalOnDaugthers.html">EvalOnDaugthers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FCNWeightsReducerUnary.html">FCNWeightsReducerUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FlagAcceptReject.html">FlagAcceptReject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags generated events as accepted (1) or rejected (0).  <a href="structhydra_1_1detail_1_1FlagAcceptReject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FlagDaugthers.html">FlagDaugthers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1function__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">function_traits</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1function__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_01_6_8_8_8_08_4.html">function_traits&lt; ReturnType(ClassType::*)(Args &amp;...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">function_traits&lt; ReturnType(ClassType::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GenzMalikBox.html">GenzMalikBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetBinCenter.html">GetBinCenter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetBinCenter_3_01T_00_011_01_4.html">GetBinCenter&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetGlobalBin.html">GetGlobalBin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetGlobalBin_3_011_00_01T_01_4.html">GetGlobalBin&lt; 1, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1has__analytical__integral"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1has__analytical__integral">has_analytical_integral</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1has__analytical__integral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1has__analytical__integral_3_01C_00_01Ret_07Args_8_8_8_08_4.html">has_analytical_integral&lt; C, Ret(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else">if_then_else</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4">if_then_else&lt; false, T1, T2 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4">if_then_else&lt; true, T1, T2 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt">if_then_else_tt</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4">if_then_else_tt&lt; false, T1, T2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4">if_then_else_tt&lt; true, T1, T2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base.html">is_homogeneous_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base_3_01A_00_01Tp_00_010_01_4.html">is_homogeneous_base&lt; A, Tp, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple_3_01T_00_01typename_01tag__type_3_01ta964df32a5ab9b829e612ce2772ce8f5.html">is_hydra_convertible_to_tuple&lt; T, typename tag_type&lt; typename T::hydra_convertible_to_tuple_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">is_hydra_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__functor_3_01T_00_01typename_01tag__type_3_01typename_01T_1_1e055cd5a743a62bbab9859fc270746e2.html">is_hydra_functor&lt; T, typename tag_type&lt; typename T::hydra_functor_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__integrator.html">is_hydra_integrator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__integrator_3_01T_00_01typename_01tag__type_3_01typename_01T_ee7a9dff6ae46c6dee1b3e989434722b.html">is_hydra_integrator&lt; T, typename tag_type&lt; typename T::hydra_integrator_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__pdf.html">is_hydra_pdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__pdf_3_01T_00_01typename_01tag__type_3_01typename_01T_1_1hydra__pdf__tag_01_4_1_1type_01_4.html">is_hydra_pdf&lt; T, typename tag_type&lt; typename T::hydra_pdf_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sum__pdf.html">is_hydra_sum_pdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sum__pdf_3_01T_00_01typename_01tag__type_3_01typename_01T_1_cd81614c45a8283de0a328bd93194fef.html">is_hydra_sum_pdf&lt; T, typename tag_type&lt; typename T::hydra_sum_pdf_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">is_instantiation_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__instantiation__of_3_01Template_00_01Template_3_01Args_8_8_8_01_4_01_4.html">is_instantiation_of&lt; Template, Template&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__specialization.html">is_specialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__specialization_3_01REF_3_01Args_8_8_8_01_4_00_01REF_01_4.html">is_specialization&lt; REF&lt; Args... &gt;, REF &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1isAccepted.html">isAccepted</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1IteratorTraits.html">IteratorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1LogLikelihood1.html">LogLikelihood1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1LogLikelihood2.html">LogLikelihood2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence_3_010_01_4.html">make_index_sequence&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence_3_011_01_4.html">make_index_sequence&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1minus__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1minus__result">minus_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1minus__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1multidimensional"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">multidimensional</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1multidimensional"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1multiply__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multiply__result">multiply_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1multiply__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1nearest__int.html">nearest_int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest integer at compile time.  <a href="structhydra_1_1detail_1_1nearest__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ObjSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ObjSelector">ObjSelector</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ObjSelector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ObjSelector_3_01false_01_4.html">ObjSelector&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ObjSelector_3_01true_01_4.html">ObjSelector&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1Parameters.html">Parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1Parameters_3_010_01_4.html">Parameters&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for no-parametrized functor  <a href="classhydra_1_1detail_1_1Parameters_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1PdfBase.html">PdfBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1power.html">power</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1power_3_01B_00_010_01_4.html">power&lt; B, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessBoxesVegas.html">ProcessBoxesVegas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsPlainBinary.html">ProcessCallsPlainBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsPlainUnary.html">ProcessCallsPlainUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsVegas.html">ProcessCallsVegas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsVegas_3_01FUNCTOR_00_01NDimensions_00_01hydra_1_1detail_1_1d02dd45e61a2dbf17b7be7b9bd27e346.html">ProcessCallsVegas&lt; FUNCTOR, NDimensions, hydra::detail::BackendPolicy&lt; BACKEND &gt;, IteratorBackendReal, IteratorBackendUInt, GRND &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikBinaryCall.html">ProcessGenzMalikBinaryCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikBox.html">ProcessGenzMalikBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikUnaryCall.html">ProcessGenzMalikUnaryCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1references__tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1references__tuple__type">references_tuple_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1references__tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1repeat"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1repeat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4">repeat&lt; T, 0, TT &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ResultPHSP"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ResultPHSP">ResultPHSP</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ResultPHSP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ResultVegas"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ResultVegas">ResultVegas</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ResultVegas"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndBreitWigner.html">RndBreitWigner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndCDF.html">RndCDF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndExp.html">RndExp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndFlag.html">RndFlag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndGauss.html">RndGauss</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndTrial.html">RndTrial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndTrial_3_01T_00_01GRND_00_01FUNCTOR_00_011_01_4.html">RndTrial&lt; T, GRND, FUNCTOR, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndUniform.html">RndUniform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1sum__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1sum__result">sum_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1sum__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1SWeights.html">SWeights</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tag__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tag__type">tag_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tag__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">tuple_cat_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4">tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1TypeTraits.html">TypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1TypeTraits_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1complex_3_01T_01_4_01_4.html">TypeTraits&lt; HYDRA_EXTERNAL_NS::thrust::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1unidimensional"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">unidimensional</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1unidimensional"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adc0fec931f3d357c7dd804db2508cd40"><td class="memTemplParams" colspan="2">template&lt;bool... bs&gt; </td></tr>
<tr class="memitem:adc0fec931f3d357c7dd804db2508cd40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#adc0fec931f3d357c7dd804db2508cd40">all_true</a> = std::is_same&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1bool__pack">bool_pack</a>&lt; bs..., true &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1bool__pack">bool_pack</a>&lt; true, bs... &gt; &gt;</td></tr>
<tr class="separator:adc0fec931f3d357c7dd804db2508cd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c72e1aed3a4538dac06a7e816543c23"><td class="memTemplParams" colspan="2">template&lt;class R , class... Ts&gt; </td></tr>
<tr class="memitem:a3c72e1aed3a4538dac06a7e816543c23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a> = <a class="el" href="namespacehydra_1_1detail.html#adc0fec931f3d357c7dd804db2508cd40">all_true</a>&lt; std::is_same&lt; Ts, R &gt;::value... &gt;</td></tr>
<tr class="separator:a3c72e1aed3a4538dac06a7e816543c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee93c31c37a22c22c49c73483cfd0f91"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:aee93c31c37a22c22c49c73483cfd0f91"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aee93c31c37a22c22c49c73483cfd0f91">common_type_t</a> = typename std::common_type&lt; T... &gt;::type</td></tr>
<tr class="separator:aee93c31c37a22c22c49c73483cfd0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8b5125381f09b1ea222ebbbb53ba0887"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra_1_1detail.html#a8b5125381f09b1ea222ebbbb53ba0887aea9c72bdee6f384d88af4eab49530ea8">kInvalidNumber</a> = -111
 }</td></tr>
<tr class="separator:a8b5125381f09b1ea222ebbbb53ba0887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1461b18b118ced9f91233acbe90fd897"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897">Backend</a> { <br />
&#160;&#160;<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a394a4eccb0e1634ec1294f902f5439e2">Host</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897ad7a51d196c98a1057d741a6ebd3d84db">Device</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a0fb8e6fb3bd5e20cae92bc309106fae4">Cpp</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a1b83f5e80dc60afdb33987f3d9ce20bf">Omp</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a0346e63703cdc5752878c4e0623ace64">Tbb</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a3ef47f45ff0de8694163bcfe498e4a89">Cuda</a>
<br />
 }</td></tr>
<tr class="separator:a1461b18b118ced9f91233acbe90fd897"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ea1b8b8cc199f447e160aea1396f9e9"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I&gt; </td></tr>
<tr class="memitem:a9ea1b8b8cc199f447e160aea1396f9e9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I==HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9ea1b8b8cc199f447e160aea1396f9e9">_get_element</a> (const size_t, T &amp;, R *&amp;)</td></tr>
<tr class="separator:a9ea1b8b8cc199f447e160aea1396f9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4514d4ab6052308b21ba01f378e0bdc5"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a4514d4ab6052308b21ba01f378e0bdc5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4514d4ab6052308b21ba01f378e0bdc5">_get_element</a> (const size_t index, T &amp;t, R *&amp;ptr)</td></tr>
<tr class="separator:a4514d4ab6052308b21ba01f378e0bdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356ee10be86b27828f8b71eb4723fd8f"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a356ee10be86b27828f8b71eb4723fd8f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a356ee10be86b27828f8b71eb4723fd8f">accumulate</a> (ArgType &amp;x, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a356ee10be86b27828f8b71eb4723fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86df3c6b6fe3b2b5b2a0bf35f5538e24"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a86df3c6b6fe3b2b5b2a0bf35f5538e24"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a86df3c6b6fe3b2b5b2a0bf35f5538e24">accumulate</a> (ArgType const &amp;x, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a86df3c6b6fe3b2b5b2a0bf35f5538e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7202798eb972c5d3683dc48aa481e1e6"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a7202798eb972c5d3683dc48aa481e1e6"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7202798eb972c5d3683dc48aa481e1e6">accumulate2</a> (ArgType1 &amp;x, ArgType2 &amp;y, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a7202798eb972c5d3683dc48aa481e1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c18a4f04978272c9323fa33d0b03be"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a48c18a4f04978272c9323fa33d0b03be"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a48c18a4f04978272c9323fa33d0b03be">accumulate2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a48c18a4f04978272c9323fa33d0b03be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063e551533f8994778522360e11eba07"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a063e551533f8994778522360e11eba07"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a063e551533f8994778522360e11eba07">add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:a063e551533f8994778522360e11eba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cc0535eaa61a3995028f8a1bc30684"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a24cc0535eaa61a3995028f8a1bc30684"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a24cc0535eaa61a3995028f8a1bc30684">add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;user_parameters, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a24cc0535eaa61a3995028f8a1bc30684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d63e6634cc0bbd8e30d4045f38e5d"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a579d63e6634cc0bbd8e30d4045f38e5d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I==sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a579d63e6634cc0bbd8e30d4045f38e5d">add_tuple_values</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="separator:a579d63e6634cc0bbd8e30d4045f38e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338f13caa00838e2c524eb3d4b20fedf"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:a338f13caa00838e2c524eb3d4b20fedf"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a338f13caa00838e2c524eb3d4b20fedf">add_tuple_values</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;result, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;tpl)</td></tr>
<tr class="separator:a338f13caa00838e2c524eb3d4b20fedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242505600313a45689ba77ca5b8f73b0"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a242505600313a45689ba77ca5b8f73b0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a242505600313a45689ba77ca5b8f73b0">addTuples</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a242505600313a45689ba77ca5b8f73b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba911b630cb7cbd2825c0c4d61bc1ce"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6ba911b630cb7cbd2825c0c4d61bc1ce"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6ba911b630cb7cbd2825c0c4d61bc1ce">addTuples</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a6ba911b630cb7cbd2825c0c4d61bc1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d132d8905e35f2feaa1b77b9d4ccb4"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:ac4d132d8905e35f2feaa1b77b9d4ccb4"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac4d132d8905e35f2feaa1b77b9d4ccb4">addTuplesHelper</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:ac4d132d8905e35f2feaa1b77b9d4ccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de2fcc403354268ee8cd0f3d36369d6"><td class="memItemLeft" align="right" valign="top">OtherTypes void ::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2de2fcc403354268ee8cd0f3d36369d6">assignArrayToTuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a2de2fcc403354268ee8cd0f3d36369d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade860710c76fecbba43b0f56bf39a29a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:ade860710c76fecbba43b0f56bf39a29a"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ade860710c76fecbba43b0f56bf39a29a">assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:ade860710c76fecbba43b0f56bf39a29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304f632a689f2da94f0adec802c2c24c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a304f632a689f2da94f0adec802c2c24c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a304f632a689f2da94f0adec802c2c24c">assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a304f632a689f2da94f0adec802c2c24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e880a2f7b75282f1b1e46b2c3749d0f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a1e880a2f7b75282f1b1e46b2c3749d0f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1e880a2f7b75282f1b1e46b2c3749d0f">assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a1e880a2f7b75282f1b1e46b2c3749d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f84a5781e447b6b5aa848a436af1b96"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a1f84a5781e447b6b5aa848a436af1b96"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1f84a5781e447b6b5aa848a436af1b96">assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a1f84a5781e447b6b5aa848a436af1b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ef566daf99fc14b95ceeb35c69c284"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a33ef566daf99fc14b95ceeb35c69c284"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a33ef566daf99fc14b95ceeb35c69c284">assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a33ef566daf99fc14b95ceeb35c69c284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bc8fc9dd6bd74339e020f9ac32eb39"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a47bc8fc9dd6bd74339e020f9ac32eb39"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a47bc8fc9dd6bd74339e020f9ac32eb39">assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a47bc8fc9dd6bd74339e020f9ac32eb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e009d63340ab91bd8acb68a46a6f5"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... T&gt; </td></tr>
<tr class="memitem:a444e009d63340ab91bd8acb68a46a6f5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a444e009d63340ab91bd8acb68a46a6f5">callOnTuple</a> (F const &amp;f, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;<a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b">tuple</a>)</td></tr>
<tr class="separator:a444e009d63340ab91bd8acb68a46a6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834a71a1ee30e362dc6d79961e2a0cb1"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a834a71a1ee30e362dc6d79961e2a0cb1"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a834a71a1ee30e362dc6d79961e2a0cb1">callOnTupleHelper</a> (F const &amp;f, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;<a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b">tuple</a>, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a834a71a1ee30e362dc6d79961e2a0cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccac2b5a421cca43286e9717d251c69"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Ts&gt; </td></tr>
<tr class="memitem:aeccac2b5a421cca43286e9717d251c69"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aeccac2b5a421cca43286e9717d251c69">CheckValue</a> (T &amp;&amp;x, char const *fmt, char const *file, char const *<a class="el" href="sample__distribution_8inl.html#ad958352cceff412d2aca63efd93d412e">function</a>, unsigned <a class="el" href="namespace_3globalScope_4.html#classint">int</a> line, Ts &amp;&amp;...par)</td></tr>
<tr class="separator:aeccac2b5a421cca43286e9717d251c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084f3753778bfcc03d29a5169f187b2c"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a084f3753778bfcc03d29a5169f187b2c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a084f3753778bfcc03d29a5169f187b2c">divideTuples</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a084f3753778bfcc03d29a5169f187b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3e99d11dc321e6139f662bae279888"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a7e3e99d11dc321e6139f662bae279888"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7e3e99d11dc321e6139f662bae279888">divideTuples</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a7e3e99d11dc321e6139f662bae279888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618a18bb0f77a31f483b924f110e9857"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a618a18bb0f77a31f483b924f110e9857"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a618a18bb0f77a31f483b924f110e9857">divideTuplesHelper</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a618a18bb0f77a31f483b924f110e9857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f81e341b211140f449dda2fd42890f3"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5f81e341b211140f449dda2fd42890f3"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5f81e341b211140f449dda2fd42890f3">eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a>, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, FuncT const &amp;)</td></tr>
<tr class="separator:a5f81e341b211140f449dda2fd42890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8735530d4a1fbdaf571d195f62c7b098"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:a8735530d4a1fbdaf571d195f62c7b098"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8735530d4a1fbdaf571d195f62c7b098">eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, FuncT const &amp;f)</td></tr>
<tr class="separator:a8735530d4a1fbdaf571d195f62c7b098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ea2c9cff400282415093123e68bf5f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:af2ea2c9cff400282415093123e68bf5f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af2ea2c9cff400282415093123e68bf5f">eval_tuple_element</a> (Return_Type &amp;, <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:af2ea2c9cff400282415093123e68bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055ed6d4ace68ec83b0f05abe635c338"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a055ed6d4ace68ec83b0f05abe635c338"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a055ed6d4ace68ec83b0f05abe635c338">eval_tuple_element</a> (Return_Type &amp;r, <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a055ed6d4ace68ec83b0f05abe635c338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Tuple &gt; </td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a96a946dad2a4b9f834836d9b954ad8b6">extract</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> idx, const Tuple &amp;t)</td></tr>
<tr class="separator:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a2d7a14d0022028fba61ddf02a207c"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ... T&gt; </td></tr>
<tr class="memitem:a14a2d7a14d0022028fba61ddf02a207c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ R &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a14a2d7a14d0022028fba61ddf02a207c">get_element</a> (const size_t index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a14a2d7a14d0022028fba61ddf02a207c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e9567de066ffc2ee411b913e068465"><td class="memTemplParams" colspan="2">template&lt;typename Tup &gt; </td></tr>
<tr class="memitem:aa6e9567de066ffc2ee411b913e068465"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa6e9567de066ffc2ee411b913e068465">get_functor_tuple</a> (Tup &amp;pdfs) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#adb5cece13dc19ee98f60f927d7c615c2">get_functor_tuple_helper</a>(pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:aa6e9567de066ffc2ee411b913e068465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5cece13dc19ee98f60f927d7c615c2"><td class="memTemplParams" colspan="2">template&lt;typename Tup , size_t ... index&gt; </td></tr>
<tr class="memitem:adb5cece13dc19ee98f60f927d7c615c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#adb5cece13dc19ee98f60f927d7c615c2">get_functor_tuple_helper</a> (Tup &amp;pdfs, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(pdfs).GetFunctor()...))</td></tr>
<tr class="separator:adb5cece13dc19ee98f60f927d7c615c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c688d5b722922805a5837cac93a6411"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7c688d5b722922805a5837cac93a6411">get_functor_tuple_helper</a> (pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a7c688d5b722922805a5837cac93a6411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I&gt; </td></tr>
<tr class="memitem:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a325f4c7bd791f8e4c8e7777fd1004e6a">get_indexes</a> (size_t, std::array&lt; T, DIM &gt; const &amp;, std::array&lt; T, DIM &gt; &amp;)</td></tr>
<tr class="separator:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba59a3eeef51673f8abf850370c9d55"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I = 0&gt; </td></tr>
<tr class="memitem:a7ba59a3eeef51673f8abf850370c9d55"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7ba59a3eeef51673f8abf850370c9d55">get_indexes</a> (size_t index, std::array&lt; T, DIM &gt; const &amp;depths, std::array&lt; T, DIM &gt; &amp;indexes)</td></tr>
<tr class="separator:a7ba59a3eeef51673f8abf850370c9d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a88db26c2e7e55cbbc893050bde47a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I&gt; </td></tr>
<tr class="memitem:af0a88db26c2e7e55cbbc893050bde47a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af0a88db26c2e7e55cbbc893050bde47a">get_indexes</a> (size_t, T(&amp;)[DIM], T(&amp;)[DIM])</td></tr>
<tr class="separator:af0a88db26c2e7e55cbbc893050bde47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dfa1b8168cdbfcb21263eaa4a0cd2c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I = 0&gt; </td></tr>
<tr class="memitem:a52dfa1b8168cdbfcb21263eaa4a0cd2c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a52dfa1b8168cdbfcb21263eaa4a0cd2c">get_indexes</a> (size_t index, T(&amp;depths)[DIM], T(&amp;indexes)[DIM])</td></tr>
<tr class="separator:a52dfa1b8168cdbfcb21263eaa4a0cd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6983a19fe9f9e2d985b801cbea16b0"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5a6983a19fe9f9e2d985b801cbea16b0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5a6983a19fe9f9e2d985b801cbea16b0">get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a5a6983a19fe9f9e2d985b801cbea16b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d0b80a94e55172ec18dff3dfcf7176"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a02d0b80a94e55172ec18dff3dfcf7176"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02d0b80a94e55172ec18dff3dfcf7176">get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, T &amp;x)</td></tr>
<tr class="separator:a02d0b80a94e55172ec18dff3dfcf7176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a227e0b524804a0ceef56b4a1da1953d4">get_zip_iterator</a> (std::array&lt; Iterator, N &gt;const &amp;array_of_iterators) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#ae97931692365b3a0511b8cce8c4c2510">get_zip_iterator_helper</a>(array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a227e0b524804a0ceef56b4a1da1953d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae9da0535b5305aaf5cfe698c42ebc8d6">get_zip_iterator</a> (IteratorHead head, std::array&lt; IteratorTail, N &gt;const &amp;array_of_iterators) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#ae97931692365b3a0511b8cce8c4c2510">get_zip_iterator_helper</a>(head, array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97931692365b3a0511b8cce8c4c2510"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t ... Index&gt; </td></tr>
<tr class="memitem:ae97931692365b3a0511b8cce8c4c2510"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae97931692365b3a0511b8cce8c4c2510">get_zip_iterator_helper</a> (std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_zip_iterator(HYDRA_EXTERNAL_NS::thrust::make_tuple(array_of_iterators[Index]...)))</td></tr>
<tr class="separator:ae97931692365b3a0511b8cce8c4c2510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382e7e9b98c32dec47168237f889f0af"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </td></tr>
<tr class="memitem:a382e7e9b98c32dec47168237f889f0af"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a382e7e9b98c32dec47168237f889f0af">get_zip_iterator_helper</a> (IteratorHead head, std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_zip_iterator(HYDRA_EXTERNAL_NS::thrust::make_tuple(head, array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a382e7e9b98c32dec47168237f889f0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c0e2d68c6b5f15b5b519229d4d1643"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a61c0e2d68c6b5f15b5b519229d4d1643"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a61c0e2d68c6b5f15b5b519229d4d1643">HasAnalyticalIntegral</a> (Functor &amp;)</td></tr>
<tr class="separator:a61c0e2d68c6b5f15b5b519229d4d1643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618d244958e2ded8465ae85756a011cd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a618d244958e2ded8465ae85756a011cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a618d244958e2ded8465ae85756a011cd">hash_combine</a> (std::size_t &amp;seed, T const &amp;v)</td></tr>
<tr class="separator:a618d244958e2ded8465ae85756a011cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be774a301b3817c97d58c61aa08ba85"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:a0be774a301b3817c97d58c61aa08ba85"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0be774a301b3817c97d58c61aa08ba85">hash_range</a> (It first, It last)</td></tr>
<tr class="separator:a0be774a301b3817c97d58c61aa08ba85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abda9a4b4ec271e3f6c5adf9bc93a3173">hash_range</a> (std::size_t &amp;seed, It first, It last)</td></tr>
<tr class="separator:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b94bf95ea506b05197dbb497cf97d8"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:ac2b94bf95ea506b05197dbb497cf97d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac2b94bf95ea506b05197dbb497cf97d8">invoke</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:ac2b94bf95ea506b05197dbb497cf97d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaca93c22dd2ed068aa89fbf8ff3b678"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:aaaca93c22dd2ed068aa89fbf8ff3b678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aaaca93c22dd2ed068aa89fbf8ff3b678">invoke</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:aaaca93c22dd2ed068aa89fbf8ff3b678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadb98e1ab2655b60e31f95f1fd4ce1b"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:acadb98e1ab2655b60e31f95f1fd4ce1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acadb98e1ab2655b60e31f95f1fd4ce1b">invoke</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:acadb98e1ab2655b60e31f95f1fd4ce1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fe39a5d0a4394580f0bbf09bbf05fa"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a47fe39a5d0a4394580f0bbf09bbf05fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a47fe39a5d0a4394580f0bbf09bbf05fa">invoke</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a47fe39a5d0a4394580f0bbf09bbf05fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b40e8f707d09db5f0316163e818156e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a2b40e8f707d09db5f0316163e818156e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a2b40e8f707d09db5f0316163e818156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150db1fa61de62253b5581bcf2901452"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a150db1fa61de62253b5581bcf2901452"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a150db1fa61de62253b5581bcf2901452">invoke_helper</a> (ArgType const &amp;x, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a150db1fa61de62253b5581bcf2901452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5380f8ef24226d0fdfa988d670efd14c"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:a5380f8ef24226d0fdfa988d670efd14c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5380f8ef24226d0fdfa988d670efd14c">invoke_helper</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y))...))</td></tr>
<tr class="separator:a5380f8ef24226d0fdfa988d670efd14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87094195c5cf716ddd42bf599d0cc71"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:ac87094195c5cf716ddd42bf599d0cc71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac87094195c5cf716ddd42bf599d0cc71">invoke_helper</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(tup)(x, y)...))</td></tr>
<tr class="separator:ac87094195c5cf716ddd42bf599d0cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9360a30d9cffc4d39b34187a56f0bb92">invoke_helper</a> (x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1111a8172c75b5f252be5adc38828af0"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType &gt; </td></tr>
<tr class="memitem:a1111a8172c75b5f252be5adc38828af0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1111a8172c75b5f252be5adc38828af0">invoke_normalized</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a1111a8172c75b5f252be5adc38828af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d54980b3fd3e5fb960701ec95c9bf17"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:a9d54980b3fd3e5fb960701ec95c9bf17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d54980b3fd3e5fb960701ec95c9bf17">invoke_normalized</a> (ArgType &amp;&amp;x, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a9d54980b3fd3e5fb960701ec95c9bf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e09107d2672f4d56c179b193082906"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a71e09107d2672f4d56c179b193082906"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a71e09107d2672f4d56c179b193082906">invoke_normalized_helper</a> (ArgType const &amp;x, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a71e09107d2672f4d56c179b193082906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173eb394103a0e94fbf9abbc1918a894"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a173eb394103a0e94fbf9abbc1918a894">invoke_normalized_helper</a> (x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a173eb394103a0e94fbf9abbc1918a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d93d2ab06e98530b6e09554baff41a"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a80d93d2ab06e98530b6e09554baff41a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a80d93d2ab06e98530b6e09554baff41a">invoke_normalized_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a80d93d2ab06e98530b6e09554baff41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d0de301331608aa91ce3589f9c5c1"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:aad9d0de301331608aa91ce3589f9c5c1"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aad9d0de301331608aa91ce3589f9c5c1">iter_swap</a> (Iterator first, Iterator second)</td></tr>
<tr class="separator:aad9d0de301331608aa91ce3589f9c5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5050bf77c477bccc5db77c507cca743"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:ab5050bf77c477bccc5db77c507cca743"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab5050bf77c477bccc5db77c507cca743">launch_decayer</a> (Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, <a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:ab5050bf77c477bccc5db77c507cca743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4695a02794382f4f997052b425413987"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a4695a02794382f4f997052b425413987"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4695a02794382f4f997052b425413987">launch_decayer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;exec_policy, Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, <a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:a4695a02794382f4f997052b425413987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3416ac487870790342b6b4a21bb607"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter &gt; </td></tr>
<tr class="memitem:aac3416ac487870790342b6b4a21bb607"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aac3416ac487870790342b6b4a21bb607">launch_decayer</a> (IteratorMother <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, IteratorMother <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, IteratorDaughter begin_daugters, <a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:aac3416ac487870790342b6b4a21bb607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af584e2f04699d2c33617ce70a4e886d8"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:af584e2f04699d2c33617ce70a4e886d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af584e2f04699d2c33617ce70a4e886d8">launch_decayer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;exec_policy, IteratorMother <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, IteratorMother <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, IteratorDaughter begin_daugters, <a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:af584e2f04699d2c33617ce70a4e886d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2cc34389ca89449738a46e209133a8"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:a9a2cc34389ca89449738a46e209133a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9a2cc34389ca89449738a46e209133a8">launch_evaluator</a> (Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, <a class="el" href="structhydra_1_1detail_1_1EvalMother.html">detail::EvalMother</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a9a2cc34389ca89449738a46e209133a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272aed700c4b40bbd2639a84507da00d"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename IteratorMother , typename Iterator &gt; </td></tr>
<tr class="memitem:a272aed700c4b40bbd2639a84507da00d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a272aed700c4b40bbd2639a84507da00d">launch_evaluator</a> (IteratorMother mbegin, IteratorMother mend, Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, <a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">detail::EvalMothers</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a272aed700c4b40bbd2639a84507da00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dce458532ae6b3d821a91604dad7895"><td class="memTemplParams" colspan="2">template&lt;size_t N, hydra::detail::Backend BACKEND, typename FUNCTOR , typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:a8dce458532ae6b3d821a91604dad7895"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8dce458532ae6b3d821a91604dad7895">launch_reducer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;const &amp;policy, Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, <a class="el" href="structhydra_1_1detail_1_1AverageMother.html">detail::AverageMother</a>&lt; N, GRND, FUNCTOR &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a8dce458532ae6b3d821a91604dad7895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b536e68d5a5831e546272b56c031ee"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:aa8b536e68d5a5831e546272b56c031ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa8b536e68d5a5831e546272b56c031ee">launch_reducer</a> (Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, <a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">detail::AverageMothers</a>&lt; N, GRND, FUNCTOR &gt; const &amp;evaluator)</td></tr>
<tr class="separator:aa8b536e68d5a5831e546272b56c031ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c762e6869221cc4c1f83e0e0eecf76e"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a9c762e6869221cc4c1f83e0e0eecf76e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9c762e6869221cc4c1f83e0e0eecf76e">make_rtuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t) -&gt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:a9c762e6869221cc4c1f83e0e0eecf76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6155319b5f6821c59294fd4904f8881a"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I&gt; </td></tr>
<tr class="memitem:a6155319b5f6821c59294fd4904f8881a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6155319b5f6821c59294fd4904f8881a">make_rtuple_helper</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;) -&gt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:a6155319b5f6821c59294fd4904f8881a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad2b12c58b82f3d39caa4dffc5ce0faf9">multiply</a> (std::array&lt; T, N &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52459ef87933d78d5ce88feb998bd8bd"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I = 0&gt; </td></tr>
<tr class="memitem:a52459ef87933d78d5ce88feb998bd8bd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a52459ef87933d78d5ce88feb998bd8bd">multiply</a> (std::array&lt; T, N &gt; const &amp;obj, T &amp;result)</td></tr>
<tr class="separator:a52459ef87933d78d5ce88feb998bd8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ac5728d4eb1752434585cba91569a8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:a81ac5728d4eb1752434585cba91569a8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a81ac5728d4eb1752434585cba91569a8">multiply</a> (T(&amp;)[N], T &amp;)</td></tr>
<tr class="separator:a81ac5728d4eb1752434585cba91569a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589472c4a34883f1d511f4dea99e9522"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I = 0&gt; </td></tr>
<tr class="memitem:a589472c4a34883f1d511f4dea99e9522"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a589472c4a34883f1d511f4dea99e9522">multiply</a> (T(&amp;obj)[N], T &amp;result)</td></tr>
<tr class="separator:a589472c4a34883f1d511f4dea99e9522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccf298d7fa30a13efd0d4d848248222"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a2ccf298d7fa30a13efd0d4d848248222"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2ccf298d7fa30a13efd0d4d848248222">multiply_array_tuple</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;fCoeficients)[sizeof...(T)], HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;tpl) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a643a9cfc48d39212a6856ce4a6458280">multiply_array_tuple_helper</a>(fCoeficients, tpl, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; sizeof...(T)&gt;</td></tr>
<tr class="separator:a2ccf298d7fa30a13efd0d4d848248222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a9cfc48d39212a6856ce4a6458280"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , size_t ... I&gt; </td></tr>
<tr class="memitem:a643a9cfc48d39212a6856ce4a6458280"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a>&lt; sizeof...(I), <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a643a9cfc48d39212a6856ce4a6458280">multiply_array_tuple_helper</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;fCoeficients)[sizeof...(I)], Tuple const &amp;tpl, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a643a9cfc48d39212a6856ce4a6458280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d6569d3430295c91bb45ca5a1a0ab"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a2c6d6569d3430295c91bb45ca5a1a0ab"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2c6d6569d3430295c91bb45ca5a1a0ab">multiply_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;)</td></tr>
<tr class="separator:a2c6d6569d3430295c91bb45ca5a1a0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef40c2dd3f84192e6dba30c7a065808"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:abef40c2dd3f84192e6dba30c7a065808"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abef40c2dd3f84192e6dba30c7a065808">multiply_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;t)</td></tr>
<tr class="separator:abef40c2dd3f84192e6dba30c7a065808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307118c3cdbf74e7c7a9382b76727b5f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a307118c3cdbf74e7c7a9382b76727b5f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a307118c3cdbf74e7c7a9382b76727b5f">multiply_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;)</td></tr>
<tr class="separator:a307118c3cdbf74e7c7a9382b76727b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02223b7d9b237863aa694751f86067c2"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a02223b7d9b237863aa694751f86067c2"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02223b7d9b237863aa694751f86067c2">multiply_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a02223b7d9b237863aa694751f86067c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4792d92134b3327ea1018899e43f6d89"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a4792d92134b3327ea1018899e43f6d89"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4792d92134b3327ea1018899e43f6d89">multiplyTuples</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a4792d92134b3327ea1018899e43f6d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169f893461baa838ccc9505c75615b90"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a169f893461baa838ccc9505c75615b90"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a169f893461baa838ccc9505c75615b90">multiplyTuples</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a169f893461baa838ccc9505c75615b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a27a39cd81ae86b1671b38b01b1829"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:ad4a27a39cd81ae86b1671b38b01b1829"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad4a27a39cd81ae86b1671b38b01b1829">multiplyTuplesHelper</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:ad4a27a39cd81ae86b1671b38b01b1829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63701869476f9138ea31be4ef303e7c1"><td class="memTemplParams" colspan="2">template&lt;class BidirIt &gt; </td></tr>
<tr class="memitem:a63701869476f9138ea31be4ef303e7c1"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a63701869476f9138ea31be4ef303e7c1">next_permutation</a> (BidirIt first, BidirIt last)</td></tr>
<tr class="separator:a63701869476f9138ea31be4ef303e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Integer , typename Comparator &gt; </td></tr>
<tr class="memitem:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; Integer &gt;::value, void &gt;::type __hydra_host__ __hydra_device__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0b2e7c87a80dcd5015c2a95ca88f67f1">nth_permutation</a> (Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, Integer n, Comparator comp)</td></tr>
<tr class="separator:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c794172447148190ddb210dd1db8a83"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N, unsigned int I&gt; </td></tr>
<tr class="memitem:a1c794172447148190ddb210dd1db8a83"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ std::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1c794172447148190ddb210dd1db8a83">pow_helper</a> (T const, T &amp;)</td></tr>
<tr class="separator:a1c794172447148190ddb210dd1db8a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N, unsigned int I&gt; </td></tr>
<tr class="memitem:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8f6c0d8fba43367d54ac4e2ce70f8718">pow_helper</a> (T const x, T &amp;r)</td></tr>
<tr class="separator:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff67efcc02bd52b3de9a5f3a142f9547"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:aff67efcc02bd52b3de9a5f3a142f9547"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aff67efcc02bd52b3de9a5f3a142f9547">print_parameters_in_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:aff67efcc02bd52b3de9a5f3a142f9547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30711a263078d73843b26cdc802cdb3f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a30711a263078d73843b26cdc802cdb3f"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a30711a263078d73843b26cdc802cdb3f">print_parameters_in_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a30711a263078d73843b26cdc802cdb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbb591af6fb8f27221cb826ec5cf743"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:acfbb591af6fb8f27221cb826ec5cf743"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acfbb591af6fb8f27221cb826ec5cf743">product</a> (ArgType const &amp;x, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:acfbb591af6fb8f27221cb826ec5cf743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac332ab75d99d58297479b2abd51a6aa9"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ac332ab75d99d58297479b2abd51a6aa9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac332ab75d99d58297479b2abd51a6aa9">product</a> (ArgType &amp;x, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ac332ab75d99d58297479b2abd51a6aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00868a4a0a332adf5621d4516e9aee36"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a00868a4a0a332adf5621d4516e9aee36"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a00868a4a0a332adf5621d4516e9aee36">product2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a00868a4a0a332adf5621d4516e9aee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac617b7fba01a202565c65f9e8e6e2faf"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ac617b7fba01a202565c65f9e8e6e2faf"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac617b7fba01a202565c65f9e8e6e2faf">product2</a> (ArgType1 &amp;x, ArgType2 &amp;y, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ac617b7fba01a202565c65f9e8e6e2faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf7fdd753b13871dc75f4bac1ce205c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a8bf7fdd753b13871dc75f4bac1ce205c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8bf7fdd753b13871dc75f4bac1ce205c">product_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a8bf7fdd753b13871dc75f4bac1ce205c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f1effc46b8b39cf2725fd4eeb119bb"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:ad8f1effc46b8b39cf2725fd4eeb119bb"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad8f1effc46b8b39cf2725fd4eeb119bb">product_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:ad8f1effc46b8b39cf2725fd4eeb119bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3939b105248efa44d81293b0d626bb49"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3939b105248efa44d81293b0d626bb49"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3939b105248efa44d81293b0d626bb49">product_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:a3939b105248efa44d81293b0d626bb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ecd0ff858976f61e4cb99e844ae1df"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a33ecd0ff858976f61e4cb99e844ae1df"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a33ecd0ff858976f61e4cb99e844ae1df">product_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a33ecd0ff858976f61e4cb99e844ae1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb35ba072cba0508cceedd65ad28a058"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:acb35ba072cba0508cceedd65ad28a058"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acb35ba072cba0508cceedd65ad28a058">product_tuple2</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:acb35ba072cba0508cceedd65ad28a058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac719625de76a2d30f5349c7b3b256559"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:ac719625de76a2d30f5349c7b3b256559"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac719625de76a2d30f5349c7b3b256559">product_tuple2</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:ac719625de76a2d30f5349c7b3b256559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef10b1dbcdecce1e1653b819236810b"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a2ef10b1dbcdecce1e1653b819236810b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2ef10b1dbcdecce1e1653b819236810b">product_tuple2</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a2ef10b1dbcdecce1e1653b819236810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745d0ee8999ce4a0ad9673151e42816c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a745d0ee8999ce4a0ad9673151e42816c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a745d0ee8999ce4a0ad9673151e42816c">product_tuple2</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a745d0ee8999ce4a0ad9673151e42816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34392ddaffc23de2780ae0749a03208"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab34392ddaffc23de2780ae0749a03208"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab34392ddaffc23de2780ae0749a03208">product_tuple3</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:ab34392ddaffc23de2780ae0749a03208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab65052d499d9f865047111cdea23ee"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a2ab65052d499d9f865047111cdea23ee"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2ab65052d499d9f865047111cdea23ee">product_tuple3</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:a2ab65052d499d9f865047111cdea23ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f4e39dc40a329a6057ffb730917ab"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab80f4e39dc40a329a6057ffb730917ab"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab80f4e39dc40a329a6057ffb730917ab">product_tuple3</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:ab80f4e39dc40a329a6057ffb730917ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98912ab33ddf035d25186f41b328518"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:af98912ab33ddf035d25186f41b328518"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af98912ab33ddf035d25186f41b328518">product_tuple3</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:af98912ab33ddf035d25186f41b328518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c089b0ed387eb4afd66bc273159b83"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad7c089b0ed387eb4afd66bc273159b83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad7c089b0ed387eb4afd66bc273159b83">ptr_setter</a> (T1 *&amp;ptr, typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; HYDRA_EXTERNAL_NS::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *el)</td></tr>
<tr class="separator:ad7c089b0ed387eb4afd66bc273159b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae973390d66b56d0371b6bc77f489ced4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae973390d66b56d0371b6bc77f489ced4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae973390d66b56d0371b6bc77f489ced4">ptr_setter</a> (T1 *&amp;, typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;!HYDRA_EXTERNAL_NS::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *)</td></tr>
<tr class="separator:ae973390d66b56d0371b6bc77f489ced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46acd298d2f60edf21c334fa8823d65"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ab46acd298d2f60edf21c334fa8823d65"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab46acd298d2f60edf21c334fa8823d65">rotate</a> (Iterator first, Iterator n_first, Iterator last)</td></tr>
<tr class="separator:ab46acd298d2f60edf21c334fa8823d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e518ba4ea2d09339231ca9b58d3af1b"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a3e518ba4ea2d09339231ca9b58d3af1b"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3e518ba4ea2d09339231ca9b58d3af1b">set_functors_in_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;)</td></tr>
<tr class="separator:a3e518ba4ea2d09339231ca9b58d3af1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762905616f6f7eaecdef5d116e9c9032"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a762905616f6f7eaecdef5d116e9c9032"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a762905616f6f7eaecdef5d116e9c9032">set_functors_in_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:a762905616f6f7eaecdef5d116e9c9032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c190a56fcea0dae4ffb6ac42e9ebf4"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:a65c190a56fcea0dae4ffb6ac42e9ebf4"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a65c190a56fcea0dae4ffb6ac42e9ebf4">set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, std::tuple&lt; Tp... &gt; &amp;, Ptr *&amp;)</td></tr>
<tr class="separator:a65c190a56fcea0dae4ffb6ac42e9ebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9154bbb7529e3dd6e3d5e9920101867"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:ae9154bbb7529e3dd6e3d5e9920101867"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae9154bbb7529e3dd6e3d5e9920101867">set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, std::tuple&lt; Tp... &gt; &amp;t, Ptr *&amp;ptr)</td></tr>
<tr class="separator:ae9154bbb7529e3dd6e3d5e9920101867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182f9fd9358a9c673cab53a0dd7ee62c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:a182f9fd9358a9c673cab53a0dd7ee62c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I==HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a182f9fd9358a9c673cab53a0dd7ee62c">set_ptrs_to_tuple</a> (T &amp;, Array_Type **)</td></tr>
<tr class="separator:a182f9fd9358a9c673cab53a0dd7ee62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e9e052ec5ff4f303bc14644aa2077a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:ab8e9e052ec5ff4f303bc14644aa2077a"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab8e9e052ec5ff4f303bc14644aa2077a">set_ptrs_to_tuple</a> (T &amp;t, Array_Type **Array)</td></tr>
<tr class="separator:ab8e9e052ec5ff4f303bc14644aa2077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce3012fbd53a2b5da267b8728a9d8a9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a9ce3012fbd53a2b5da267b8728a9d8a9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9ce3012fbd53a2b5da267b8728a9d8a9">set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a9ce3012fbd53a2b5da267b8728a9d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1d4819c5159a38d63346d9f2f3212c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a2d1d4819c5159a38d63346d9f2f3212c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2d1d4819c5159a38d63346d9f2f3212c">set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t, const T &amp;x)</td></tr>
<tr class="separator:a2d1d4819c5159a38d63346d9f2f3212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26f750aee2b4a44078dec88b62be49b"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2&gt; </td></tr>
<tr class="memitem:ae26f750aee2b4a44078dec88b62be49b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae26f750aee2b4a44078dec88b62be49b">split_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1... &gt; &amp;t1, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T2... &gt; &amp;t2, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1..., T2... &gt; const &amp;t)</td></tr>
<tr class="separator:ae26f750aee2b4a44078dec88b62be49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d5385e5dadaf062d323e7d891b617d"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename ... T&gt; </td></tr>
<tr class="memitem:a05d5385e5dadaf062d323e7d891b617d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a05d5385e5dadaf062d323e7d891b617d">split_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#afef3d0c17270ab8b76059d11e90ac2e2">split_tuple_helper</a>(t, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a05d5385e5dadaf062d323e7d891b617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef3d0c17270ab8b76059d11e90ac2e2"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:afef3d0c17270ab8b76059d11e90ac2e2"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afef3d0c17270ab8b76059d11e90ac2e2">split_tuple_helper</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1... &gt; &amp;t1, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T2... &gt; &amp;t2, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1..., T2... &gt; const &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;)</td></tr>
<tr class="separator:afef3d0c17270ab8b76059d11e90ac2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d06336a86ab7a875909eaccec8fafd"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:a63d06336a86ab7a875909eaccec8fafd"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a63d06336a86ab7a875909eaccec8fafd">split_tuple_helper</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_pair(HYDRA_EXTERNAL_NS::thrust::tie(HYDRA_EXTERNAL_NS::thrust::get&lt; I1 &gt;(t)...), HYDRA_EXTERNAL_NS::thrust::tie(HYDRA_EXTERNAL_NS::thrust::get&lt; I2++sizeof...(I1)&gt;(t)...)))</td></tr>
<tr class="separator:a63d06336a86ab7a875909eaccec8fafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27b1b6e6e6bd585dff3927674fc624c"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:af27b1b6e6e6bd585dff3927674fc624c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af27b1b6e6e6bd585dff3927674fc624c">subtractTuples</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:af27b1b6e6e6bd585dff3927674fc624c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e945e2d1758af244c4d9e0094f0c21a"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a4e945e2d1758af244c4d9e0094f0c21a"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4e945e2d1758af244c4d9e0094f0c21a">subtractTuples</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a4e945e2d1758af244c4d9e0094f0c21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d5c34c5afffd66fe18f0c965a80995"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a52d5c34c5afffd66fe18f0c965a80995"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a52d5c34c5afffd66fe18f0c965a80995">subtractTuplesHelper</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a52d5c34c5afffd66fe18f0c965a80995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf971ae71a711b13306a58d79c0bc854"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:acf971ae71a711b13306a58d79c0bc854"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acf971ae71a711b13306a58d79c0bc854">sum_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:acf971ae71a711b13306a58d79c0bc854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3635135537b34ed7b9b690c046caba3e"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3635135537b34ed7b9b690c046caba3e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3635135537b34ed7b9b690c046caba3e">sum_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a3635135537b34ed7b9b690c046caba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd1ab802c1cf0813124fa1a2084064"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a02dd1ab802c1cf0813124fa1a2084064"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02dd1ab802c1cf0813124fa1a2084064">sum_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a02dd1ab802c1cf0813124fa1a2084064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7809fae326d609265168b9218c81afad"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a7809fae326d609265168b9218c81afad"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7809fae326d609265168b9218c81afad">sum_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a7809fae326d609265168b9218c81afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a768cdf608f16f197f2f28465f4c5"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a672a768cdf608f16f197f2f28465f4c5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a672a768cdf608f16f197f2f28465f4c5">sum_tuple2</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a672a768cdf608f16f197f2f28465f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef0b917781becc3f2a075581dc5f4c5"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:adef0b917781becc3f2a075581dc5f4c5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#adef0b917781becc3f2a075581dc5f4c5">sum_tuple2</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:adef0b917781becc3f2a075581dc5f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40defb7c8c498e5e08f8d3c638cd9246"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a40defb7c8c498e5e08f8d3c638cd9246"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a40defb7c8c498e5e08f8d3c638cd9246">sum_tuple2</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a40defb7c8c498e5e08f8d3c638cd9246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000714f04bcbbe987d1d6571d572d5c4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a000714f04bcbbe987d1d6571d572d5c4"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a000714f04bcbbe987d1d6571d572d5c4">sum_tuple2</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:a000714f04bcbbe987d1d6571d572d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace544073fe8587547403cd411de880a9"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:ace544073fe8587547403cd411de880a9"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ace544073fe8587547403cd411de880a9">tupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;)</td></tr>
<tr class="separator:ace544073fe8587547403cd411de880a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3336cd369617ffa6dc20218a0ba53a4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:af3336cd369617ffa6dc20218a0ba53a4"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af3336cd369617ffa6dc20218a0ba53a4">tupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:af3336cd369617ffa6dc20218a0ba53a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc89e34e642e54d06e05eecd35e6586"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a9fc89e34e642e54d06e05eecd35e6586"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9fc89e34e642e54d06e05eecd35e6586">tupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, typename std::remove_reference&lt; FistType &gt;::type *)</td></tr>
<tr class="separator:a9fc89e34e642e54d06e05eecd35e6586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99132bf945fc5a95c270e53644d7ca60"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a99132bf945fc5a95c270e53644d7ca60"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a99132bf945fc5a95c270e53644d7ca60">tupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, typename std::remove_reference&lt; FistType &gt;::type *Array)</td></tr>
<tr class="separator:a99132bf945fc5a95c270e53644d7ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f5637c265f0432130b335c2590345b"><td class="memTemplParams" colspan="2">template&lt;typename L , typename ReturnType , typename ... Args, size_t N&gt; </td></tr>
<tr class="memitem:a34f5637c265f0432130b335c2590345b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a34f5637c265f0432130b335c2590345b">wrap_lambda_helper</a> (L const &amp;f, ReturnType, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Args... &gt;const &amp;, std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, N &gt; const &amp;parameters) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LambdaWrapper">LambdaWrapper</a>&lt; ReturnType(Args...), L, N &gt;</td></tr>
<tr class="separator:a34f5637c265f0432130b335c2590345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bb853bde138e3ea6bed9b14b07db69"><td class="memTemplParams" colspan="2">template&lt;typename L , typename ReturnType , typename ... Args&gt; </td></tr>
<tr class="memitem:af4bb853bde138e3ea6bed9b14b07db69"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af4bb853bde138e3ea6bed9b14b07db69">wrap_lambda_helper</a> (L const &amp;f, ReturnType, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Args... &gt;const &amp;) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LambdaWrapper">LambdaWrapper</a>&lt; ReturnType(Args...), L, 0 &gt;</td></tr>
<tr class="separator:af4bb853bde138e3ea6bed9b14b07db69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6e5ce23b23364c64166f4c390f0f5f03">make_index_sequence&lt; sizeof...(T) -N &gt;</a></td></tr>
<tr class="separator:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structhydra_1_1detail_1_1__merge__and__renumber" id="structhydra_1_1detail_1_1__merge__and__renumber"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1__merge__and__renumber">&#9670;&nbsp;</a></span>hydra::detail::_merge_and_renumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::_merge_and_renumber</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class Sequence1, class Sequence2&gt;<br />
struct hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1__merge__and__renumber__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1__merge__and__renumber__coll__graph.svg" width="203" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1append__to__type__seq" id="structhydra_1_1detail_1_1append__to__type__seq"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1append__to__type__seq">&#9670;&nbsp;</a></span>hydra::detail::append_to_type_seq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::append_to_type_seq</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename, typename&gt;<br />
struct hydra::detail::append_to_type_seq&lt; typename, typename &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::append_to_type_seq&lt; typename, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1append__to__type__seq__coll__graph.svg" width="184" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename... Ts, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4__coll__graph.svg" width="163" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a96007bd667e99ae9126cb0378e0ea3d9"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1BackendPolicy" id="structhydra_1_1detail_1_1BackendPolicy"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1BackendPolicy">&#9670;&nbsp;</a></span>hydra::detail::BackendPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::BackendPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;Backend BACKEND&gt;<br />
struct hydra::detail::BackendPolicy&lt; BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multivector_container_8inl-example.html#_a4">multivector_container.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::detail::BackendPolicy&lt; BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1BackendPolicy__coll__graph.svg" width="199" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1bool__pack" id="structhydra_1_1detail_1_1bool__pack"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1bool__pack">&#9670;&nbsp;</a></span>hydra::detail::bool_pack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::bool_pack</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool...&gt;<br />
struct hydra::detail::bool_pack&lt;... &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::bool_pack&lt;... &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1bool__pack__coll__graph.svg" width="136" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1CanConvert" id="structhydra_1_1detail_1_1CanConvert"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1CanConvert">&#9670;&nbsp;</a></span>hydra::detail::CanConvert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::CanConvert</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ... A&gt;<br />
struct hydra::detail::CanConvert&lt; A &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::CanConvert&lt; A &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1CanConvert__coll__graph.svg" width="215" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1divide__result" id="structhydra_1_1detail_1_1divide__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1divide__result">&#9670;&nbsp;</a></span>hydra::detail::divide_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::divide_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::divide_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::divide_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1divide__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a11d97c4c8a678e80149749e40e905142"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1function__traits" id="structhydra_1_1detail_1_1function__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1function__traits">&#9670;&nbsp;</a></span>hydra::detail::function_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::function_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::function_traits&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::function_traits&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1function__traits__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1has__analytical__integral" id="structhydra_1_1detail_1_1has__analytical__integral"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1has__analytical__integral">&#9670;&nbsp;</a></span>hydra::detail::has_analytical_integral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::has_analytical_integral</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename, typename T&gt;<br />
struct hydra::detail::has_analytical_integral&lt; typename, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::has_analytical_integral&lt; typename, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1has__analytical__integral__coll__graph.svg" width="144" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else" id="classhydra_1_1detail_1_1if__then__else"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else">&#9670;&nbsp;</a></span>hydra::detail::if_then_else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool C, typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; C, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; C, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else__coll__graph.svg" width="151" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4" id="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else&lt; false, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else&lt; false, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; false, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; false, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4__coll__graph.svg" width="162" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9ccbe22c7f1cb3f5c1a2d408bed944a8"></a>typedef T2</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4" id="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else&lt; true, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else&lt; true, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; true, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; true, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4__coll__graph.svg" width="156" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a34c5da7d250feff5bad076f085abf67b"></a>typedef T1</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt" id="structhydra_1_1detail_1_1if__then__else__tt"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool Condition, template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; Condition, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; Condition, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt__coll__graph.svg" width="204" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4" id="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4__coll__graph.svg" width="178" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad720270512c28116871b746b1e11686e"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4" id="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4__coll__graph.svg" width="171" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6a09c2f0ef798cfca4abdfb2ab115c25"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1minus__result" id="structhydra_1_1detail_1_1minus__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1minus__result">&#9670;&nbsp;</a></span>hydra::detail::minus_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::minus_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::minus_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::minus_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1minus__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="add29ddc4b8fac81ed38f877959086d79"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1multidimensional" id="structhydra_1_1detail_1_1multidimensional"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1multidimensional">&#9670;&nbsp;</a></span>hydra::detail::multidimensional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::multidimensional</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::multidimensional:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1multidimensional__coll__graph.svg" width="210" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1multiply__result" id="structhydra_1_1detail_1_1multiply__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1multiply__result">&#9670;&nbsp;</a></span>hydra::detail::multiply_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::multiply_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::multiply_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::multiply_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1multiply__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9f322e4e5accd44a6a804994aca86b7b"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ObjSelector" id="structhydra_1_1detail_1_1ObjSelector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ObjSelector">&#9670;&nbsp;</a></span>hydra::detail::ObjSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ObjSelector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool FLAG&gt;<br />
struct hydra::detail::ObjSelector&lt; FLAG &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::ObjSelector&lt; FLAG &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ObjSelector__coll__graph.svg" width="180" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1references__tuple__type" id="structhydra_1_1detail_1_1references__tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1references__tuple__type">&#9670;&nbsp;</a></span>hydra::detail::references_tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::references_tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::references_tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::references_tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1references__tuple__type__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a359cfd315141fd3d5bd521ab97ea56ec"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, tuple_of_iterator_references &gt;::<a class="el" href="namespacehydra_1_1detail.html#a359cfd315141fd3d5bd521ab97ea56ec">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1repeat" id="structhydra_1_1detail_1_1repeat"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1repeat">&#9670;&nbsp;</a></span>hydra::detail::repeat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::repeat</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, unsigned int N, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::repeat&lt; T, N, TT &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::repeat&lt; T, N, TT &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1repeat__coll__graph.svg" width="148" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3c8492545a2a08149cff4a2b065d2b6f"></a>typedef typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq">append_to_type_seq</a>&lt; T, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N-1, TT &gt;::<a class="el" href="namespacehydra_1_1detail.html#a3c8492545a2a08149cff4a2b065d2b6f">type</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a3c8492545a2a08149cff4a2b065d2b6f">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4" id="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4">&#9670;&nbsp;</a></span>hydra::detail::repeat&lt; T, 0, TT &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::repeat&lt; T, 0, TT &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::repeat&lt; T, 0, TT &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::repeat&lt; T, 0, TT &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4__coll__graph.svg" width="148" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7e12a8d9a98e19982fedf2fc1b7f207a"></a>typedef TT&lt;&gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ResultPHSP" id="structhydra_1_1detail_1_1ResultPHSP"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ResultPHSP">&#9670;&nbsp;</a></span>hydra::detail::ResultPHSP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ResultPHSP</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::ResultPHSP:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ResultPHSP__coll__graph.svg" width="187" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8d19e0d65eaa393fe0d5f2d578675900"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fM2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9c02ae737d47a9ae27842532c81c07bf"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fMean</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a99c4af82a39dec887b1718c445d47ecd"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fW</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ResultVegas" id="structhydra_1_1detail_1_1ResultVegas"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ResultVegas">&#9670;&nbsp;</a></span>hydra::detail::ResultVegas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ResultVegas</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::ResultVegas:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ResultVegas__coll__graph.svg" width="187" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="addf467fb4f6b03675952501e353748e7"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fM2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a4d239d7f5d0d7b5335cec859fbb263c8"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fMean</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aeac7d6d40e06471c8713e6f589e3d15b"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fN</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1sum__result" id="structhydra_1_1detail_1_1sum__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1sum__result">&#9670;&nbsp;</a></span>hydra::detail::sum_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::sum_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::sum_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::sum_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1sum__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a574a0cf3739a23e067ea7e3b1acc7592"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tag__type" id="structhydra_1_1detail_1_1tag__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tag__type">&#9670;&nbsp;</a></span>hydra::detail::tag_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tag_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class T, class R = void&gt;<br />
struct hydra::detail::tag_type&lt; T, R &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tag_type&lt; T, R &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tag__type__coll__graph.svg" width="130" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a559de10d2ff5e2db2754adf86b3840ec"></a>typedef R</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type" id="structhydra_1_1detail_1_1tuple__cat__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Tuple1, typename Tuple2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type__coll__graph.svg" width="200" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename ... &gt;class Tuple, typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4__coll__graph.svg" width="174" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8a6f9bf15607fb5fb21b31448d616c0e"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__type" id="structhydra_1_1detail_1_1tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__type__coll__graph.svg" width="140" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a94810d8d67c44ca227f9c4a1e456b1d6"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, <a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b">tuple</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a94810d8d67c44ca227f9c4a1e456b1d6">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1unidimensional" id="structhydra_1_1detail_1_1unidimensional"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1unidimensional">&#9670;&nbsp;</a></span>hydra::detail::unidimensional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::unidimensional</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::unidimensional:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1unidimensional__coll__graph.svg" width="198" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adc0fec931f3d357c7dd804db2508cd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0fec931f3d357c7dd804db2508cd40">&#9670;&nbsp;</a></span>all_true</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra_1_1detail.html#adc0fec931f3d357c7dd804db2508cd40">hydra::detail::all_true</a> = typedef std::is_same&lt;<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1bool__pack">bool_pack</a>&lt;bs..., true&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1bool__pack">bool_pack</a>&lt;true, bs...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c72e1aed3a4538dac06a7e816543c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c72e1aed3a4538dac06a7e816543c23">&#9670;&nbsp;</a></span>are_all_same</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">hydra::detail::are_all_same</a> = typedef <a class="el" href="namespacehydra_1_1detail.html#adc0fec931f3d357c7dd804db2508cd40">all_true</a>&lt;std::is_same&lt;Ts, R&gt;::value...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee93c31c37a22c22c49c73483cfd0f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee93c31c37a22c22c49c73483cfd0f91">&#9670;&nbsp;</a></span>common_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra_1_1detail.html#aee93c31c37a22c22c49c73483cfd0f91">hydra::detail::common_type_t</a> = typedef typename std::common_type&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8b5125381f09b1ea222ebbbb53ba0887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5125381f09b1ea222ebbbb53ba0887">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8b5125381f09b1ea222ebbbb53ba0887aea9c72bdee6f384d88af4eab49530ea8"></a>kInvalidNumber&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1461b18b118ced9f91233acbe90fd897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1461b18b118ced9f91233acbe90fd897">&#9670;&nbsp;</a></span>Backend</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897">hydra::detail::Backend</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a394a4eccb0e1634ec1294f902f5439e2"></a>Host&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897ad7a51d196c98a1057d741a6ebd3d84db"></a>Device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a0fb8e6fb3bd5e20cae92bc309106fae4"></a>Cpp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a1b83f5e80dc60afdb33987f3d9ce20bf"></a>Omp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a0346e63703cdc5752878c4e0623ace64"></a>Tbb&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a3ef47f45ff0de8694163bcfe498e4a89"></a>Cuda&#160;</td><td class="fielddoc"></td></tr>
</table>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a15">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9ea1b8b8cc199f447e160aea1396f9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea1b8b8cc199f447e160aea1396f9e9">&#9670;&nbsp;</a></span>_get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I == HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;T&gt;::value), void&gt;::type hydra::detail::_get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4514d4ab6052308b21ba01f378e0bdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4514d4ab6052308b21ba01f378e0bdc5">&#9670;&nbsp;</a></span>_get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , size_t I = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;( I &lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;T&gt;::value), void&gt;::type hydra::detail::_get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a356ee10be86b27828f8b71eb4723fd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356ee10be86b27828f8b71eb4723fd8f">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Return_Type hydra::detail::accumulate </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86df3c6b6fe3b2b5b2a0bf35f5538e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86df3c6b6fe3b2b5b2a0bf35f5538e24">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Return_Type hydra::detail::accumulate </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7202798eb972c5d3683dc48aa481e1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7202798eb972c5d3683dc48aa481e1e6">&#9670;&nbsp;</a></span>accumulate2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Return_Type hydra::detail::accumulate2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48c18a4f04978272c9323fa33d0b03be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c18a4f04978272c9323fa33d0b03be">&#9670;&nbsp;</a></span>accumulate2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Return_Type hydra::detail::accumulate2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a063e551533f8994778522360e11eba07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063e551533f8994778522360e11eba07">&#9670;&nbsp;</a></span>add_parameters_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::add_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a24cc0535eaa61a3995028f8a1bc30684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cc0535eaa61a3995028f8a1bc30684">&#9670;&nbsp;</a></span>add_parameters_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::add_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>user_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a579d63e6634cc0bbd8e30d4045f38e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579d63e6634cc0bbd8e30d4045f38e5d">&#9670;&nbsp;</a></span>add_tuple_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I == sizeof...(T)),void &gt;::type hydra::detail::add_tuple_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a338f13caa00838e2c524eb3d4b20fedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338f13caa00838e2c524eb3d4b20fedf">&#9670;&nbsp;</a></span>add_tuple_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(T)),void &gt;::type hydra::detail::add_tuple_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a242505600313a45689ba77ca5b8f73b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242505600313a45689ba77ca5b8f73b0">&#9670;&nbsp;</a></span>addTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::addTuples </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ba911b630cb7cbd2825c0c4d61bc1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba911b630cb7cbd2825c0c4d61bc1ce">&#9670;&nbsp;</a></span>addTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::addTuples </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4d132d8905e35f2feaa1b77b9d4ccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d132d8905e35f2feaa1b77b9d4ccb4">&#9670;&nbsp;</a></span>addTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::addTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2de2fcc403354268ee8cd0f3d36369d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de2fcc403354268ee8cd0f3d36369d6">&#9670;&nbsp;</a></span>assignArrayToTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OtherTypes void ::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade860710c76fecbba43b0f56bf39a29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade860710c76fecbba43b0f56bf39a29a">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname">[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a304f632a689f2da94f0adec802c2c24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304f632a689f2da94f0adec802c2c24c">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e880a2f7b75282f1b1e46b2c3749d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e880a2f7b75282f1b1e46b2c3749d0f">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname">[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f84a5781e447b6b5aa848a436af1b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f84a5781e447b6b5aa848a436af1b96">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33ef566daf99fc14b95ceeb35c69c284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ef566daf99fc14b95ceeb35c69c284">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname">[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47bc8fc9dd6bd74339e020f9ac32eb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bc8fc9dd6bd74339e020f9ac32eb39">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a444e009d63340ab91bd8acb68a46a6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444e009d63340ab91bd8acb68a46a6f5">&#9670;&nbsp;</a></span>callOnTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::callOnTuple </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a834a71a1ee30e362dc6d79961e2a0cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834a71a1ee30e362dc6d79961e2a0cb1">&#9670;&nbsp;</a></span>callOnTupleHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::callOnTupleHelper </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeccac2b5a421cca43286e9717d251c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccac2b5a421cca43286e9717d251c69">&#9670;&nbsp;</a></span>CheckValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::detail::CheckValue </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a084f3753778bfcc03d29a5169f187b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084f3753778bfcc03d29a5169f187b2c">&#9670;&nbsp;</a></span>divideTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::divideTuples </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e3e99d11dc321e6139f662bae279888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3e99d11dc321e6139f662bae279888">&#9670;&nbsp;</a></span>divideTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::divideTuples </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a618a18bb0f77a31f483b924f110e9857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618a18bb0f77a31f483b924f110e9857">&#9670;&nbsp;</a></span>divideTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::divideTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f81e341b211140f449dda2fd42890f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f81e341b211140f449dda2fd42890f3">&#9670;&nbsp;</a></span>eval_on_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::eval_on_tuple_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8735530d4a1fbdaf571d195f62c7b098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8735530d4a1fbdaf571d195f62c7b098">&#9670;&nbsp;</a></span>eval_on_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::eval_on_tuple_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2ea2c9cff400282415093123e68bf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ea2c9cff400282415093123e68bf5f">&#9670;&nbsp;</a></span>eval_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::eval_tuple_element </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a055ed6d4ace68ec83b0f05abe635c338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055ed6d4ace68ec83b0f05abe635c338">&#9670;&nbsp;</a></span>eval_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::eval_tuple_element </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96a946dad2a4b9f834836d9b954ad8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a946dad2a4b9f834836d9b954ad8b6">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Type hydra::detail::extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14a2d7a14d0022028fba61ddf02a207c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a2d7a14d0022028fba61ddf02a207c">&#9670;&nbsp;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ R&amp; hydra::detail::get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6e9567de066ffc2ee411b913e068465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e9567de066ffc2ee411b913e068465">&#9670;&nbsp;</a></span>get_functor_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::get_functor_tuple </td>
          <td>(</td>
          <td class="paramtype">Tup &amp;&#160;</td>
          <td class="paramname"><em>pdfs</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#adb5cece13dc19ee98f60f927d7c615c2">get_functor_tuple_helper</a>(pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb5cece13dc19ee98f60f927d7c615c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5cece13dc19ee98f60f927d7c615c2">&#9670;&nbsp;</a></span>get_functor_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::get_functor_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">Tup &amp;&#160;</td>
          <td class="paramname"><em>pdfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt;index&gt;(pdfs).GetFunctor()...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c688d5b722922805a5837cac93a6411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c688d5b722922805a5837cac93a6411">&#9670;&nbsp;</a></span>get_functor_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return hydra::detail::get_functor_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">pdfs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a325f4c7bd791f8e4c8e7777fd1004e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325f4c7bd791f8e4c8e7777fd1004e6a">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ba59a3eeef51673f8abf850370c9d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba59a3eeef51673f8abf850370c9d55">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; const &amp;&#160;</td>
          <td class="paramname"><em>depths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0a88db26c2e7e55cbbc893050bde47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a88db26c2e7e55cbbc893050bde47a">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[DIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[DIM]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52dfa1b8168cdbfcb21263eaa4a0cd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dfa1b8168cdbfcb21263eaa4a0cd2c">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>depths</em>[DIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>indexes</em>[DIM]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a6983a19fe9f9e2d985b801cbea16b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6983a19fe9f9e2d985b801cbea16b0">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02d0b80a94e55172ec18dff3dfcf7176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d0b80a94e55172ec18dff3dfcf7176">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a227e0b524804a0ceef56b4a1da1953d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e0b524804a0ceef56b4a1da1953d4">&#9670;&nbsp;</a></span>get_zip_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ auto hydra::detail::get_zip_iterator </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Iterator, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#ae97931692365b3a0511b8cce8c4c2510">get_zip_iterator_helper</a>( array_of_iterators , <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9da0535b5305aaf5cfe698c42ebc8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9da0535b5305aaf5cfe698c42ebc8d6">&#9670;&nbsp;</a></span>get_zip_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ auto hydra::detail::get_zip_iterator </td>
          <td>(</td>
          <td class="paramtype">IteratorHead&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IteratorTail, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#ae97931692365b3a0511b8cce8c4c2510">get_zip_iterator_helper</a>(head, array_of_iterators , <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae97931692365b3a0511b8cce8c4c2510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97931692365b3a0511b8cce8c4c2510">&#9670;&nbsp;</a></span>get_zip_iterator_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , size_t ... Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ auto hydra::detail::get_zip_iterator_helper </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( HYDRA_EXTERNAL_NS::thrust::make_zip_iterator( HYDRA_EXTERNAL_NS::thrust::make_tuple( array_of_iterators[Index]...)) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a382e7e9b98c32dec47168237f889f0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382e7e9b98c32dec47168237f889f0af">&#9670;&nbsp;</a></span>get_zip_iterator_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ auto hydra::detail::get_zip_iterator_helper </td>
          <td>(</td>
          <td class="paramtype">IteratorHead&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( HYDRA_EXTERNAL_NS::thrust::make_zip_iterator( HYDRA_EXTERNAL_NS::thrust::make_tuple(head, array_of_iterators[Index]...)) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61c0e2d68c6b5f15b5b519229d4d1643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c0e2d68c6b5f15b5b519229d4d1643">&#9670;&nbsp;</a></span>HasAnalyticalIntegral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::detail::HasAnalyticalIntegral </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a618d244958e2ded8465ae85756a011cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618d244958e2ded8465ae85756a011cd">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0be774a301b3817c97d58c61aa08ba85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be774a301b3817c97d58c61aa08ba85">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t hydra::detail::hash_range </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abda9a4b4ec271e3f6c5adf9bc93a3173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda9a4b4ec271e3f6c5adf9bc93a3173">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::hash_range </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2b94bf95ea506b05197dbb497cf97d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b94bf95ea506b05197dbb497cf97d8">&#9670;&nbsp;</a></span>invoke() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(std::forward&lt;ArgType&gt;(x), std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaaca93c22dd2ed068aa89fbf8ff3b678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaca93c22dd2ed068aa89fbf8ff3b678">&#9670;&nbsp;</a></span>invoke() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acadb98e1ab2655b60e31f95f1fd4ce1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadb98e1ab2655b60e31f95f1fd4ce1b">&#9670;&nbsp;</a></span>invoke() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>( std::forward&lt;ArgType1&gt;(x), std::forward&lt;ArgType2&gt;(y),  std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47fe39a5d0a4394580f0bbf09bbf05fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fe39a5d0a4394580f0bbf09bbf05fa">&#9670;&nbsp;</a></span>invoke() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>( x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b40e8f707d09db5f0316163e818156e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b40e8f707d09db5f0316163e818156e">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt;index&gt;(std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType&gt;(x))...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a150db1fa61de62253b5581bcf2901452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150db1fa61de62253b5581bcf2901452">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt;index&gt;(tup)(x)...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5380f8ef24226d0fdfa988d670efd14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5380f8ef24226d0fdfa988d670efd14c">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt;index&gt;( std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType1&gt;(x), std::forward&lt;ArgType2&gt;(y))...) )
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac87094195c5cf716ddd42bf599d0cc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87094195c5cf716ddd42bf599d0cc71">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt;index&gt;(tup)(x,y)...) )
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9360a30d9cffc4d39b34187a56f0bb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9360a30d9cffc4d39b34187a56f0bb92">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">x&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tup&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1111a8172c75b5f252be5adc38828af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1111a8172c75b5f252be5adc38828af0">&#9670;&nbsp;</a></span>invoke_normalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke_normalized </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d54980b3fd3e5fb960701ec95c9bf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d54980b3fd3e5fb960701ec95c9bf17">&#9670;&nbsp;</a></span>invoke_normalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke_normalized </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">invoke_helper</a>(std::forward&lt;ArgType&gt;(x), std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71e09107d2672f4d56c179b193082906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e09107d2672f4d56c179b193082906">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt;index&gt;(tup)(x)...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a173eb394103a0e94fbf9abbc1918a894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173eb394103a0e94fbf9abbc1918a894">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">x&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tup&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80d93d2ab06e98530b6e09554baff41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d93d2ab06e98530b6e09554baff41a">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt;index&gt;(std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType&gt;(x))...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad9d0de301331608aa91ce3589f9c5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9d0de301331608aa91ce3589f9c5c1">&#9670;&nbsp;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ void hydra::detail::iter_swap </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5050bf77c477bccc5db77c507cca743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5050bf77c477bccc5db77c507cca743">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4695a02794382f4f997052b425413987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4695a02794382f4f997052b425413987">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename Iterator , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac3416ac487870790342b6b4a21bb607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3416ac487870790342b6b4a21bb607">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorDaughter&#160;</td>
          <td class="paramname"><em>begin_daugters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af584e2f04699d2c33617ce70a4e886d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af584e2f04699d2c33617ce70a4e886d8">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorDaughter&#160;</td>
          <td class="paramname"><em>begin_daugters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a2cc34389ca89449738a46e209133a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2cc34389ca89449738a46e209133a8">&#9670;&nbsp;</a></span>launch_evaluator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_evaluator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1EvalMother.html">detail::EvalMother</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a272aed700c4b40bbd2639a84507da00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272aed700c4b40bbd2639a84507da00d">&#9670;&nbsp;</a></span>launch_evaluator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename IteratorMother , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_evaluator </td>
          <td>(</td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>mbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>mend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">detail::EvalMothers</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dce458532ae6b3d821a91604dad7895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dce458532ae6b3d821a91604dad7895">&#9670;&nbsp;</a></span>launch_reducer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, hydra::detail::Backend BACKEND, typename FUNCTOR , typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a> hydra::detail::launch_reducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1AverageMother.html">detail::AverageMother</a>&lt; N, GRND, FUNCTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b536e68d5a5831e546272b56c031ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b536e68d5a5831e546272b56c031ee">&#9670;&nbsp;</a></span>launch_reducer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a> hydra::detail::launch_reducer </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">detail::AverageMothers</a>&lt; N, GRND, FUNCTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c762e6869221cc4c1f83e0e0eecf76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c762e6869221cc4c1f83e0e0eecf76e">&#9670;&nbsp;</a></span>make_rtuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::make_rtuple </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; HYDRA_EXTERNAL_NS::thrust::tuple&lt;T&amp;...&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6155319b5f6821c59294fd4904f8881a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6155319b5f6821c59294fd4904f8881a">&#9670;&nbsp;</a></span>make_rtuple_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::make_rtuple_helper </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; HYDRA_EXTERNAL_NS::thrust::tuple&lt;T&amp;...&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2b12c58b82f3d39caa4dffc5ce0faf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b12c58b82f3d39caa4dffc5ce0faf9">&#9670;&nbsp;</a></span>multiply() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52459ef87933d78d5ce88feb998bd8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52459ef87933d78d5ce88feb998bd8bd">&#9670;&nbsp;</a></span>multiply() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81ac5728d4eb1752434585cba91569a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ac5728d4eb1752434585cba91569a8">&#9670;&nbsp;</a></span>multiply() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a589472c4a34883f1d511f4dea99e9522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589472c4a34883f1d511f4dea99e9522">&#9670;&nbsp;</a></span>multiply() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>obj</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ccf298d7fa30a13efd0d4d848248222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccf298d7fa30a13efd0d4d848248222">&#9670;&nbsp;</a></span>multiply_array_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::detail::multiply_array_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;)&#160;</td>
          <td class="paramname"><em>fCoeficients</em>[sizeof...(T)], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a643a9cfc48d39212a6856ce4a6458280">multiply_array_tuple_helper</a>(fCoeficients,tpl,<a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;sizeof...(T)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a643a9cfc48d39212a6856ce4a6458280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643a9cfc48d39212a6856ce4a6458280">&#9670;&nbsp;</a></span>multiply_array_tuple_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a>&lt;sizeof...(I), <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt;::type hydra::detail::multiply_array_tuple_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;)&#160;</td>
          <td class="paramname"><em>fCoeficients</em>[sizeof...(I)], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c6d6569d3430295c91bb45ca5a1a0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6d6569d3430295c91bb45ca5a1a0ab">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abef40c2dd3f84192e6dba30c7a065808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef40c2dd3f84192e6dba30c7a065808">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a307118c3cdbf74e7c7a9382b76727b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307118c3cdbf74e7c7a9382b76727b5f">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02223b7d9b237863aa694751f86067c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02223b7d9b237863aa694751f86067c2">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4792d92134b3327ea1018899e43f6d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4792d92134b3327ea1018899e43f6d89">&#9670;&nbsp;</a></span>multiplyTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::multiplyTuples </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a169f893461baa838ccc9505c75615b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169f893461baa838ccc9505c75615b90">&#9670;&nbsp;</a></span>multiplyTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::multiplyTuples </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4a27a39cd81ae86b1671b38b01b1829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a27a39cd81ae86b1671b38b01b1829">&#9670;&nbsp;</a></span>multiplyTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::multiplyTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63701869476f9138ea31be4ef303e7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63701869476f9138ea31be4ef303e7c1">&#9670;&nbsp;</a></span>next_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::detail::next_permutation </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b2e7c87a80dcd5015c2a95ca88f67f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2e7c87a80dcd5015c2a95ca88f67f1">&#9670;&nbsp;</a></span>nth_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Integer , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; Integer &gt;::value, void &gt;::type __hydra_host__ __hydra_device__ hydra::detail::nth_permutation </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c794172447148190ddb210dd1db8a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c794172447148190ddb210dd1db8a83">&#9670;&nbsp;</a></span>pow_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N, unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ std::enable_if&lt;I==N, void &gt;::type hydra::detail::pow_helper </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f6c0d8fba43367d54ac4e2ce70f8718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6c0d8fba43367d54ac4e2ce70f8718">&#9670;&nbsp;</a></span>pow_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N, unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ std::enable_if&lt; (I&lt; N), void &gt;::type hydra::detail::pow_helper </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff67efcc02bd52b3de9a5f3a142f9547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff67efcc02bd52b3de9a5f3a142f9547">&#9670;&nbsp;</a></span>print_parameters_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::print_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30711a263078d73843b26cdc802cdb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30711a263078d73843b26cdc802cdb3f">&#9670;&nbsp;</a></span>print_parameters_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::print_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfbb591af6fb8f27221cb826ec5cf743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbb591af6fb8f27221cb826ec5cf743">&#9670;&nbsp;</a></span>product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Return_Type hydra::detail::product </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac332ab75d99d58297479b2abd51a6aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac332ab75d99d58297479b2abd51a6aa9">&#9670;&nbsp;</a></span>product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Return_Type hydra::detail::product </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00868a4a0a332adf5621d4516e9aee36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00868a4a0a332adf5621d4516e9aee36">&#9670;&nbsp;</a></span>product2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Return_Type hydra::detail::product2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac617b7fba01a202565c65f9e8e6e2faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac617b7fba01a202565c65f9e8e6e2faf">&#9670;&nbsp;</a></span>product2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Return_Type hydra::detail::product2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bf7fdd753b13871dc75f4bac1ce205c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf7fdd753b13871dc75f4bac1ce205c">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8f1effc46b8b39cf2725fd4eeb119bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f1effc46b8b39cf2725fd4eeb119bb">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3939b105248efa44d81293b0d626bb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3939b105248efa44d81293b0d626bb49">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33ecd0ff858976f61e4cb99e844ae1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ecd0ff858976f61e4cb99e844ae1df">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb35ba072cba0508cceedd65ad28a058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb35ba072cba0508cceedd65ad28a058">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac719625de76a2d30f5349c7b3b256559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac719625de76a2d30f5349c7b3b256559">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; (sizeof...(Tp))),void &gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ef10b1dbcdecce1e1653b819236810b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef10b1dbcdecce1e1653b819236810b">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a745d0ee8999ce4a0ad9673151e42816c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745d0ee8999ce4a0ad9673151e42816c">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; (sizeof...(Tp))),void &gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab34392ddaffc23de2780ae0749a03208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34392ddaffc23de2780ae0749a03208">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == N, void&gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ab65052d499d9f865047111cdea23ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab65052d499d9f865047111cdea23ee">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; N),void &gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab80f4e39dc40a329a6057ffb730917ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80f4e39dc40a329a6057ffb730917ab">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == N, void&gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af98912ab33ddf035d25186f41b328518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98912ab33ddf035d25186f41b328518">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; N),void &gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7c089b0ed387eb4afd66bc273159b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c089b0ed387eb4afd66bc273159b83">&#9670;&nbsp;</a></span>ptr_setter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::ptr_setter </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; HYDRA_EXTERNAL_NS::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *&#160;</td>
          <td class="paramname"><em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae973390d66b56d0371b6bc77f489ced4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae973390d66b56d0371b6bc77f489ced4">&#9670;&nbsp;</a></span>ptr_setter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::ptr_setter </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;!HYDRA_EXTERNAL_NS::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab46acd298d2f60edf21c334fa8823d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46acd298d2f60edf21c334fa8823d65">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ Iterator hydra::detail::rotate </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>n_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e518ba4ea2d09339231ca9b58d3af1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e518ba4ea2d09339231ca9b58d3af1b">&#9670;&nbsp;</a></span>set_functors_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_functors_in_tuple </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a762905616f6f7eaecdef5d116e9c9032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762905616f6f7eaecdef5d116e9c9032">&#9670;&nbsp;</a></span>set_functors_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::set_functors_in_tuple </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65c190a56fcea0dae4ffb6ac42e9ebf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c190a56fcea0dae4ffb6ac42e9ebf4">&#9670;&nbsp;</a></span>set_ptr_to_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_ptr_to_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9154bbb7529e3dd6e3d5e9920101867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9154bbb7529e3dd6e3d5e9920101867">&#9670;&nbsp;</a></span>set_ptr_to_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::set_ptr_to_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a182f9fd9358a9c673cab53a0dd7ee62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182f9fd9358a9c673cab53a0dd7ee62c">&#9670;&nbsp;</a></span>set_ptrs_to_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Array_Type , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I == HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;T&gt;::value) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt;Array_Type, T&gt;::value, void&gt;::type hydra::detail::set_ptrs_to_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array_Type **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8e9e052ec5ff4f303bc14644aa2077a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e9e052ec5ff4f303bc14644aa2077a">&#9670;&nbsp;</a></span>set_ptrs_to_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Array_Type , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;T&gt;::value) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt;Array_Type, T&gt;::value, void&gt;::type hydra::detail::set_ptrs_to_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array_Type **&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ce3012fbd53a2b5da267b8728a9d8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce3012fbd53a2b5da267b8728a9d8a9">&#9670;&nbsp;</a></span>set_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d1d4819c5159a38d63346d9f2f3212c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1d4819c5159a38d63346d9f2f3212c">&#9670;&nbsp;</a></span>set_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::set_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae26f750aee2b4a44078dec88b62be49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26f750aee2b4a44078dec88b62be49b">&#9670;&nbsp;</a></span>split_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T1, typename ... T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ void hydra::detail::split_tuple </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T2... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1..., T2... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05d5385e5dadaf062d323e7d891b617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d5385e5dadaf062d323e7d891b617d">&#9670;&nbsp;</a></span>split_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::detail::split_tuple </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#afef3d0c17270ab8b76059d11e90ac2e2">split_tuple_helper</a>( t, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afef3d0c17270ab8b76059d11e90ac2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef3d0c17270ab8b76059d11e90ac2e2">&#9670;&nbsp;</a></span>split_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ void hydra::detail::split_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T2... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1..., T2... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63d06336a86ab7a875909eaccec8fafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d06336a86ab7a875909eaccec8fafd">&#9670;&nbsp;</a></span>split_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t... I1, size_t... I2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::detail::split_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( HYDRA_EXTERNAL_NS::thrust::make_pair(HYDRA_EXTERNAL_NS::thrust::tie( HYDRA_EXTERNAL_NS::thrust::get&lt;I1&gt;(t)... ), HYDRA_EXTERNAL_NS::thrust::tie( HYDRA_EXTERNAL_NS::thrust::get&lt;I2+ + sizeof...(I1)&gt;(t)... ) ) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af27b1b6e6e6bd585dff3927674fc624c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27b1b6e6e6bd585dff3927674fc624c">&#9670;&nbsp;</a></span>subtractTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::subtractTuples </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e945e2d1758af244c4d9e0094f0c21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e945e2d1758af244c4d9e0094f0c21a">&#9670;&nbsp;</a></span>subtractTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::detail::subtractTuples </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52d5c34c5afffd66fe18f0c965a80995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d5c34c5afffd66fe18f0c965a80995">&#9670;&nbsp;</a></span>subtractTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::subtractTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf971ae71a711b13306a58d79c0bc854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf971ae71a711b13306a58d79c0bc854">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3635135537b34ed7b9b690c046caba3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3635135537b34ed7b9b690c046caba3e">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02dd1ab802c1cf0813124fa1a2084064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dd1ab802c1cf0813124fa1a2084064">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7809fae326d609265168b9218c81afad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7809fae326d609265168b9218c81afad">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a672a768cdf608f16f197f2f28465f4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672a768cdf608f16f197f2f28465f4c5">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adef0b917781becc3f2a075581dc5f4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef0b917781becc3f2a075581dc5f4c5">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40defb7c8c498e5e08f8d3c638cd9246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40defb7c8c498e5e08f8d3c638cd9246">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a000714f04bcbbe987d1d6571d572d5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000714f04bcbbe987d1d6571d572d5c4">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace544073fe8587547403cd411de880a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace544073fe8587547403cd411de880a9">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3336cd369617ffa6dc20218a0ba53a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3336cd369617ffa6dc20218a0ba53a4">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fc89e34e642e54d06e05eecd35e6586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc89e34e642e54d06e05eecd35e6586">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::remove_reference&lt; FistType &gt;::type *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99132bf945fc5a95c270e53644d7ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99132bf945fc5a95c270e53644d7ca60">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::remove_reference&lt; FistType &gt;::type *&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34f5637c265f0432130b335c2590345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f5637c265f0432130b335c2590345b">&#9670;&nbsp;</a></span>wrap_lambda_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename ReturnType , typename ... Args, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::wrap_lambda_helper </td>
          <td>(</td>
          <td class="paramtype">L const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Args... &gt;const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LambdaWrapper">LambdaWrapper</a>&lt;ReturnType(Args...), L, N&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4bb853bde138e3ea6bed9b14b07db69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bb853bde138e3ea6bed9b14b07db69">&#9670;&nbsp;</a></span>wrap_lambda_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename ReturnType , typename ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::wrap_lambda_helper </td>
          <td>(</td>
          <td class="paramtype">L const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; Args... &gt;const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LambdaWrapper">LambdaWrapper</a>&lt;ReturnType(Args...), L, 0&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6e5ce23b23364c64166f4c390f0f5f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5ce23b23364c64166f4c390f0f5f03">&#9670;&nbsp;</a></span>make_index_sequence&lt; sizeof...(T) -N &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">hydra::detail::make_index_sequence</a>&lt; sizeof...(T) -N &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li><li class="navelem"><a class="el" href="namespacehydra_1_1detail.html">detail</a></li>
    <li class="footer">Generated on Fri Mar 23 2018 14:51:41 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
