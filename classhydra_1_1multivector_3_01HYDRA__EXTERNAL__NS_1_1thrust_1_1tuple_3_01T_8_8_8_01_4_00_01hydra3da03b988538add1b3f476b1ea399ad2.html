<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra::multivector&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">hydra::multivector&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements storage in SoA layouts for table where all elements have the same type.  
 <a href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">multivector.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hydra::multivector&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra5ba4eaf83b2b725a6c8ae8c6758a60ad.svg" width="219" height="294"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c746b148ab3c39a150f32baf924ebb7"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a1c746b148ab3c39a150f32baf924ebb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1c746b148ab3c39a150f32baf924ebb7">caster_iterator</a> = HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>, typename std::result_of&lt; Functor(tuple_type &amp;)&gt;::type &gt;</td></tr>
<tr class="separator:a1c746b148ab3c39a150f32baf924ebb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84efdbce8d30fb396b40ceb83e4d6356"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a84efdbce8d30fb396b40ceb83e4d6356"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a84efdbce8d30fb396b40ceb83e4d6356">caster_reverse_iterator</a> = HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4b64140850abcb9ae6d43487256da039">reverse_iterator</a>, typename std::result_of&lt; Functor(tuple_type &amp;)&gt;::type &gt;</td></tr>
<tr class="separator:a84efdbce8d30fb396b40ceb83e4d6356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d57e0024621dea4d7f21cb9a422ebd8"><td class="memTemplParams" colspan="2">template&lt;typename Iterators , unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a6d57e0024621dea4d7f21cb9a422ebd8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a> = HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I1, Iterators &gt;::type, typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I2, Iterators &gt;::type, typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; IN, Iterators &gt;::type... &gt; &gt;</td></tr>
<tr class="separator:a6d57e0024621dea4d7f21cb9a422ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b3bcb2c99ed09f8a232792ce7565c7"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a></td></tr>
<tr class="separator:a32b3bcb2c99ed09f8a232792ce7565c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b1a854d91cb0daceef53a4d904fcb7"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; const_iterator_v&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a></td></tr>
<tr class="separator:a59b1a854d91cb0daceef53a4d904fcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed729e1a7325d7c643929f18c847f85"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaed729e1a7325d7c643929f18c847f85">const_reference</a></td></tr>
<tr class="separator:aaed729e1a7325d7c643929f18c847f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b0c80bceeb388efd4b97bd9d1571c5"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; const_reference_v&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a27b0c80bceeb388efd4b97bd9d1571c5">const_reference_t</a></td></tr>
<tr class="separator:a27b0c80bceeb388efd4b97bd9d1571c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c60b067234325a9950fd63c88addae"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a></td></tr>
<tr class="separator:a57c60b067234325a9950fd63c88addae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da821e1ad1a2b61b092d466c8699263"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; const_reverse_iterator_v&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a></td></tr>
<tr class="separator:a2da821e1ad1a2b61b092d466c8699263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6bf370df77efa092ceb7c937d2c388"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a></td></tr>
<tr class="separator:abf6bf370df77efa092ceb7c937d2c388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c60bf21be09355290ad9f2c97d1e74"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab9c60bf21be09355290ad9f2c97d1e74">iterator_category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab9c60bf21be09355290ad9f2c97d1e74">iterator_category</a></td></tr>
<tr class="separator:ab9c60bf21be09355290ad9f2c97d1e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b8f8ca5b9e422458d85b3dcdf02771"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; iterator_v&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a></td></tr>
<tr class="separator:a34b8f8ca5b9e422458d85b3dcdf02771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3030a4e25d70b9d713be16c18ccccc5"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; pointer_v&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae3030a4e25d70b9d713be16c18ccccc5">pointer_t</a></td></tr>
<tr class="separator:ae3030a4e25d70b9d713be16c18ccccc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844278cd4ebf3064ba5b725025c52152"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a></td></tr>
<tr class="separator:a844278cd4ebf3064ba5b725025c52152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af848ba15276745e57f67ad634589d068"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; reference_v&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#af848ba15276745e57f67ad634589d068">reference_t</a></td></tr>
<tr class="separator:af848ba15276745e57f67ad634589d068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b64140850abcb9ae6d43487256da039"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4b64140850abcb9ae6d43487256da039">reverse_iterator</a></td></tr>
<tr class="separator:a4b64140850abcb9ae6d43487256da039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cc96c0cc01ed2232a0b35da2344c95"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; reverse_iterator_v&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a></td></tr>
<tr class="separator:ab3cc96c0cc01ed2232a0b35da2344c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc719f34fb1c5923527fabd627c7c05"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a></td></tr>
<tr class="separator:adcc719f34fb1c5923527fabd627c7c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3025c226894dc0c99125e2fecc7183b"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; vector&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae3025c226894dc0c99125e2fecc7183b">storage_t</a></td></tr>
<tr class="separator:ae3025c226894dc0c99125e2fecc7183b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1951903d7b205a75b4883b45cf316b5d"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a></td></tr>
<tr class="separator:a1951903d7b205a75b4883b45cf316b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a5402761a374092de364010df060d0"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; value_type_v&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a65a5402761a374092de364010df060d0">value_type_t</a></td></tr>
<tr class="separator:a65a5402761a374092de364010df060d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aefdb4e3ad1b0c5b0e2cc66c785fc23ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aefdb4e3ad1b0c5b0e2cc66c785fc23ba">multivector</a> ()=default</td></tr>
<tr class="memdesc:aefdb4e3ad1b0c5b0e2cc66c785fc23ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#aefdb4e3ad1b0c5b0e2cc66c785fc23ba">More...</a><br /></td></tr>
<tr class="separator:aefdb4e3ad1b0c5b0e2cc66c785fc23ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3c383529f928a6bc498796c342c8df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#afb3c383529f928a6bc498796c342c8df">multivector</a> (size_t n)</td></tr>
<tr class="memdesc:afb3c383529f928a6bc498796c342c8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the <code>multivector</code> with <code>n</code> entries.  <a href="#afb3c383529f928a6bc498796c342c8df">More...</a><br /></td></tr>
<tr class="separator:afb3c383529f928a6bc498796c342c8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac559b671f4cee6f207e063876981e2f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ac559b671f4cee6f207e063876981e2f5">multivector</a> (size_t n, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> const &amp;value)</td></tr>
<tr class="memdesc:ac559b671f4cee6f207e063876981e2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the multivector with <code>n</code> copies of <code>value</code> .  <a href="#ac559b671f4cee6f207e063876981e2f5">More...</a><br /></td></tr>
<tr class="separator:ac559b671f4cee6f207e063876981e2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76b0e632c7c7c31a8a0cf8e4fd6459f"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa76b0e632c7c7c31a8a0cf8e4fd6459f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aa76b0e632c7c7c31a8a0cf8e4fd6459f">multivector</a> (<a class="el" href="namespacehydra.html#acf5241d6a56b2040e9cc9ea860b4cbff">hydra::pair</a>&lt; Int, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt; const &amp;<a class="el" href="namespacehydra.html#acf5241d6a56b2040e9cc9ea860b4cbff">pair</a>)</td></tr>
<tr class="memdesc:aa76b0e632c7c7c31a8a0cf8e4fd6459f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the multivector with <code>n</code> copies of <code>value</code> .  <a href="#aa76b0e632c7c7c31a8a0cf8e4fd6459f">More...</a><br /></td></tr>
<tr class="separator:aa76b0e632c7c7c31a8a0cf8e4fd6459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae715ee895f04208bb4ccfdf1b4923acc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae715ee895f04208bb4ccfdf1b4923acc">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:ae715ee895f04208bb4ccfdf1b4923acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ae715ee895f04208bb4ccfdf1b4923acc">More...</a><br /></td></tr>
<tr class="separator:ae715ee895f04208bb4ccfdf1b4923acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4579614257d3d0b77148eeb815dfa18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae4579614257d3d0b77148eeb815dfa18">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ae4579614257d3d0b77148eeb815dfa18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ae4579614257d3d0b77148eeb815dfa18">More...</a><br /></td></tr>
<tr class="separator:ae4579614257d3d0b77148eeb815dfa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af52bc0acacaf7c4aed9aab8490c64e"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a3af52bc0acacaf7c4aed9aab8490c64e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a3af52bc0acacaf7c4aed9aab8490c64e">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:a3af52bc0acacaf7c4aed9aab8490c64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for containers allocated in different backends.  <a href="#a3af52bc0acacaf7c4aed9aab8490c64e">More...</a><br /></td></tr>
<tr class="separator:a3af52bc0acacaf7c4aed9aab8490c64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c766db220df47b11ead3515d23214"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a849c766db220df47b11ead3515d23214"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a849c766db220df47b11ead3515d23214">multivector</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a849c766db220df47b11ead3515d23214"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor builds a <code>multivector</code> from a range.  <a href="#a849c766db220df47b11ead3515d23214">More...</a><br /></td></tr>
<tr class="separator:a849c766db220df47b11ead3515d23214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6b29388153bc9777e275f33de18457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2b6b29388153bc9777e275f33de18457">back</a> ()</td></tr>
<tr class="memdesc:a2b6b29388153bc9777e275f33de18457"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a reference referring to the last element of this vector_dev.  <a href="#a2b6b29388153bc9777e275f33de18457">More...</a><br /></td></tr>
<tr class="separator:a2b6b29388153bc9777e275f33de18457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7aaff3c3949c45c644b5a6558abad61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaed729e1a7325d7c643929f18c847f85">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#af7aaff3c3949c45c644b5a6558abad61">back</a> () const</td></tr>
<tr class="memdesc:af7aaff3c3949c45c644b5a6558abad61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const reference pointing to the last element of this <code>multivector</code>.  <a href="#af7aaff3c3949c45c644b5a6558abad61">More...</a><br /></td></tr>
<tr class="separator:af7aaff3c3949c45c644b5a6558abad61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77193fcd2ee91551284045296ccc4a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a77193fcd2ee91551284045296ccc4a97">begin</a> ()</td></tr>
<tr class="memdesc:a77193fcd2ee91551284045296ccc4a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns an iterator pointing to the beginning of this <code>multivector</code>.  <a href="#a77193fcd2ee91551284045296ccc4a97">More...</a><br /></td></tr>
<tr class="separator:a77193fcd2ee91551284045296ccc4a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2eb94e6cbf85c3ac442e1cfe60bfb1"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a9f2eb94e6cbf85c3ac442e1cfe60bfb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1c746b148ab3c39a150f32baf924ebb7">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a9f2eb94e6cbf85c3ac442e1cfe60bfb1">begin</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a9f2eb94e6cbf85c3ac442e1cfe60bfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2921c2676a2f068b18a38ec867699b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2921c2676a2f068b18a38ec867699b0c">begin</a> () const</td></tr>
<tr class="separator:a2921c2676a2f068b18a38ec867699b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119c5b28e1b18905f016d1b2dc7c7b96"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a119c5b28e1b18905f016d1b2dc7c7b96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a119c5b28e1b18905f016d1b2dc7c7b96">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:a119c5b28e1b18905f016d1b2dc7c7b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707c2ccc76ad832063ab09ff8b50eed7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a707c2ccc76ad832063ab09ff8b50eed7"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a707c2ccc76ad832063ab09ff8b50eed7">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:a707c2ccc76ad832063ab09ff8b50eed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7e2fb2b54bc662dfcca37ee7d9dbe7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a2a7e2fb2b54bc662dfcca37ee7d9dbe7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2a7e2fb2b54bc662dfcca37ee7d9dbe7">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a2a7e2fb2b54bc662dfcca37ee7d9dbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa48c246d808bc291f8e9f9c0f632c04"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:afa48c246d808bc291f8e9f9c0f632c04"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#afa48c246d808bc291f8e9f9c0f632c04">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:afa48c246d808bc291f8e9f9c0f632c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c3c33478743318a9509b3da9a051ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a67c3c33478743318a9509b3da9a051ff">capacity</a> () const</td></tr>
<tr class="memdesc:a67c3c33478743318a9509b3da9a051ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements which have been reserved in this <code>multivector</code>.  <a href="#a67c3c33478743318a9509b3da9a051ff">More...</a><br /></td></tr>
<tr class="separator:a67c3c33478743318a9509b3da9a051ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e9da568676c046d182395651a7b649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae4e9da568676c046d182395651a7b649">cbegin</a> () const</td></tr>
<tr class="separator:ae4e9da568676c046d182395651a7b649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc75ba3c2f7c5a709883ba6977f0150"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a9fc75ba3c2f7c5a709883ba6977f0150"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a9fc75ba3c2f7c5a709883ba6977f0150">cbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a9fc75ba3c2f7c5a709883ba6977f0150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965d83cb3a722ba9cb4f36fc9fbd0468"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a965d83cb3a722ba9cb4f36fc9fbd0468"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a965d83cb3a722ba9cb4f36fc9fbd0468">cbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a965d83cb3a722ba9cb4f36fc9fbd0468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5d6cfa3a792ea451a837bf389eb3dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1b5d6cfa3a792ea451a837bf389eb3dd">cend</a> () const</td></tr>
<tr class="separator:a1b5d6cfa3a792ea451a837bf389eb3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9dc58b4e6bb6b2e4ced52703cb3fa9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:aaa9dc58b4e6bb6b2e4ced52703cb3fa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaa9dc58b4e6bb6b2e4ced52703cb3fa9">cend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:aaa9dc58b4e6bb6b2e4ced52703cb3fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd41da9cf5799bda9c93cb2db6222301"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:afd41da9cf5799bda9c93cb2db6222301"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#afd41da9cf5799bda9c93cb2db6222301">cend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:afd41da9cf5799bda9c93cb2db6222301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297c630b3fa467177defcc94d6c78793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a297c630b3fa467177defcc94d6c78793">clear</a> ()</td></tr>
<tr class="memdesc:a297c630b3fa467177defcc94d6c78793"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method resizes this <code>multivector</code> to 0.  <a href="#a297c630b3fa467177defcc94d6c78793">More...</a><br /></td></tr>
<tr class="separator:a297c630b3fa467177defcc94d6c78793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a96678233e865896ec9f37d5e2f6dd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ac3a96678233e865896ec9f37d5e2f6dd"><td class="memTemplItemLeft" align="right" valign="top">const HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae3025c226894dc0c99125e2fecc7183b">storage_t</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ac3a96678233e865896ec9f37d5e2f6dd">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:ac3a96678233e865896ec9f37d5e2f6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba0423bfcc6fd45b7ca8ed8d3a2988b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1ba0423bfcc6fd45b7ca8ed8d3a2988b">crbegin</a> () const</td></tr>
<tr class="separator:a1ba0423bfcc6fd45b7ca8ed8d3a2988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e565bba54a50f5df4cb805676453f3"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:af9e565bba54a50f5df4cb805676453f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#af9e565bba54a50f5df4cb805676453f3">crbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:af9e565bba54a50f5df4cb805676453f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ddfd2b61a1fb32b365800cceb5cb2b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ae3ddfd2b61a1fb32b365800cceb5cb2b"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae3ddfd2b61a1fb32b365800cceb5cb2b">crbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:ae3ddfd2b61a1fb32b365800cceb5cb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aabf46d8a467bbf5b8e8f1c633cb4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a0aabf46d8a467bbf5b8e8f1c633cb4db">crend</a> () const</td></tr>
<tr class="separator:a0aabf46d8a467bbf5b8e8f1c633cb4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c394866c74d53d99c9d7f06bef1067"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ae1c394866c74d53d99c9d7f06bef1067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae1c394866c74d53d99c9d7f06bef1067">crend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:ae1c394866c74d53d99c9d7f06bef1067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ba2b5a44a46464ae54952fbdf4957b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ae7ba2b5a44a46464ae54952fbdf4957b"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae7ba2b5a44a46464ae54952fbdf4957b">crend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:ae7ba2b5a44a46464ae54952fbdf4957b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c019cf63426849a2c4e824a2fc5c3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2c019cf63426849a2c4e824a2fc5c3b7">empty</a> () const</td></tr>
<tr class="memdesc:a2c019cf63426849a2c4e824a2fc5c3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true iff <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2bf849251082f58ea5191eacedcf9bca" title="Returns the number of elements in this multivector. ">size()</a> == 0.  <a href="#a2c019cf63426849a2c4e824a2fc5c3b7">More...</a><br /></td></tr>
<tr class="separator:a2c019cf63426849a2c4e824a2fc5c3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f2cc5d39ea13012c68cf0fbb2c2e7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a94f2cc5d39ea13012c68cf0fbb2c2e7a">end</a> ()</td></tr>
<tr class="memdesc:a94f2cc5d39ea13012c68cf0fbb2c2e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const_iterator pointing to one element past the last of this <code>multivector</code>.  <a href="#a94f2cc5d39ea13012c68cf0fbb2c2e7a">More...</a><br /></td></tr>
<tr class="separator:a94f2cc5d39ea13012c68cf0fbb2c2e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd26b13326bf0d53d8cdebbf78d8e03"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a9fd26b13326bf0d53d8cdebbf78d8e03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1c746b148ab3c39a150f32baf924ebb7">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a9fd26b13326bf0d53d8cdebbf78d8e03">end</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a9fd26b13326bf0d53d8cdebbf78d8e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c426c9d02e477f2fc4a9b90944d9590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a3c426c9d02e477f2fc4a9b90944d9590">end</a> () const</td></tr>
<tr class="separator:a3c426c9d02e477f2fc4a9b90944d9590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519075c69c29f78918db2b0d600d11b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ae519075c69c29f78918db2b0d600d11b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae519075c69c29f78918db2b0d600d11b">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:ae519075c69c29f78918db2b0d600d11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6103d42e79664ede0fe248ba9783dd9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ac6103d42e79664ede0fe248ba9783dd9"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ac6103d42e79664ede0fe248ba9783dd9">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:ac6103d42e79664ede0fe248ba9783dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa244835303b6bd745b105718c57ee1"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a9aa244835303b6bd745b105718c57ee1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a9aa244835303b6bd745b105718c57ee1">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a9aa244835303b6bd745b105718c57ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cd14b8d2edbbb4140fc4de82cbac29"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ab8cd14b8d2edbbb4140fc4de82cbac29"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab8cd14b8d2edbbb4140fc4de82cbac29">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:ab8cd14b8d2edbbb4140fc4de82cbac29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadba2f5878582df2615548fd4b08a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#afadba2f5878582df2615548fd4b08a29">erase</a> (<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> pos)</td></tr>
<tr class="memdesc:afadba2f5878582df2615548fd4b08a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes the element at position pos.  <a href="#afadba2f5878582df2615548fd4b08a29">More...</a><br /></td></tr>
<tr class="separator:afadba2f5878582df2615548fd4b08a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c5001e6c07fe3463eac6e2a40c8362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ad8c5001e6c07fe3463eac6e2a40c8362">erase</a> (<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> first, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> last)</td></tr>
<tr class="memdesc:ad8c5001e6c07fe3463eac6e2a40c8362"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes the range of elements [first,last) from this <code>multivector</code>.  <a href="#ad8c5001e6c07fe3463eac6e2a40c8362">More...</a><br /></td></tr>
<tr class="separator:ad8c5001e6c07fe3463eac6e2a40c8362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa3c66e1856f152d51223b294b2d765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a0aa3c66e1856f152d51223b294b2d765">front</a> ()</td></tr>
<tr class="memdesc:a0aa3c66e1856f152d51223b294b2d765"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const_reference referring to the first element of this <code>multivector</code>.  <a href="#a0aa3c66e1856f152d51223b294b2d765">More...</a><br /></td></tr>
<tr class="separator:a0aa3c66e1856f152d51223b294b2d765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5682544095acfb776e9f0da2ce3c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaed729e1a7325d7c643929f18c847f85">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abd5682544095acfb776e9f0da2ce3c50">front</a> () const</td></tr>
<tr class="memdesc:abd5682544095acfb776e9f0da2ce3c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a reference pointing to the first element of this <code>multivector</code>.  <a href="#abd5682544095acfb776e9f0da2ce3c50">More...</a><br /></td></tr>
<tr class="separator:abd5682544095acfb776e9f0da2ce3c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d3f404a0189ca6cae8567e4b0090c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a95d3f404a0189ca6cae8567e4b0090c5">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> pos, const <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:a95d3f404a0189ca6cae8567e4b0090c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a single copy of a given exemplar value at the specified position in this <code>multivector</code>.  <a href="#a95d3f404a0189ca6cae8567e4b0090c5">More...</a><br /></td></tr>
<tr class="separator:a95d3f404a0189ca6cae8567e4b0090c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf65d8b3a9ef9631d62b0e98b5621d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#acf65d8b3a9ef9631d62b0e98b5621d51">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> pos, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a> n, const <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:acf65d8b3a9ef9631d62b0e98b5621d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a copy of an exemplar value to a range at the specified position in this <code>multivector</code>.  <a href="#acf65d8b3a9ef9631d62b0e98b5621d51">More...</a><br /></td></tr>
<tr class="separator:acf65d8b3a9ef9631d62b0e98b5621d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84788ec7c4b2ea27577d6c01ecf8cf02"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a84788ec7c4b2ea27577d6c01ecf8cf02"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple, typename HYDRA_EXTERNAL_NS::thrust::detail::remove_const&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt; InputIterator &gt;::type &gt;::type &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt; HYDRA_EXTERNAL_NS::thrust::detail::tuple_of_iterator_references, typename HYDRA_EXTERNAL_NS::thrust::detail::remove_const&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt; InputIterator &gt;::type &gt;::type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a84788ec7c4b2ea27577d6c01ecf8cf02">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> pos, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a84788ec7c4b2ea27577d6c01ecf8cf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a copy of an input range at the specified position in this <code>multivector</code>.  <a href="#a84788ec7c4b2ea27577d6c01ecf8cf02">More...</a><br /></td></tr>
<tr class="separator:a84788ec7c4b2ea27577d6c01ecf8cf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85631d0ae7037d153cb8927c3908671d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a85631d0ae7037d153cb8927c3908671d">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:a85631d0ae7037d153cb8927c3908671d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a85631d0ae7037d153cb8927c3908671d">More...</a><br /></td></tr>
<tr class="separator:a85631d0ae7037d153cb8927c3908671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87c8606fd6b5edc0ce1b48aee25a87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae87c8606fd6b5edc0ce1b48aee25a87f">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ae87c8606fd6b5edc0ce1b48aee25a87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assignment operator.  <a href="#ae87c8606fd6b5edc0ce1b48aee25a87f">More...</a><br /></td></tr>
<tr class="separator:ae87c8606fd6b5edc0ce1b48aee25a87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4739c5d1d4242854331f77b6782fcb1e"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a4739c5d1d4242854331f77b6782fcb1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4739c5d1d4242854331f77b6782fcb1e">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; const &amp;other)</td></tr>
<tr class="memdesc:a4739c5d1d4242854331f77b6782fcb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a4739c5d1d4242854331f77b6782fcb1e">More...</a><br /></td></tr>
<tr class="separator:a4739c5d1d4242854331f77b6782fcb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cc724c54383c5b6e0e34ec3c2c878c"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a76cc724c54383c5b6e0e34ec3c2c878c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1c746b148ab3c39a150f32baf924ebb7">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a76cc724c54383c5b6e0e34ec3c2c878c">operator[]</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a76cc724c54383c5b6e0e34ec3c2c878c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537bb97827c08cb6374c5da7d5b68154"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a537bb97827c08cb6374c5da7d5b68154"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a537bb97827c08cb6374c5da7d5b68154">operator[]</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt; index)</td></tr>
<tr class="separator:a537bb97827c08cb6374c5da7d5b68154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae346a17be36844d76f04126defea65c7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ae346a17be36844d76f04126defea65c7"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae346a17be36844d76f04126defea65c7">operator[]</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt; index) const</td></tr>
<tr class="separator:ae346a17be36844d76f04126defea65c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecee30bd8a1161d6d0d967be5e027fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#acecee30bd8a1161d6d0d967be5e027fd">operator[]</a> (size_t n)</td></tr>
<tr class="memdesc:acecee30bd8a1161d6d0d967be5e027fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in this vector_dev.  <a href="#acecee30bd8a1161d6d0d967be5e027fd">More...</a><br /></td></tr>
<tr class="separator:acecee30bd8a1161d6d0d967be5e027fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b2d89e11a96430ec3cacf28dcdfca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaed729e1a7325d7c643929f18c847f85">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a63b2d89e11a96430ec3cacf28dcdfca8">operator[]</a> (size_t n) const</td></tr>
<tr class="memdesc:a63b2d89e11a96430ec3cacf28dcdfca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript read access to the data contained in this vector_dev.  <a href="#a63b2d89e11a96430ec3cacf28dcdfca8">More...</a><br /></td></tr>
<tr class="separator:a63b2d89e11a96430ec3cacf28dcdfca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f30858b2535fdcf13751b67c8d89dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1f30858b2535fdcf13751b67c8d89dc4">pop_back</a> ()</td></tr>
<tr class="memdesc:a1f30858b2535fdcf13751b67c8d89dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method erases the last element of this <code>multivector</code>, invalidating all iterators and references to it.  <a href="#a1f30858b2535fdcf13751b67c8d89dc4">More...</a><br /></td></tr>
<tr class="separator:a1f30858b2535fdcf13751b67c8d89dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44aa23818a9eec88fc4252230598269f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a44aa23818a9eec88fc4252230598269f">push_back</a> (<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> const &amp;value)</td></tr>
<tr class="memdesc:a44aa23818a9eec88fc4252230598269f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method appends the given element to the end of this <code>multivector</code>.  <a href="#a44aa23818a9eec88fc4252230598269f">More...</a><br /></td></tr>
<tr class="separator:a44aa23818a9eec88fc4252230598269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5b2dbf366e675e9dabdc6c3a0ead1b"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Obj &gt; </td></tr>
<tr class="memitem:a1d5b2dbf366e675e9dabdc6c3a0ead1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1d5b2dbf366e675e9dabdc6c3a0ead1b">push_back</a> (Functor const &amp;functor, Obj const &amp;obj)</td></tr>
<tr class="memdesc:a1d5b2dbf366e675e9dabdc6c3a0ead1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method appends the given element to the end of this <code>multivector</code>.  <a href="#a1d5b2dbf366e675e9dabdc6c3a0ead1b">More...</a><br /></td></tr>
<tr class="separator:a1d5b2dbf366e675e9dabdc6c3a0ead1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a82185a84492a8cb71b5843cc8ee1b"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:af5a82185a84492a8cb71b5843cc8ee1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a84efdbce8d30fb396b40ceb83e4d6356">caster_reverse_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#af5a82185a84492a8cb71b5843cc8ee1b">rbegin</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:af5a82185a84492a8cb71b5843cc8ee1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15bc89d5086698c2b8985074815a99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4b64140850abcb9ae6d43487256da039">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ac15bc89d5086698c2b8985074815a99e">rbegin</a> ()</td></tr>
<tr class="separator:ac15bc89d5086698c2b8985074815a99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd6ab4c5a11d5bcfa23ece7855636a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abcd6ab4c5a11d5bcfa23ece7855636a8">rbegin</a> () const</td></tr>
<tr class="separator:abcd6ab4c5a11d5bcfa23ece7855636a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f1416bb51355ecccbf158673f0955d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ae4f1416bb51355ecccbf158673f0955d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae4f1416bb51355ecccbf158673f0955d">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:ae4f1416bb51355ecccbf158673f0955d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b231db2ddeefc841587fd8ad3d0501"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ae9b231db2ddeefc841587fd8ad3d0501"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae9b231db2ddeefc841587fd8ad3d0501">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:ae9b231db2ddeefc841587fd8ad3d0501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33bd646e3fd4f17a8a64b5ced782e8c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ad33bd646e3fd4f17a8a64b5ced782e8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ad33bd646e3fd4f17a8a64b5ced782e8c">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:ad33bd646e3fd4f17a8a64b5ced782e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc5ab3ca0d6f8aef90e1fa946d956d2"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a0fc5ab3ca0d6f8aef90e1fa946d956d2"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a0fc5ab3ca0d6f8aef90e1fa946d956d2">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a0fc5ab3ca0d6f8aef90e1fa946d956d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852a7405024ee61f44d45657cecb7df2"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a852a7405024ee61f44d45657cecb7df2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a84efdbce8d30fb396b40ceb83e4d6356">caster_reverse_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a852a7405024ee61f44d45657cecb7df2">rend</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a852a7405024ee61f44d45657cecb7df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909ab6a99264033e3997d481d2d741dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4b64140850abcb9ae6d43487256da039">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a909ab6a99264033e3997d481d2d741dd">rend</a> ()</td></tr>
<tr class="separator:a909ab6a99264033e3997d481d2d741dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07530927473567b83e0ce2bb7a7cb053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a07530927473567b83e0ce2bb7a7cb053">rend</a> () const</td></tr>
<tr class="separator:a07530927473567b83e0ce2bb7a7cb053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70fa0d68163c9e02aac180028ec775a"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ae70fa0d68163c9e02aac180028ec775a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae70fa0d68163c9e02aac180028ec775a">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:ae70fa0d68163c9e02aac180028ec775a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d940ac999256fd810c54a8e8b4cea7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:aa7d940ac999256fd810c54a8e8b4cea7"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aa7d940ac999256fd810c54a8e8b4cea7">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:aa7d940ac999256fd810c54a8e8b4cea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0438ce7b6c24b41f6f66f8bf270fb628"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a0438ce7b6c24b41f6f66f8bf270fb628"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a0438ce7b6c24b41f6f66f8bf270fb628">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; c1, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; c2, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a0438ce7b6c24b41f6f66f8bf270fb628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57defa9ece6a201b7216a4a11086e0b2"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a57defa9ece6a201b7216a4a11086e0b2"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57defa9ece6a201b7216a4a11086e0b2">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a57defa9ece6a201b7216a4a11086e0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af641579fdacbf12849a8a159a77cf6ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#af641579fdacbf12849a8a159a77cf6ac">reserve</a> (<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a> <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2bf849251082f58ea5191eacedcf9bca">size</a>)</td></tr>
<tr class="memdesc:af641579fdacbf12849a8a159a77cf6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">If n is less than or equal to <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a67c3c33478743318a9509b3da9a051ff" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a>, this call has no effect.  <a href="#af641579fdacbf12849a8a159a77cf6ac">More...</a><br /></td></tr>
<tr class="separator:af641579fdacbf12849a8a159a77cf6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0237d76e9b27f66422913f15347bc39a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a0237d76e9b27f66422913f15347bc39a">resize</a> (<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a> new_size)</td></tr>
<tr class="memdesc:a0237d76e9b27f66422913f15347bc39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this <code>multivector</code> to the specified number of elements.  <a href="#a0237d76e9b27f66422913f15347bc39a">More...</a><br /></td></tr>
<tr class="separator:a0237d76e9b27f66422913f15347bc39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5088766883a27c1423e07c835a03f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ac5088766883a27c1423e07c835a03f86">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ac5088766883a27c1423e07c835a03f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method shrinks the capacity of this <code>multivector</code> to exactly fit its elements.  <a href="#ac5088766883a27c1423e07c835a03f86">More...</a><br /></td></tr>
<tr class="separator:ac5088766883a27c1423e07c835a03f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf849251082f58ea5191eacedcf9bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2bf849251082f58ea5191eacedcf9bca">size</a> () const</td></tr>
<tr class="memdesc:a2bf849251082f58ea5191eacedcf9bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this <code>multivector</code>.  <a href="#a2bf849251082f58ea5191eacedcf9bca">More...</a><br /></td></tr>
<tr class="separator:a2bf849251082f58ea5191eacedcf9bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ... T, hydra::detail::Backend BACKEND&gt;<br />
class hydra::multivector&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</h3>

<p>This class implements storage in SoA layouts for table where all elements have the same type. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1c746b148ab3c39a150f32baf924ebb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c746b148ab3c39a150f32baf924ebb7">&#9670;&nbsp;</a></span>caster_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1c746b148ab3c39a150f32baf924ebb7">caster_iterator</a> =  HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>, typename std::result_of&lt;Functor(tuple_type&amp;)&gt;::type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84efdbce8d30fb396b40ceb83e4d6356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84efdbce8d30fb396b40ceb83e4d6356">&#9670;&nbsp;</a></span>caster_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a84efdbce8d30fb396b40ceb83e4d6356">caster_reverse_iterator</a> =  HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4b64140850abcb9ae6d43487256da039">reverse_iterator</a>, typename std::result_of&lt;Functor(tuple_type&amp;)&gt;::type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d57e0024621dea4d7f21cb9a422ebd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d57e0024621dea4d7f21cb9a422ebd8">&#9670;&nbsp;</a></span>columns_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Iterators , unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a> =  HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I1, Iterators &gt;::type, typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I2, Iterators &gt;::type, typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; IN, Iterators &gt;::type...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32b3bcb2c99ed09f8a232792ce7565c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b3bcb2c99ed09f8a232792ce7565c7">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59b1a854d91cb0daceef53a4d904fcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b1a854d91cb0daceef53a4d904fcb7">&#9670;&nbsp;</a></span>const_iterator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; const_iterator_v&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaed729e1a7325d7c643929f18c847f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed729e1a7325d7c643929f18c847f85">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaed729e1a7325d7c643929f18c847f85">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27b0c80bceeb388efd4b97bd9d1571c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b0c80bceeb388efd4b97bd9d1571c5">&#9670;&nbsp;</a></span>const_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; const_reference_v&lt;T&gt;...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a27b0c80bceeb388efd4b97bd9d1571c5">const_reference_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57c60b067234325a9950fd63c88addae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c60b067234325a9950fd63c88addae">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2da821e1ad1a2b61b092d466c8699263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da821e1ad1a2b61b092d466c8699263">&#9670;&nbsp;</a></span>const_reverse_iterator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; const_reverse_iterator_v&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf6bf370df77efa092ceb7c937d2c388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6bf370df77efa092ceb7c937d2c388">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9c60bf21be09355290ad9f2c97d1e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c60bf21be09355290ad9f2c97d1e74">&#9670;&nbsp;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab9c60bf21be09355290ad9f2c97d1e74">iterator_category</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab9c60bf21be09355290ad9f2c97d1e74">iterator_category</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34b8f8ca5b9e422458d85b3dcdf02771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b8f8ca5b9e422458d85b3dcdf02771">&#9670;&nbsp;</a></span>iterator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; iterator_v&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3030a4e25d70b9d713be16c18ccccc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3030a4e25d70b9d713be16c18ccccc5">&#9670;&nbsp;</a></span>pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; pointer_v&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae3030a4e25d70b9d713be16c18ccccc5">pointer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a844278cd4ebf3064ba5b725025c52152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844278cd4ebf3064ba5b725025c52152">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af848ba15276745e57f67ad634589d068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af848ba15276745e57f67ad634589d068">&#9670;&nbsp;</a></span>reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; reference_v&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#af848ba15276745e57f67ad634589d068">reference_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b64140850abcb9ae6d43487256da039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b64140850abcb9ae6d43487256da039">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4b64140850abcb9ae6d43487256da039">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3cc96c0cc01ed2232a0b35da2344c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cc96c0cc01ed2232a0b35da2344c95">&#9670;&nbsp;</a></span>reverse_iterator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; reverse_iterator_v&lt;T&gt;...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcc719f34fb1c5923527fabd627c7c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc719f34fb1c5923527fabd627c7c05">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3025c226894dc0c99125e2fecc7183b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3025c226894dc0c99125e2fecc7183b">&#9670;&nbsp;</a></span>storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; vector&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae3025c226894dc0c99125e2fecc7183b">storage_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1951903d7b205a75b4883b45cf316b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1951903d7b205a75b4883b45cf316b5d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65a5402761a374092de364010df060d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a5402761a374092de364010df060d0">&#9670;&nbsp;</a></span>value_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt; value_type_v&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a65a5402761a374092de364010df060d0">value_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aefdb4e3ad1b0c5b0e2cc66c785fc23ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdb4e3ad1b0c5b0e2cc66c785fc23ba">&#9670;&nbsp;</a></span>multivector() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This constructor creates an empty <code>multivector</code>. </p>

</div>
</div>
<a id="afb3c383529f928a6bc498796c342c8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3c383529f928a6bc498796c342c8df">&#9670;&nbsp;</a></span>multivector() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the <code>multivector</code> with <code>n</code> entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to initially create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac559b671f4cee6f207e063876981e2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac559b671f4cee6f207e063876981e2f5">&#9670;&nbsp;</a></span>multivector() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the multivector with <code>n</code> copies of <code>value</code> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of elements </td></tr>
    <tr><td class="paramname">value</td><td>object to copy from (<a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b" title="tuple template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can b...">hydra::tuple</a> or convertible to <a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b" title="tuple template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can b...">hydra::tuple</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa76b0e632c7c7c31a8a0cf8e4fd6459f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76b0e632c7c7c31a8a0cf8e4fd6459f">&#9670;&nbsp;</a></span>multivector() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Int , typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#acf5241d6a56b2040e9cc9ea860b4cbff">hydra::pair</a>&lt; Int, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the multivector with <code>n</code> copies of <code>value</code> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td><a class="el" href="namespacehydra.html#acf5241d6a56b2040e9cc9ea860b4cbff" title="pair template is an alias to the HYDRA_EXTERNAL_NS::thrust::pair structure. ">hydra::pair</a>&lt;size_t, <a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b" title="tuple template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can b...">hydra::tuple&lt;T...&gt;</a> &gt; object to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae715ee895f04208bb4ccfdf1b4923acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae715ee895f04208bb4ccfdf1b4923acc">&#9670;&nbsp;</a></span>multivector() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4579614257d3d0b77148eeb815dfa18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4579614257d3d0b77148eeb815dfa18">&#9670;&nbsp;</a></span>multivector() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3af52bc0acacaf7c4aed9aab8490c64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af52bc0acacaf7c4aed9aab8490c64e">&#9670;&nbsp;</a></span>multivector() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for containers allocated in different backends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a849c766db220df47b11ead3515d23214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849c766db220df47b11ead3515d23214">&#9670;&nbsp;</a></span>multivector() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor builds a <code>multivector</code> from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2b6b29388153bc9777e275f33de18457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6b29388153bc9777e275f33de18457">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a reference referring to the last element of this vector_dev. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="af7aaff3c3949c45c644b5a6558abad61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7aaff3c3949c45c644b5a6558abad61">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaed729e1a7325d7c643929f18c847f85">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const reference pointing to the last element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="a77193fcd2ee91551284045296ccc4a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77193fcd2ee91551284045296ccc4a97">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns an iterator pointing to the beginning of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="a9f2eb94e6cbf85c3ac442e1cfe60bfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2eb94e6cbf85c3ac442e1cfe60bfb1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1c746b148ab3c39a150f32baf924ebb7">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2921c2676a2f068b18a38ec867699b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2921c2676a2f068b18a38ec867699b0c">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a119c5b28e1b18905f016d1b2dc7c7b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119c5b28e1b18905f016d1b2dc7c7b96">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a707c2ccc76ad832063ab09ff8b50eed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707c2ccc76ad832063ab09ff8b50eed7">&#9670;&nbsp;</a></span>begin() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a7e2fb2b54bc662dfcca37ee7d9dbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7e2fb2b54bc662dfcca37ee7d9dbe7">&#9670;&nbsp;</a></span>begin() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa48c246d808bc291f8e9f9c0f632c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa48c246d808bc291f8e9f9c0f632c04">&#9670;&nbsp;</a></span>begin() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67c3c33478743318a9509b3da9a051ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c3c33478743318a9509b3da9a051ff">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements which have been reserved in this <code>multivector</code>. </p>

</div>
</div>
<a id="ae4e9da568676c046d182395651a7b649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e9da568676c046d182395651a7b649">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fc75ba3c2f7c5a709883ba6977f0150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc75ba3c2f7c5a709883ba6977f0150">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a965d83cb3a722ba9cb4f36fc9fbd0468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965d83cb3a722ba9cb4f36fc9fbd0468">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b5d6cfa3a792ea451a837bf389eb3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5d6cfa3a792ea451a837bf389eb3dd">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa9dc58b4e6bb6b2e4ced52703cb3fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9dc58b4e6bb6b2e4ced52703cb3fa9">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd41da9cf5799bda9c93cb2db6222301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd41da9cf5799bda9c93cb2db6222301">&#9670;&nbsp;</a></span>cend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a297c630b3fa467177defcc94d6c78793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297c630b3fa467177defcc94d6c78793">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method resizes this <code>multivector</code> to 0. </p>

</div>
</div>
<a id="ac3a96678233e865896ec9f37d5e2f6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a96678233e865896ec9f37d5e2f6dd">&#9670;&nbsp;</a></span>column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ae3025c226894dc0c99125e2fecc7183b">storage_t</a>&gt;::type&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ba0423bfcc6fd45b7ca8ed8d3a2988b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba0423bfcc6fd45b7ca8ed8d3a2988b">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9e565bba54a50f5df4cb805676453f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e565bba54a50f5df4cb805676453f3">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3ddfd2b61a1fb32b365800cceb5cb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ddfd2b61a1fb32b365800cceb5cb2b">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0aabf46d8a467bbf5b8e8f1c633cb4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aabf46d8a467bbf5b8e8f1c633cb4db">&#9670;&nbsp;</a></span>crend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1c394866c74d53d99c9d7f06bef1067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c394866c74d53d99c9d7f06bef1067">&#9670;&nbsp;</a></span>crend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7ba2b5a44a46464ae54952fbdf4957b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ba2b5a44a46464ae54952fbdf4957b">&#9670;&nbsp;</a></span>crend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c019cf63426849a2c4e824a2fc5c3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c019cf63426849a2c4e824a2fc5c3b7">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns true iff <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2bf849251082f58ea5191eacedcf9bca" title="Returns the number of elements in this multivector. ">size()</a> == 0. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2bf849251082f58ea5191eacedcf9bca" title="Returns the number of elements in this multivector. ">size()</a> == 0; false, otherwise. </dd></dl>

</div>
</div>
<a id="a94f2cc5d39ea13012c68cf0fbb2c2e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f2cc5d39ea13012c68cf0fbb2c2e7a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const_iterator pointing to one element past the last of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a77193fcd2ee91551284045296ccc4a97" title="This method returns an iterator pointing to the beginning of this multivector. ">begin()</a> + <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2bf849251082f58ea5191eacedcf9bca" title="Returns the number of elements in this multivector. ">size()</a>. </dd></dl>

</div>
</div>
<a id="a9fd26b13326bf0d53d8cdebbf78d8e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd26b13326bf0d53d8cdebbf78d8e03">&#9670;&nbsp;</a></span>end() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1c746b148ab3c39a150f32baf924ebb7">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c426c9d02e477f2fc4a9b90944d9590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c426c9d02e477f2fc4a9b90944d9590">&#9670;&nbsp;</a></span>end() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a32b3bcb2c99ed09f8a232792ce7565c7">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae519075c69c29f78918db2b0d600d11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae519075c69c29f78918db2b0d600d11b">&#9670;&nbsp;</a></span>end() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6103d42e79664ede0fe248ba9783dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6103d42e79664ede0fe248ba9783dd9">&#9670;&nbsp;</a></span>end() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9aa244835303b6bd745b105718c57ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa244835303b6bd745b105718c57ee1">&#9670;&nbsp;</a></span>end() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8cd14b8d2edbbb4140fc4de82cbac29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cd14b8d2edbbb4140fc4de82cbac29">&#9670;&nbsp;</a></span>end() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afadba2f5878582df2615548fd4b08a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadba2f5878582df2615548fd4b08a29">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method removes the element at position pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the element at position pos. </dd></dl>

</div>
</div>
<a id="ad8c5001e6c07fe3463eac6e2a40c8362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c5001e6c07fe3463eac6e2a40c8362">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method removes the range of elements [first,last) from this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of elements to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element in the sequence [first,last). </dd></dl>

</div>
</div>
<a id="a0aa3c66e1856f152d51223b294b2d765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa3c66e1856f152d51223b294b2d765">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const_reference referring to the first element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="abd5682544095acfb776e9f0da2ce3c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5682544095acfb776e9f0da2ce3c50">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaed729e1a7325d7c643929f18c847f85">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a reference pointing to the first element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="a95d3f404a0189ca6cae8567e4b0090c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d3f404a0189ca6cae8567e4b0090c5">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a single copy of a given exemplar value at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">x</td><td>The exemplar element to copy &amp; insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted element. </dd></dl>

</div>
</div>
<a id="acf65d8b3a9ef9631d62b0e98b5621d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf65d8b3a9ef9631d62b0e98b5621d51">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a copy of an exemplar value to a range at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position </td></tr>
    <tr><td class="paramname">n</td><td>The number of insertions to perform. </td></tr>
    <tr><td class="paramname">x</td><td>The value to replicate and insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84788ec7c4b2ea27577d6c01ecf8cf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84788ec7c4b2ea27577d6c01ecf8cf02">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt;HYDRA_EXTERNAL_NS::thrust::tuple, typename HYDRA_EXTERNAL_NS::thrust::detail::remove_const&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt; InputIterator &gt;::type &gt;::type &gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt;HYDRA_EXTERNAL_NS::thrust::detail::tuple_of_iterator_references, typename HYDRA_EXTERNAL_NS::thrust::detail::remove_const&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt; InputIterator &gt;::type&gt;::type &gt;::value, void&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#abf6bf370df77efa092ceb7c937d2c388">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a copy of an input range at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the range to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html&gt;Input Iterator&lt;/a&gt;,
                      and \p InputIterator's \c value_type is a model of &lt;a href="<a href="http://www.sgi.com/tech/stl/Assignable.html">http://www.sgi.com/tech/stl/Assignable.html</a>"&gt;Assignable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85631d0ae7037d153cb8927c3908671d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85631d0ae7037d153cb8927c3908671d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae87c8606fd6b5edc0ce1b48aee25a87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87c8606fd6b5edc0ce1b48aee25a87f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4739c5d1d4242854331f77b6782fcb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4739c5d1d4242854331f77b6782fcb1e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a76cc724c54383c5b6e0e34ec3c2c878c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cc724c54383c5b6e0e34ec3c2c878c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1c746b148ab3c39a150f32baf924ebb7">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a537bb97827c08cb6374c5da7d5b68154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537bb97827c08cb6374c5da7d5b68154">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a34b8f8ca5b9e422458d85b3dcdf02771">iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae346a17be36844d76f04126defea65c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae346a17be36844d76f04126defea65c7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a59b1a854d91cb0daceef53a4d904fcb7">const_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acecee30bd8a1161d6d0d967be5e027fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecee30bd8a1161d6d0d967be5e027fd">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a844278cd4ebf3064ba5b725025c52152">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in this vector_dev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a id="a63b2d89e11a96430ec3cacf28dcdfca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b2d89e11a96430ec3cacf28dcdfca8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#aaed729e1a7325d7c643929f18c847f85">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript read access to the data contained in this vector_dev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a id="a1f30858b2535fdcf13751b67c8d89dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f30858b2535fdcf13751b67c8d89dc4">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method erases the last element of this <code>multivector</code>, invalidating all iterators and references to it. </p>

</div>
</div>
<a id="a44aa23818a9eec88fc4252230598269f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44aa23818a9eec88fc4252230598269f">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a1951903d7b205a75b4883b45cf316b5d">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method appends the given element to the end of this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d5b2dbf366e675e9dabdc6c3a0ead1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5b2dbf366e675e9dabdc6c3a0ead1b">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor , typename Obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Obj const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method appends the given element to the end of this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The element to append. </td></tr>
    <tr><td class="paramname">functor</td><td>Functor to convert the element to a value_type tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a82185a84492a8cb71b5843cc8ee1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a82185a84492a8cb71b5843cc8ee1b">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a84efdbce8d30fb396b40ceb83e4d6356">caster_reverse_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac15bc89d5086698c2b8985074815a99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15bc89d5086698c2b8985074815a99e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4b64140850abcb9ae6d43487256da039">reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abcd6ab4c5a11d5bcfa23ece7855636a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd6ab4c5a11d5bcfa23ece7855636a8">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4f1416bb51355ecccbf158673f0955d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f1416bb51355ecccbf158673f0955d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b231db2ddeefc841587fd8ad3d0501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b231db2ddeefc841587fd8ad3d0501">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad33bd646e3fd4f17a8a64b5ced782e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33bd646e3fd4f17a8a64b5ced782e8c">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fc5ab3ca0d6f8aef90e1fa946d956d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc5ab3ca0d6f8aef90e1fa946d956d2">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a852a7405024ee61f44d45657cecb7df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852a7405024ee61f44d45657cecb7df2">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a84efdbce8d30fb396b40ceb83e4d6356">caster_reverse_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a909ab6a99264033e3997d481d2d741dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909ab6a99264033e3997d481d2d741dd">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a4b64140850abcb9ae6d43487256da039">reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07530927473567b83e0ce2bb7a7cb053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07530927473567b83e0ce2bb7a7cb053">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a57c60b067234325a9950fd63c88addae">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae70fa0d68163c9e02aac180028ec775a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70fa0d68163c9e02aac180028ec775a">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7d940ac999256fd810c54a8e8b4cea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d940ac999256fd810c54a8e8b4cea7">&#9670;&nbsp;</a></span>rend() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#ab3cc96c0cc01ed2232a0b35da2344c95">reverse_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0438ce7b6c24b41f6f66f8bf270fb628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0438ce7b6c24b41f6f66f8bf270fb628">&#9670;&nbsp;</a></span>rend() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a6d57e0024621dea4d7f21cb9a422ebd8">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57defa9ece6a201b7216a4a11086e0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57defa9ece6a201b7216a4a11086e0b2">&#9670;&nbsp;</a></span>rend() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2da821e1ad1a2b61b092d466c8699263">const_reverse_iterator_t</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af641579fdacbf12849a8a159a77cf6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af641579fdacbf12849a8a159a77cf6ac">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If n is less than or equal to <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a67c3c33478743318a9509b3da9a051ff" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a>, this call has no effect. </p>
<p>Otherwise, this method is a request for allocation of additional memory. If the request is successful, then <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a67c3c33478743318a9509b3da9a051ff" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a> is greater than or equal to n; otherwise, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a67c3c33478743318a9509b3da9a051ff" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a> is unchanged. In either case, <a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#a2bf849251082f58ea5191eacedcf9bca" title="Returns the number of elements in this multivector. ">size()</a> is unchanged. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds max_size(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0237d76e9b27f66422913f15347bc39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0237d76e9b27f66422913f15347bc39a">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes this <code>multivector</code> to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements this <code>multivector</code> should contain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds max_size().</td></tr>
  </table>
  </dd>
</dl>
<p>This method will resize this <code>multivector</code> to the specified number of elements. If the number is smaller than this <code>multivector's</code> current size this <code>multivector</code> is truncated, otherwise this <code>multivector</code> is extended and new default initialized elements are populated. </p>

</div>
</div>
<a id="ac5088766883a27c1423e07c835a03f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5088766883a27c1423e07c835a03f86">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method shrinks the capacity of this <code>multivector</code> to exactly fit its elements. </p>

</div>
</div>
<a id="a2bf849251082f58ea5191eacedcf9bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf849251082f58ea5191eacedcf9bca">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#adcc719f34fb1c5923527fabd627c7c05">size_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in this <code>multivector</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="">multivector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li><li class="navelem"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html">multivector&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></li>
    <li class="footer">Generated on Fri Mar 23 2018 12:08:58 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
