<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
   <div id="projectbrief">A header only templated C++ library to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00648.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hydra Namespace Reference<div class="ingroups"><a class="el" href="a00646.html">Policy</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic policies definition.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00652"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00652.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00654"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00654.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00656"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00656.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00663"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00663.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00658"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00658.html">host</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00660"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00660.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00650"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00650.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00662"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00662.html">tbb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01273.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01845"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00643.html#a01845">BaseFunctor</a></td></tr>
<tr class="memdesc:a01845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all functors in hydra.  <a href="a00643.html#a01845">More...</a><br /></td></tr>
<tr class="separator:a01845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01217"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01217">Cache</a></td></tr>
<tr class="separator:a01217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01221"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Cache&lt; hydra::detail::BackendPolicy&lt; BACKEND &gt;, Functors... &gt;</b></td></tr>
<tr class="separator:a01221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01225"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01225">Chains</a></td></tr>
<tr class="separator:a01225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01229"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Chains&lt; Decays&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;... &gt;</b></td></tr>
<tr class="memdesc:a01229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory storage for a chain of decays. <br /></td></tr>
<tr class="separator:a01229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01297.html">Compose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01301.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01233"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01233">Decays</a></td></tr>
<tr class="separator:a01233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01237"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Decays&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="separator:a01237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01253"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01253">DenseHistogram</a></td></tr>
<tr class="separator:a01253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01261"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>DenseHistogram&lt; 1, T, detail::unidimensional &gt;</b></td></tr>
<tr class="separator:a01261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01257"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>DenseHistogram&lt; N, T, detail::multidimensional &gt;</b></td></tr>
<tr class="separator:a01257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01325.html">Divide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01833.html">Events</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a01833.html" title="Events is a container struct to hold all the information corresponding the generated events...">Events</a> is a container struct to hold all the information corresponding the generated events.  <a href="a01833.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01837"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01837">FCN</a></td></tr>
<tr class="separator:a01837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01841.html">FCN&lt; Estimator&lt; PDF, Iterator, Visitors... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01857"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01857">GaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:a01857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
Self-adaptive Gauss-Kronrod Quadrature. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01437.html">GaussKronrodBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01429.html">GaussKronrodCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01865"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01865">GaussKronrodQuadrature</a></td></tr>
<tr class="separator:a01865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>GaussKronrodQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
Gauss-Kronrod Quadrature. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01873.html">GaussKronrodRule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01877"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01877">GaussKronrodRuleSelector</a></td></tr>
<tr class="separator:a01877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01881.html">GaussKronrodRuleSelector&lt; 15 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01885.html">GaussKronrodRuleSelector&lt; 21 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01889.html">GaussKronrodRuleSelector&lt; 31 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01893.html">GaussKronrodRuleSelector&lt; 41 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01897.html">GaussKronrodRuleSelector&lt; 51 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01901.html">GaussKronrodRuleSelector&lt; 61 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01433.html">GaussKronrodUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01905.html">GenericRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01909"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01909">GenzMalikQuadrature</a></td></tr>
<tr class="separator:a01909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>GenzMalikQuadrature&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-adaptive Genz-Malik multidimensional quadrature. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01921"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01921">GenzMalikRule</a></td></tr>
<tr class="separator:a01921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>GenzMalikRule&lt; DIM, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01917.html">GenzMalikRuleBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01565.html">Integrator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01849"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01849">LambdaWrapper</a></td></tr>
<tr class="separator:a01849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01853"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00643.html#a01853">LambdaWrapper&lt; ReturnType(ArgType...), L, N &gt;</a></td></tr>
<tr class="memdesc:a01853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for lambda functions.  <a href="a00643.html#a01853">More...</a><br /></td></tr>
<tr class="separator:a01853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01929"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01929">LogLikelihoodFCN</a></td></tr>
<tr class="separator:a01929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01573.html">LogLikelihoodFCN&lt; Pdf&lt; Functor, Integrator &gt;, Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01577.html">LogLikelihoodFCN&lt; PDFSumExtendable&lt; Pdfs... &gt;, Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01581.html">LogLikelihoodFCN&lt; PDFSumNonExtendable&lt; Pdfs... &gt;, Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01585.html">Minus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01933"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01933">multiarray</a></td></tr>
<tr class="separator:a01933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01937"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>multiarray&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="separator:a01937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01589.html">Multiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01941"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01941">multivector</a></td></tr>
<tr class="separator:a01941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01945"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>multivector&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="memdesc:a01945"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements storage in SoA layouts for table where all elements have the same type. <br /></td></tr>
<tr class="separator:a01945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02037"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a02037">null_type</a></td></tr>
<tr class="separator:a02037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01949"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00640.html#a01949">Parameter</a></td></tr>
<tr class="memdesc:a01949"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
,  <a href="a00640.html#a01949">More...</a><br /></td></tr>
<tr class="separator:a01949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01957"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00640.html#a01957">Pdf</a></td></tr>
<tr class="memdesc:a01957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class describing probability density functions.  <a href="a00640.html#a01957">More...</a><br /></td></tr>
<tr class="separator:a01957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01961.html">PDFSumExtendable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01965.html">PDFSumNonExtendable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01969"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00642.html#a01969">PhaseSpace</a></td></tr>
<tr class="memdesc:a01969"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements phase-space Monte Carlo generation in hydra.  <a href="a00642.html#a01969">More...</a><br /></td></tr>
<tr class="separator:a01969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01973"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01973">PhaseSpaceIntegrator</a></td></tr>
<tr class="separator:a01973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpaceIntegrator&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01993"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a01993">Plain</a></td></tr>
<tr class="separator:a01993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Plain&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="a00648.html#a01993">Plain</a> MC numerical integration algorithm in Hydra. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02001"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00644.html#a02001">PlainState</a></td></tr>
<tr class="memdesc:a02001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple structure to hold the results of the <a class="el" href="a00648.html#a01993">Plain</a> MC numerical integration.  <a href="a00644.html#a02001">More...</a><br /></td></tr>
<tr class="separator:a02001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01625.html">Print</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01425.html">ProcessGaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02005"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00641.html#a02005">Random</a></td></tr>
<tr class="memdesc:a02005"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements functionalities associated to random number generation and pdf sampling.  <a href="a00641.html#a02005">More...</a><br /></td></tr>
<tr class="separator:a02005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02009"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a02009">SparseHistogram</a></td></tr>
<tr class="separator:a02009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02017"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SparseHistogram&lt; 1, T, detail::unidimensional &gt;</b></td></tr>
<tr class="separator:a02017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02013"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SparseHistogram&lt; N, T, detail::multidimensional &gt;</b></td></tr>
<tr class="separator:a02013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02021.html">SPlot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02029"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00645.html#a02029">strided_range</a></td></tr>
<tr class="memdesc:a02029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strided range iterator original code: <a href="https://github.com/hydra/detail/external/thrust/hydra/detail/external/thrust/blob/master/examples/strided_range.cu">https://github.com/hydra/detail/external/thrust/hydra/detail/external/thrust/blob/master/examples/strided_range.cu</a>.  <a href="a00645.html#a02029">More...</a><br /></td></tr>
<tr class="separator:a02029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01629.html">Sum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02041.html">UserParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02045"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00642.html#a02045">Vector3R</a></td></tr>
<tr class="memdesc:a02045"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents three-dimensional Euclidian vectors and implements common operation performed on it.  <a href="a00642.html#a02045">More...</a><br /></td></tr>
<tr class="separator:a02045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02049"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00642.html#a02049">Vector4R</a></td></tr>
<tr class="memdesc:a02049"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents four-dimensional relativistic vectors and implements common operation performed on it.  <a href="a00642.html#a02049">More...</a><br /></td></tr>
<tr class="separator:a02049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02053"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a02053">Vegas</a></td></tr>
<tr class="separator:a02053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Vegas&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to perform numerical integration using <a class="el" href="a00648.html#a02053">Vegas</a> algorithm. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02061"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00644.html#a02061">VegasState</a></td></tr>
<tr class="memdesc:a02061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="a00648.html#a02053">hydra::Vegas</a> integration algorithm.  <a href="a00644.html#a02061">More...</a><br /></td></tr>
<tr class="separator:a02061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02065"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VegasState&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="memdesc:a02065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="a00648.html#a02053">hydra::Vegas</a> integration algorithm. <br /></td></tr>
<tr class="separator:a02065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02069"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a02069">Weights</a></td></tr>
<tr class="separator:a02069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02073"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Weights&lt; hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</b></td></tr>
<tr class="separator:a02073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">BoolVector_d</a></td></tr>
<tr class="memdesc:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="a00642.html#a02049" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector.  <a href="#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">More...</a><br /></td></tr>
<tr class="separator:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b1c32d255fc13e78a08e96de133f0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a274b1c32d255fc13e78a08e96de133f0">BoolVector_h</a></td></tr>
<tr class="memdesc:a274b1c32d255fc13e78a08e96de133f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00642.html#a02045" title="This class represents three-dimensional Euclidian vectors and implements common operation performed o...">Vector3R</a> host vector.  <a href="#a274b1c32d255fc13e78a08e96de133f0">More...</a><br /></td></tr>
<tr class="separator:a274b1c32d255fc13e78a08e96de133f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a> = HYDRA_EXTERNAL_NS::thrust::complex&lt; T &gt;</td></tr>
<tr class="separator:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7670b2993eb064d9c192d9200ab82b89"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="a00648.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a7670b2993eb064d9c192d9200ab82b89">ComplexVector_d</a></td></tr>
<tr class="memdesc:a7670b2993eb064d9c192d9200ab82b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GReal_t device vector.  <a href="#a7670b2993eb064d9c192d9200ab82b89">More...</a><br /></td></tr>
<tr class="separator:a7670b2993eb064d9c192d9200ab82b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30019aaf18d88f73acd61f2f363f9f6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="a00648.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#af30019aaf18d88f73acd61f2f363f9f6">ComplexVector_h</a></td></tr>
<tr class="memdesc:af30019aaf18d88f73acd61f2f363f9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GReal_t host vector.  <a href="#af30019aaf18d88f73acd61f2f363f9f6">More...</a><br /></td></tr>
<tr class="separator:af30019aaf18d88f73acd61f2f363f9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2d81895ace081c5204b9adc76a2808"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="a00642.html#a02049">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ada2d81895ace081c5204b9adc76a2808">FourVectors_h</a></td></tr>
<tr class="memdesc:ada2d81895ace081c5204b9adc76a2808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for complex number.  <a href="#ada2d81895ace081c5204b9adc76a2808">More...</a><br /></td></tr>
<tr class="separator:ada2d81895ace081c5204b9adc76a2808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c251ed5017d0638da929130062bcad"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a></td></tr>
<tr class="memdesc:aa8c251ed5017d0638da929130062bcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean (0=false, 1=true) (bool)  <a href="#aa8c251ed5017d0638da929130062bcad">More...</a><br /></td></tr>
<tr class="separator:aa8c251ed5017d0638da929130062bcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ae2da2ab0037e6bca3cb7c15adc5c4125">GByte_t</a></td></tr>
<tr class="memdesc:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte (8 bits) (unsigned char)  <a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">More...</a><br /></td></tr>
<tr class="separator:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab04a199389c4989174dc115507fa89"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a7ab04a199389c4989174dc115507fa89">GChar_t</a></td></tr>
<tr class="memdesc:a7ab04a199389c4989174dc115507fa89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Character 1 byte (char)  <a href="#a7ab04a199389c4989174dc115507fa89">More...</a><br /></td></tr>
<tr class="separator:a7ab04a199389c4989174dc115507fa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab78a78009fd9969bce04250387d13e"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::complex&lt; <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a></td></tr>
<tr class="separator:a7ab78a78009fd9969bce04250387d13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986267d40d932c5cbf0ae874a506f83"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#af986267d40d932c5cbf0ae874a506f83">GDouble_t</a></td></tr>
<tr class="memdesc:af986267d40d932c5cbf0ae874a506f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 8 bytes.  <a href="#af986267d40d932c5cbf0ae874a506f83">More...</a><br /></td></tr>
<tr class="separator:af986267d40d932c5cbf0ae874a506f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bab7b854d7b3c3042fe47201b765eb"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a71bab7b854d7b3c3042fe47201b765eb">GFloat_t</a></td></tr>
<tr class="memdesc:a71bab7b854d7b3c3042fe47201b765eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float 4 bytes (float)  <a href="#a71bab7b854d7b3c3042fe47201b765eb">More...</a><br /></td></tr>
<tr class="separator:a71bab7b854d7b3c3042fe47201b765eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a0c9fb4d7195ab952da10a82d5c4ad30e">GInt_t</a></td></tr>
<tr class="memdesc:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer 4 bytes (int)  <a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">More...</a><br /></td></tr>
<tr class="separator:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memItemLeft" align="right" valign="top">typedef long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a9d68c21fb715bbfb1edc5b1933b173e9">GLong64_t</a></td></tr>
<tr class="memdesc:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable signed long integer 8 bytes.  <a href="#a9d68c21fb715bbfb1edc5b1933b173e9">More...</a><br /></td></tr>
<tr class="separator:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a5f57a4025b40929c2708cd544c3a1ccd">GLong_t</a></td></tr>
<tr class="memdesc:a5f57a4025b40929c2708cd544c3a1ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed long integer 4 bytes (long)  <a href="#a5f57a4025b40929c2708cd544c3a1ccd">More...</a><br /></td></tr>
<tr class="separator:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751abe69b482cde879c718fd4775733f"><td class="memItemLeft" align="right" valign="top">typedef long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a751abe69b482cde879c718fd4775733f">GLongDouble_t</a></td></tr>
<tr class="memdesc:a751abe69b482cde879c718fd4775733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Long Double.  <a href="#a751abe69b482cde879c718fd4775733f">More...</a><br /></td></tr>
<tr class="separator:a751abe69b482cde879c718fd4775733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td></tr>
<tr class="memdesc:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 16 bytes or float 4 bytes.  <a href="#a971e94bcb8c43741d11f9d8eb98f5fab">More...</a><br /></td></tr>
<tr class="separator:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589c60d92ba893c28d814edd6e149a9c"><td class="memItemLeft" align="right" valign="top">typedef short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a589c60d92ba893c28d814edd6e149a9c">GShort_t</a></td></tr>
<tr class="memdesc:a589c60d92ba893c28d814edd6e149a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Short integer 2 bytes (short)  <a href="#a589c60d92ba893c28d814edd6e149a9c">More...</a><br /></td></tr>
<tr class="separator:a589c60d92ba893c28d814edd6e149a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc842c1ec8321e9637dee714dcdaebff"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#abc842c1ec8321e9637dee714dcdaebff">GText_t</a></td></tr>
<tr class="memdesc:abc842c1ec8321e9637dee714dcdaebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">General string (char)  <a href="#abc842c1ec8321e9637dee714dcdaebff">More...</a><br /></td></tr>
<tr class="separator:abc842c1ec8321e9637dee714dcdaebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef97faee95aa79f3839eb7abdf5238"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a51ef97faee95aa79f3839eb7abdf5238">GUChar_t</a></td></tr>
<tr class="memdesc:a51ef97faee95aa79f3839eb7abdf5238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Character 1 byte (unsigned char)  <a href="#a51ef97faee95aa79f3839eb7abdf5238">More...</a><br /></td></tr>
<tr class="separator:a51ef97faee95aa79f3839eb7abdf5238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a7b1f515ac1ed9409afd67252a32b"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a251a7b1f515ac1ed9409afd67252a32b">GUInt_t</a></td></tr>
<tr class="memdesc:a251a7b1f515ac1ed9409afd67252a32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer 4 bytes (unsigned int)  <a href="#a251a7b1f515ac1ed9409afd67252a32b">More...</a><br /></td></tr>
<tr class="separator:a251a7b1f515ac1ed9409afd67252a32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e8443cd746900da90cb1f77807e7c0"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a55e8443cd746900da90cb1f77807e7c0">GULong64_t</a></td></tr>
<tr class="memdesc:a55e8443cd746900da90cb1f77807e7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable unsigned long integer 8 bytes.  <a href="#a55e8443cd746900da90cb1f77807e7c0">More...</a><br /></td></tr>
<tr class="separator:a55e8443cd746900da90cb1f77807e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a0d54fd4ed46052939549edd086c5"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#abf9a0d54fd4ed46052939549edd086c5">GULong_t</a></td></tr>
<tr class="separator:abf9a0d54fd4ed46052939549edd086c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911a3042526fac189d0c87a089f52955"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a911a3042526fac189d0c87a089f52955">GUShort_t</a></td></tr>
<tr class="memdesc:a911a3042526fac189d0c87a089f52955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Short integer 2 bytes (unsigned short)  <a href="#a911a3042526fac189d0c87a089f52955">More...</a><br /></td></tr>
<tr class="separator:a911a3042526fac189d0c87a089f52955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648839818fa9d4a58c2195a55a51e773"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a648839818fa9d4a58c2195a55a51e773"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a> = HYDRA_EXTERNAL_NS::thrust::device_vector&lt; T &gt;</td></tr>
<tr class="memdesc:a648839818fa9d4a58c2195a55a51e773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector.  <a href="#a648839818fa9d4a58c2195a55a51e773">More...</a><br /></td></tr>
<tr class="separator:a648839818fa9d4a58c2195a55a51e773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de6f086a44380382022dafca75de4c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6de6f086a44380382022dafca75de4c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a> = HYDRA_EXTERNAL_NS::thrust::host_vector&lt; T, HYDRA_EXTERNAL_NS::thrust::system::cuda::experimental::pinned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a6de6f086a44380382022dafca75de4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector.  <a href="#a6de6f086a44380382022dafca75de4c9">More...</a><br /></td></tr>
<tr class="separator:a6de6f086a44380382022dafca75de4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#acf5241d6a56b2040e9cc9ea860b4cbff">pair</a> = HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt;</td></tr>
<tr class="memdesc:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pair</code> template is an alias to the HYDRA_EXTERNAL_NS::thrust::pair structure.  <a href="#acf5241d6a56b2040e9cc9ea860b4cbff">More...</a><br /></td></tr>
<tr class="separator:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34184a169c185689e065d0c30f9ffba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="a00642.html#a02049">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ae34184a169c185689e065d0c30f9ffba">Particles_d</a></td></tr>
<tr class="memdesc:ae34184a169c185689e065d0c30f9ffba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GComplex_t device vector.  <a href="#ae34184a169c185689e065d0c30f9ffba">More...</a><br /></td></tr>
<tr class="separator:ae34184a169c185689e065d0c30f9ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="a00642.html#a02049">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a9df2f3d6dc63cf297b0f74ba228f6c89">Particles_h</a></td></tr>
<tr class="memdesc:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GComplex_t host vector.  <a href="#a9df2f3d6dc63cf297b0f74ba228f6c89">More...</a><br /></td></tr>
<tr class="separator:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fd090c6e39cfcdd744f369dacffabe"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a79fd090c6e39cfcdd744f369dacffabe">RealVector_d</a></td></tr>
<tr class="memdesc:a79fd090c6e39cfcdd744f369dacffabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GBool_t device vector.  <a href="#a79fd090c6e39cfcdd744f369dacffabe">More...</a><br /></td></tr>
<tr class="separator:a79fd090c6e39cfcdd744f369dacffabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d21da5996b50a240e6f400025e3b139"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a6d21da5996b50a240e6f400025e3b139">RealVector_h</a></td></tr>
<tr class="memdesc:a6d21da5996b50a240e6f400025e3b139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GBool_t host vector.  <a href="#a6d21da5996b50a240e6f400025e3b139">More...</a><br /></td></tr>
<tr class="separator:a6d21da5996b50a240e6f400025e3b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcdb1155222988a4250114d880e8b46"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="a00642.html#a02045">Vector3R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a7dcdb1155222988a4250114d880e8b46">ThreeVectors_h</a></td></tr>
<tr class="memdesc:a7dcdb1155222988a4250114d880e8b46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00642.html#a02049" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector.  <a href="#a7dcdb1155222988a4250114d880e8b46">More...</a><br /></td></tr>
<tr class="separator:a7dcdb1155222988a4250114d880e8b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e59cc0127adfac6b799c5fd6785431b"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a5e59cc0127adfac6b799c5fd6785431b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a5e59cc0127adfac6b799c5fd6785431b">tuple</a> = HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;</td></tr>
<tr class="memdesc:a5e59cc0127adfac6b799c5fd6785431b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>tuple</code> template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can be instantiated with a indefinite number of arguments.  <a href="#a5e59cc0127adfac6b799c5fd6785431b">More...</a><br /></td></tr>
<tr class="separator:a5e59cc0127adfac6b799c5fd6785431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecb38ba9198aee2de36f374d07638de"><td class="memTemplParams" colspan="2">template&lt;int N, class T &gt; </td></tr>
<tr class="memitem:a3ecb38ba9198aee2de36f374d07638de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a3ecb38ba9198aee2de36f374d07638de">tuple_element</a> = HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, T &gt;</td></tr>
<tr class="memdesc:a3ecb38ba9198aee2de36f374d07638de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest.  <a href="#a3ecb38ba9198aee2de36f374d07638de">More...</a><br /></td></tr>
<tr class="separator:a3ecb38ba9198aee2de36f374d07638de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ab06a4451f99b94119ead1dcadf2b8e31">tuple_size</a> = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;</td></tr>
<tr class="memdesc:ab06a4451f99b94119ead1dcadf2b8e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This metafunction returns the number of elements of a <code>tuple</code> type of interest.  <a href="#ab06a4451f99b94119ead1dcadf2b8e31">More...</a><br /></td></tr>
<tr class="separator:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aed873b1b84fbec3791e721b22a52d1fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00648.html#aed873b1b84fbec3791e721b22a52d1fea4517ec382985cb7a39393c0da09e58d5">INFO</a> =0, 
<a class="el" href="a00648.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a> =1, 
<a class="el" href="a00648.html#aed873b1b84fbec3791e721b22a52d1feadbc96f88184ea3a51f68df95e2b44851">ERROR</a> =2
 }</td></tr>
<tr class="separator:aed873b1b84fbec3791e721b22a52d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1107488f838687e73b39ddd8245f40d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00648.html#a1107488f838687e73b39ddd8245f40d0aae772e8b4c5ada0e1e4c65495702176a">MODE_IMPORTANCE</a> = 1, 
<a class="el" href="a00648.html#a1107488f838687e73b39ddd8245f40d0a28550661921a3af1306fa74a26b8569c">MODE_IMPORTANCE_ONLY</a> = 0, 
<a class="el" href="a00648.html#a1107488f838687e73b39ddd8245f40d0acb2c0124fecbf6c1182f1cf7cd9bc37a">MODE_STRATIFIED</a> = -1, 
<a class="el" href="a00648.html#a1107488f838687e73b39ddd8245f40d0aba2629d0445cc7ef401fd6793f047da0">BINS_MAX</a> = 50
 }</td></tr>
<tr class="separator:a1107488f838687e73b39ddd8245f40d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab7ba86af6b39da2d26222b1bc200814c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7ba86af6b39da2d26222b1bc200814c"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ab7ba86af6b39da2d26222b1bc200814c">abs</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab7ba86af6b39da2d26222b1bc200814c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f35a53dc5c3388a2ab13ddde5dc39c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0f35a53dc5c3388a2ab13ddde5dc39c"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ab0f35a53dc5c3388a2ab13ddde5dc39c">acos</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab0f35a53dc5c3388a2ab13ddde5dc39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747815d02662791baa7a68032d4cac5e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a747815d02662791baa7a68032d4cac5e"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a747815d02662791baa7a68032d4cac5e">acosh</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a747815d02662791baa7a68032d4cac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cac9fee3f765860563dcc08a6a42e9"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:af8cac9fee3f765860563dcc08a6a42e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01961.html">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#af8cac9fee3f765860563dcc08a6a42e9">add_pdfs</a> (std::array&lt; <a class="el" href="a00640.html#a01949">Parameter</a> *, sizeof...(PDFs)+2 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:af8cac9fee3f765860563dcc08a6a42e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to add pdfs without set template parameters explicitly.  <a href="#af8cac9fee3f765860563dcc08a6a42e9">More...</a><br /></td></tr>
<tr class="separator:af8cac9fee3f765860563dcc08a6a42e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd00ebc1db7600324fe4e6b30c05d7e"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:aedd00ebc1db7600324fe4e6b30c05d7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aedd00ebc1db7600324fe4e6b30c05d7e">add_pdfs</a> (std::array&lt; <a class="el" href="a00640.html#a01949">Parameter</a> *, sizeof...(PDFs)+1 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:aedd00ebc1db7600324fe4e6b30c05d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to add pdfs without set template parameters explicitly.  <a href="#aedd00ebc1db7600324fe4e6b30c05d7e">More...</a><br /></td></tr>
<tr class="separator:aedd00ebc1db7600324fe4e6b30c05d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f175cc8f2c59f6cf2c416354fdb951f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Functor &gt; </td></tr>
<tr class="memitem:a4f175cc8f2c59f6cf2c416354fdb951f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01905.html">hydra::GenericRange</a>&lt; typename Container::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a4f175cc8f2c59f6cf2c416354fdb951f">apply_filter</a> (Container &amp;container, Functor const  &amp;filter)</td></tr>
<tr class="memdesc:a4f175cc8f2c59f6cf2c416354fdb951f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a filter to the range [first, last] and return a pair of iterators for the filtered events.  <a href="#a4f175cc8f2c59f6cf2c416354fdb951f">More...</a><br /></td></tr>
<tr class="separator:a4f175cc8f2c59f6cf2c416354fdb951f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4363cbd28bb5e42f27241e5bca02f0d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4363cbd28bb5e42f27241e5bca02f0d"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ac4363cbd28bb5e42f27241e5bca02f0d">arg</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ac4363cbd28bb5e42f27241e5bca02f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7288f22488e57a5b739979864a86e38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7288f22488e57a5b739979864a86e38"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ab7288f22488e57a5b739979864a86e38">asin</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab7288f22488e57a5b739979864a86e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b00aff8ca48e2f3a2e8b24ddeb571"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a579b00aff8ca48e2f3a2e8b24ddeb571"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a579b00aff8ca48e2f3a2e8b24ddeb571">asinh</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a579b00aff8ca48e2f3a2e8b24ddeb571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20a2c3862e19a865286b0b3aaa3d146"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab20a2c3862e19a865286b0b3aaa3d146"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ab20a2c3862e19a865286b0b3aaa3d146">atan</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab20a2c3862e19a865286b0b3aaa3d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7689f62c3b4d6a9c4cd9c167d19f0911"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7689f62c3b4d6a9c4cd9c167d19f0911"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a7689f62c3b4d6a9c4cd9c167d19f0911">atanh</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a7689f62c3b4d6a9c4cd9c167d19f0911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8c272359dca5fb49f5a76d4cf93451"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:afe8c272359dca5fb49f5a76d4cf93451"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#afe8c272359dca5fb49f5a76d4cf93451">begin</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:afe8c272359dca5fb49f5a76d4cf93451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a4f1cb0e2e3473d8e25b079dd72b8bc8a">begin</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6874d900b0238ec21d1490998de81f99"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6874d900b0238ec21d1490998de81f99"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a6874d900b0238ec21d1490998de81f99">begin</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a6874d900b0238ec21d1490998de81f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6d2db036860acb6cd33738ba85e357"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:aca6d2db036860acb6cd33738ba85e357"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aca6d2db036860acb6cd33738ba85e357">begin</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:aca6d2db036860acb6cd33738ba85e357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d2bb64b855258800238a7263f26699"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a52d2bb64b855258800238a7263f26699">boostTo</a> (const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;rs, const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;p4, bool inverse=false)</td></tr>
<tr class="separator:a52d2bb64b855258800238a7263f26699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56aaad7de821363b5a3f6a3853688a5f"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a56aaad7de821363b5a3f6a3853688a5f">boostTo</a> (const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;rs, const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;boost, bool inverse=false)</td></tr>
<tr class="separator:a56aaad7de821363b5a3f6a3853688a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1429976b67876d11b19469677d7223"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename ... Ts, typename  = typename std::enable_if&lt;T0::is_functor::value &amp;&amp; T1::is_functor::value &amp;&amp; detail::all_true&lt;Ts::is_functor::value...&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a2f1429976b67876d11b19469677d7223"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01297.html">Compose</a>&lt; T0, T1, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a2f1429976b67876d11b19469677d7223">compose</a> (T0 const &amp;F0, T1 const &amp;F1, Ts const &amp;...Fs)</td></tr>
<tr class="separator:a2f1429976b67876d11b19469677d7223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9f167506a6f00739dccfab84d60c83"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a9f167506a6f00739dccfab84d60c83"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a3a9f167506a6f00739dccfab84d60c83">conj</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a3a9f167506a6f00739dccfab84d60c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a28aa8ffeea73bf98ccab0fb7cd1c8116">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memTemplParams" colspan="2">template&lt;detail::Backend Backend, typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a98b97d9c4a1b0350ef7c2d646c8c504a">copy</a> (hydra::detail::BackendPolicy&lt; Backend &gt; const &amp;policy, InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7154a99c3dfc0f0718e0b2762f11ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb7154a99c3dfc0f0718e0b2762f11ac"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#abb7154a99c3dfc0f0718e0b2762f11ac">cos</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:abb7154a99c3dfc0f0718e0b2762f11ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b238296c1ef949b0b3d31134e23445a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b238296c1ef949b0b3d31134e23445a"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a6b238296c1ef949b0b3d31134e23445a">cosh</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a6b238296c1ef949b0b3d31134e23445a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafa4366407089182878f1f595038b13"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#aeafa4366407089182878f1f595038b13">cross</a> (const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;p1, const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;p2)</td></tr>
<tr class="separator:aeafa4366407089182878f1f595038b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1016bfa0c15215b4c14afc007d932074"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a1016bfa0c15215b4c14afc007d932074"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a1016bfa0c15215b4c14afc007d932074">distance</a> (Iterator first, Iterator last) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::distance&lt; Iterator &gt;(first, last))</td></tr>
<tr class="separator:a1016bfa0c15215b4c14afc007d932074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762ed9329b60137d5230242c159b0c6d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a762ed9329b60137d5230242c159b0c6d"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01325.html">Divide</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a762ed9329b60137d5230242c159b0c6d">divide</a> (T1 const &amp;F1, T1 const &amp;F2)</td></tr>
<tr class="separator:a762ed9329b60137d5230242c159b0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a5f434b6fb7d95b6ca2a386e25e6b6733">end</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f44ac4277e27b370317451862a091d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:ae4f44ac4277e27b370317451862a091d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ae4f44ac4277e27b370317451862a091d">end</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ae4f44ac4277e27b370317451862a091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f8d7b0cfc77696dd1ba9aaf31d23a7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ae7f8d7b0cfc77696dd1ba9aaf31d23a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ae7f8d7b0cfc77696dd1ba9aaf31d23a7">end</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ae7f8d7b0cfc77696dd1ba9aaf31d23a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c20a7a5048641695b7f0e61b725f416"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a0c20a7a5048641695b7f0e61b725f416"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a0c20a7a5048641695b7f0e61b725f416">end</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a0c20a7a5048641695b7f0e61b725f416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24ab75c18fd15430a4f071f1a426e80"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:gae24ab75c18fd15430a4f071f1a426e80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00645.html#gae24ab75c18fd15430a4f071f1a426e80">eval</a> (hydra::detail::BackendPolicy&lt; BACKEND &gt;const  &amp;policy, Functor const  &amp;functor, Iterator <a class="el" href="a00648.html#a6874d900b0238ec21d1490998de81f99">begin</a>, Iterator <a class="el" href="a00648.html#ae7f8d7b0cfc77696dd1ba9aaf31d23a7">end</a>) -&gt; typename hydra::detail::BackendPolicy&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:gae24ab75c18fd15430a4f071f1a426e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a hydra functor on a range using the parallel policy.  <a href="a00645.html#gae24ab75c18fd15430a4f071f1a426e80">More...</a><br /></td></tr>
<tr class="separator:gae24ab75c18fd15430a4f071f1a426e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4154f918ffa8358edfaa48455c38eed"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Functors&gt; </td></tr>
<tr class="memitem:gaf4154f918ffa8358edfaa48455c38eed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00645.html#gaf4154f918ffa8358edfaa48455c38eed">eval</a> (hydra::detail::BackendPolicy&lt; BACKEND &gt;const  &amp;policy, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="a00648.html#a6874d900b0238ec21d1490998de81f99">begin</a>, Iterator <a class="el" href="a00648.html#ae7f8d7b0cfc77696dd1ba9aaf31d23a7">end</a>) -&gt; <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; typename Functors::return_type ... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt;&gt;</td></tr>
<tr class="memdesc:gaf4154f918ffa8358edfaa48455c38eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of hydra functors on a range using the parallel policy.  <a href="a00645.html#gaf4154f918ffa8358edfaa48455c38eed">More...</a><br /></td></tr>
<tr class="separator:gaf4154f918ffa8358edfaa48455c38eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93303de58d08af18100ae64b47277a4d"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Functor , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga93303de58d08af18100ae64b47277a4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00645.html#ga93303de58d08af18100ae64b47277a4d">eval</a> (hydra::detail::BackendPolicy&lt; BACKEND &gt;const  &amp;policy, Functor const  &amp;functor, Iterator <a class="el" href="a00648.html#a6874d900b0238ec21d1490998de81f99">begin</a>, Iterator <a class="el" href="a00648.html#ae7f8d7b0cfc77696dd1ba9aaf31d23a7">end</a>, Iterators... begins) -&gt; typename hydra::detail::BackendPolicy&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:ga93303de58d08af18100ae64b47277a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a functor over a list of ranges.  <a href="a00645.html#ga93303de58d08af18100ae64b47277a4d">More...</a><br /></td></tr>
<tr class="separator:ga93303de58d08af18100ae64b47277a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96808ecb92b537bcf51bbcfb19195d83"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Iterators, typename ... Functors&gt; </td></tr>
<tr class="memitem:ga96808ecb92b537bcf51bbcfb19195d83"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00645.html#ga96808ecb92b537bcf51bbcfb19195d83">eval</a> (hydra::detail::BackendPolicy&lt; BACKEND &gt;const  &amp;policy, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="a00648.html#a6874d900b0238ec21d1490998de81f99">begin</a>, Iterator <a class="el" href="a00648.html#ae7f8d7b0cfc77696dd1ba9aaf31d23a7">end</a>, Iterators... begins) -&gt; <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; typename Functors::return_type ... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</td></tr>
<tr class="memdesc:ga96808ecb92b537bcf51bbcfb19195d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of functors over a list of ranges.  <a href="a00645.html#ga96808ecb92b537bcf51bbcfb19195d83">More...</a><br /></td></tr>
<tr class="separator:ga96808ecb92b537bcf51bbcfb19195d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f0de94ba6edf1f98d40ea2afd91a94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77f0de94ba6edf1f98d40ea2afd91a94"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a77f0de94ba6edf1f98d40ea2afd91a94">exp</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a77f0de94ba6edf1f98d40ea2afd91a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad01484e7c92de1226a1d341df3325e"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:a5ad01484e7c92de1226a1d341df3325e"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a5ad01484e7c92de1226a1d341df3325e">get</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;<a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>)</td></tr>
<tr class="memdesc:a5ad01484e7c92de1226a1d341df3325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a reference to a <code>tuple</code> element of interest.  <a href="#a5ad01484e7c92de1226a1d341df3325e">More...</a><br /></td></tr>
<tr class="separator:a5ad01484e7c92de1226a1d341df3325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7540bfa2632da70c72f837a0f2693c25"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:a7540bfa2632da70c72f837a0f2693c25"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a7540bfa2632da70c72f837a0f2693c25">get</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;<a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>)</td></tr>
<tr class="separator:a7540bfa2632da70c72f837a0f2693c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d13dee5e010004d3e43db4763165557"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2d13dee5e010004d3e43db4763165557"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a2d13dee5e010004d3e43db4763165557">get</a> (HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &amp;&amp;<a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>)</td></tr>
<tr class="separator:a2d13dee5e010004d3e43db4763165557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a9bd95a2e510a972665cc8e93abb7ad00">get</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa301daa15842709092a044086afe7547"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:aa301daa15842709092a044086afe7547"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aa301daa15842709092a044086afe7547">get</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:aa301daa15842709092a044086afe7547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263225f66d8e954e0391c8445e50bc04"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:a263225f66d8e954e0391c8445e50bc04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a263225f66d8e954e0391c8445e50bc04">get_pdf</a> (<a class="el" href="a01961.html">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdfs) -&gt; std::pair&lt; <a class="el" href="a00640.html#a01949">Parameter</a>, typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, typename <a class="el" href="a01961.html">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;::pdfs_tuple_type &gt;::type &gt;</td></tr>
<tr class="separator:a263225f66d8e954e0391c8445e50bc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89ec49a297773352fad3ddb84214fb6"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:aa89ec49a297773352fad3ddb84214fb6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aa89ec49a297773352fad3ddb84214fb6">get_pdf</a> (<a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdfs) -&gt; std::pair&lt; <a class="el" href="a00640.html#a01949">Parameter</a>, typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; I, typename <a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;::pdfs_tuple_type &gt;::type &gt;</td></tr>
<tr class="separator:aa89ec49a297773352fad3ddb84214fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a7582acf570b53c033d52c6ff0fecb43e">GetFormatedString</a> (const char *format, Args... args)</td></tr>
<tr class="separator:a7582acf570b53c033d52c6ff0fecb43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa215df4feed1826c6bc64bade76c39a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa215df4feed1826c6bc64bade76c39a0"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aa215df4feed1826c6bc64bade76c39a0">log</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:aa215df4feed1826c6bc64bade76c39a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38d0dd2b2ee0784014d04554b67db6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af38d0dd2b2ee0784014d04554b67db6b"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#af38d0dd2b2ee0784014d04554b67db6b">log10</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:af38d0dd2b2ee0784014d04554b67db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66310c43220a83278f7e1588cf2d0feb"><td class="memTemplParams" colspan="2">template&lt;size_t ... N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a66310c43220a83278f7e1588cf2d0feb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00648.html#a01225">Chains</a>&lt; <a class="el" href="a00648.html#a01233">Decays</a>&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a66310c43220a83278f7e1588cf2d0feb">make_chain</a> (hydra::detail::BackendPolicy&lt; BACKEND &gt; const &amp;policy, size_t entries)</td></tr>
<tr class="separator:a66310c43220a83278f7e1588cf2d0feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2940519393c31b1d5566e1894e01bad7"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterator &gt; </td></tr>
<tr class="memitem:a2940519393c31b1d5566e1894e01bad7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a2940519393c31b1d5566e1894e01bad7">make_loglikehood_fcn</a> (Iterator first, Iterator last, <a class="el" href="a00640.html#a01957">Pdf</a>&lt; Functor, <a class="el" href="a01565.html">Integrator</a> &gt; &amp;functor) -&gt; <a class="el" href="a00648.html#a01929">LogLikelihoodFCN</a>&lt; <a class="el" href="a00640.html#a01957">Pdf</a>&lt; Functor, <a class="el" href="a01565.html">Integrator</a> &gt;, Iterator &gt;</td></tr>
<tr class="separator:a2940519393c31b1d5566e1894e01bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b7d583d231a242249f3a8a2c3ff7d0"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator &gt; </td></tr>
<tr class="memitem:a25b7d583d231a242249f3a8a2c3ff7d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a25b7d583d231a242249f3a8a2c3ff7d0">make_loglikehood_fcn</a> (Iterator first, Iterator last, <a class="el" href="a01961.html">PDFSumExtendable</a>&lt; Pdfs... &gt; &amp;functor) -&gt; <a class="el" href="a00648.html#a01929">LogLikelihoodFCN</a>&lt; <a class="el" href="a01961.html">PDFSumExtendable</a>&lt; Pdfs... &gt;, Iterator &gt;</td></tr>
<tr class="separator:a25b7d583d231a242249f3a8a2c3ff7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f369bd2cc9adc9091ec7cf15a83739f"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator &gt; </td></tr>
<tr class="memitem:a4f369bd2cc9adc9091ec7cf15a83739f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a4f369bd2cc9adc9091ec7cf15a83739f">make_loglikehood_fcn</a> (Iterator first, Iterator last, <a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt; Pdfs... &gt; &amp;functor) -&gt; <a class="el" href="a00648.html#a01929">LogLikelihoodFCN</a>&lt; <a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, Iterator &gt;</td></tr>
<tr class="separator:a4f369bd2cc9adc9091ec7cf15a83739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f6ab65f6835130e8c8237785c2e188"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a47f6ab65f6835130e8c8237785c2e188"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a47f6ab65f6835130e8c8237785c2e188">make_pair</a> (T1 &amp;&amp;t1, T2 &amp;&amp;t2) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_pair(std::forward&lt; T1 &gt;(t1), std::forward&lt; T2 &gt;(t2)))</td></tr>
<tr class="memdesc:a47f6ab65f6835130e8c8237785c2e188"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects.  <a href="#a47f6ab65f6835130e8c8237785c2e188">More...</a><br /></td></tr>
<tr class="separator:a47f6ab65f6835130e8c8237785c2e188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplParams" colspan="2">template&lt;typename FUNCTOR , typename INTEGRATOR &gt; </td></tr>
<tr class="memitem:a2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00640.html#a01957">Pdf</a>&lt; FUNCTOR, INTEGRATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a2d468a0d98a74f41479f8ccb95f5533e">make_pdf</a> (FUNCTOR const &amp;functor, INTEGRATOR integrator)</td></tr>
<tr class="memdesc:a2d468a0d98a74f41479f8ccb95f5533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="a00640.html#a01957" title="Class describing probability density functions. ">hydra::Pdf</a> given a shape described by a functor and a integrator (algorithm or functor).  <a href="#a2d468a0d98a74f41479f8ccb95f5533e">More...</a><br /></td></tr>
<tr class="separator:a2d468a0d98a74f41479f8ccb95f5533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d210727c4d8b6989542eff5fd3f6319"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a8d210727c4d8b6989542eff5fd3f6319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01905.html">GenericRange</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a8d210727c4d8b6989542eff5fd3f6319">make_range</a> (Iterator <a class="el" href="a00648.html#a6874d900b0238ec21d1490998de81f99">begin</a>, Iterator <a class="el" href="a00648.html#ae7f8d7b0cfc77696dd1ba9aaf31d23a7">end</a>)</td></tr>
<tr class="separator:a8d210727c4d8b6989542eff5fd3f6319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5314ace45b4baa7084a9addb625ca99"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:af5314ace45b4baa7084a9addb625ca99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02021.html">SPlot</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#af5314ace45b4baa7084a9addb625ca99">make_splot</a> (<a class="el" href="a01961.html">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdf)</td></tr>
<tr class="separator:af5314ace45b4baa7084a9addb625ca99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd7ac5f41262275e8887b4edcb9357c"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a7cd7ac5f41262275e8887b4edcb9357c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a7cd7ac5f41262275e8887b4edcb9357c">make_tuple</a> (T &amp;&amp;... <a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(std::forward&lt; T &gt;(<a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>)...))</td></tr>
<tr class="memdesc:a7cd7ac5f41262275e8887b4edcb9357c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects.  <a href="#a7cd7ac5f41262275e8887b4edcb9357c">More...</a><br /></td></tr>
<tr class="separator:a7cd7ac5f41262275e8887b4edcb9357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c135b2a31b8adc650408759756cd30"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa9c135b2a31b8adc650408759756cd30"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a01585.html">Minus</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aa9c135b2a31b8adc650408759756cd30">minus</a> (T1 const &amp;F1, T1 const &amp;F2)</td></tr>
<tr class="separator:aa9c135b2a31b8adc650408759756cd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a50c2051805f64f02bd175de858ed4b"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a9a50c2051805f64f02bd175de858ed4b"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01589.html">Multiply</a>&lt; F1, F2, Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a9a50c2051805f64f02bd175de858ed4b">multiply</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:a9a50c2051805f64f02bd175de858ed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69f12b645e7126856ef32ba8917fb71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae69f12b645e7126856ef32ba8917fb71"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ae69f12b645e7126856ef32ba8917fb71">norm</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ae69f12b645e7126856ef32ba8917fb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913357a180c5a5e87f79873cabd0ae5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a913357a180c5a5e87f79873cabd0ae5d"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a913357a180c5a5e87f79873cabd0ae5d">operator!=</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a913357a180c5a5e87f79873cabd0ae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a25d4e1e31a1d0d0d44dd7de38a9a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45a25d4e1e31a1d0d0d44dd7de38a9a2"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a45a25d4e1e31a1d0d0d44dd7de38a9a2">operator!=</a> (const T &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a45a25d4e1e31a1d0d0d44dd7de38a9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78094f07d3ecae48d4ee065254f63fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa78094f07d3ecae48d4ee065254f63fa"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aa78094f07d3ecae48d4ee065254f63fa">operator!=</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:aa78094f07d3ecae48d4ee065254f63fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memTemplParams" colspan="2">template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a74f09f60eaa232f756f2e5ee0ccb5326">operator!=</a> (const <a class="el" href="a00648.html#a01233">Decays</a>&lt; N1, hydra::detail::BackendPolicy&lt; BACKEND1 &gt; &gt; &amp;lhs, const <a class="el" href="a00648.html#a01233">Decays</a>&lt; N2, hydra::detail::BackendPolicy&lt; BACKEND2 &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258cacce52e3670d4880af1576a16a22"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a258cacce52e3670d4880af1576a16a22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a258cacce52e3670d4880af1576a16a22">operator!=</a> (const <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a258cacce52e3670d4880af1576a16a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9653c961d5b4bb192f5af6ec0159dcef"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a9653c961d5b4bb192f5af6ec0159dcef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a9653c961d5b4bb192f5af6ec0159dcef">operator!=</a> (const <a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a9653c961d5b4bb192f5af6ec0159dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453f3462b38832622a8a719e348d1d26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a453f3462b38832622a8a719e348d1d26"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a453f3462b38832622a8a719e348d1d26">operator*</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a453f3462b38832622a8a719e348d1d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15264ba6f6e6f2329ea89b8c4adf1c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae15264ba6f6e6f2329ea89b8c4adf1c1"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ae15264ba6f6e6f2329ea89b8c4adf1c1">operator*</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:ae15264ba6f6e6f2329ea89b8c4adf1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa9b12786f7b702aaac2486c906a9e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfa9b12786f7b702aaac2486c906a9e6"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#abfa9b12786f7b702aaac2486c906a9e6">operator*</a> (const T &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:abfa9b12786f7b702aaac2486c906a9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb35eb14984b6f9d742e7184f98fb4a8"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#abb35eb14984b6f9d742e7184f98fb4a8">operator*</a> (<a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:abb35eb14984b6f9d742e7184f98fb4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56864f196d50c23d6ef4bd0fa5320ee"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ad56864f196d50c23d6ef4bd0fa5320ee">operator*</a> (const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v1, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:ad56864f196d50c23d6ef4bd0fa5320ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16922c01d5d589efdcafaf9f3c4c852e"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a16922c01d5d589efdcafaf9f3c4c852e">operator*</a> (const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v1, const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:a16922c01d5d589efdcafaf9f3c4c852e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8059091b90cfa8bfd6a7bbabf84e851"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ab8059091b90cfa8bfd6a7bbabf84e851">operator*</a> (<a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:ab8059091b90cfa8bfd6a7bbabf84e851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea48ebde3804da5519a849fd697a9ed"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a8ea48ebde3804da5519a849fd697a9ed">operator*</a> (const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v2, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a8ea48ebde3804da5519a849fd697a9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4041f5a5f507aa261b2e722d8aea605c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4041f5a5f507aa261b2e722d8aea605c"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01589.html">Multiply</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a4041f5a5f507aa261b2e722d8aea605c">operator*</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a4041f5a5f507aa261b2e722d8aea605c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc68502df5d8b6b8f5fba9b1ba7ac2e9"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#acc68502df5d8b6b8f5fba9b1ba7ac2e9">operator*</a> (const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v1, const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:acc68502df5d8b6b8f5fba9b1ba7ac2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef450a625d3a4b0d301d4cc516024e7e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:aef450a625d3a4b0d301d4cc516024e7e"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01589.html">Multiply</a>&lt; <a class="el" href="a01301.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aef450a625d3a4b0d301d4cc516024e7e">operator*</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:aef450a625d3a4b0d301d4cc516024e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad246bd46bbecdf62fad753ebc2dce9f6"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:ad246bd46bbecdf62fad753ebc2dce9f6"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ad246bd46bbecdf62fad753ebc2dce9f6">operator*</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:ad246bd46bbecdf62fad753ebc2dce9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e1e189bc887ae3654818288261ad66"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a02e1e189bc887ae3654818288261ad66"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01589.html">Multiply</a>&lt; <a class="el" href="a01301.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a02e1e189bc887ae3654818288261ad66">operator*</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:a02e1e189bc887ae3654818288261ad66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af587b7c92737fe70358655f15e30ccc7"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#af587b7c92737fe70358655f15e30ccc7">operator*</a> (<a class="el" href="a00640.html#a01949">Parameter</a> par1, <a class="el" href="a00640.html#a01949">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:af587b7c92737fe70358655f15e30ccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e396d4f239faf8395afd30c288a2116"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a5e396d4f239faf8395afd30c288a2116">operator*</a> (<a class="el" href="a00640.html#a01949">Parameter</a> par1, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a5e396d4f239faf8395afd30c288a2116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7545311b9dadd924decb19aa5c678e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e7545311b9dadd924decb19aa5c678e"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a0e7545311b9dadd924decb19aa5c678e">operator+</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a0e7545311b9dadd924decb19aa5c678e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2e80d981cfe98af22638389ac78a89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc2e80d981cfe98af22638389ac78a89"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#acc2e80d981cfe98af22638389ac78a89">operator+</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:acc2e80d981cfe98af22638389ac78a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee0958a1405d293624a05ff2d16ae60"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a7ee0958a1405d293624a05ff2d16ae60">operator+</a> (const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v1, const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:a7ee0958a1405d293624a05ff2d16ae60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9fac87dd53e628338c40ad17db0302"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a9fac87dd53e628338c40ad17db0302"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a0a9fac87dd53e628338c40ad17db0302">operator+</a> (const T &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a0a9fac87dd53e628338c40ad17db0302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb95fa627ccd32ea676dd48ac231177b"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:aeb95fa627ccd32ea676dd48ac231177b"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aeb95fa627ccd32ea676dd48ac231177b">operator+</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:aeb95fa627ccd32ea676dd48ac231177b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c990f0b58881363c9b28525a379371"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79c990f0b58881363c9b28525a379371"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a79c990f0b58881363c9b28525a379371">operator+</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a79c990f0b58881363c9b28525a379371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71a6353509fb42628cb8cb677b1e580"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:ac71a6353509fb42628cb8cb677b1e580"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01629.html">Sum</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ac71a6353509fb42628cb8cb677b1e580">operator+</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:ac71a6353509fb42628cb8cb677b1e580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fefe9fcea2b9c4770e7ee42c98dfa7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a38fefe9fcea2b9c4770e7ee42c98dfa7"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01629.html">Sum</a>&lt; <a class="el" href="a01301.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a38fefe9fcea2b9c4770e7ee42c98dfa7">operator+</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:a38fefe9fcea2b9c4770e7ee42c98dfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099a6b58b45d6bcb7a10985101771603"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a099a6b58b45d6bcb7a10985101771603"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01629.html">Sum</a>&lt; <a class="el" href="a01301.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a099a6b58b45d6bcb7a10985101771603">operator+</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:a099a6b58b45d6bcb7a10985101771603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d67c62da7414fa54685256891397394"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a8d67c62da7414fa54685256891397394">operator+</a> (const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v1, const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:a8d67c62da7414fa54685256891397394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb1d38b677c0b1cd04e858dfd2b1743"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a8fb1d38b677c0b1cd04e858dfd2b1743">operator+</a> (<a class="el" href="a00640.html#a01949">Parameter</a> par1, <a class="el" href="a00640.html#a01949">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a8fb1d38b677c0b1cd04e858dfd2b1743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf413cf8a4ae5c7c270bde93e62f9bfe"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#acf413cf8a4ae5c7c270bde93e62f9bfe">operator+</a> (<a class="el" href="a00640.html#a01949">Parameter</a> par1, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:acf413cf8a4ae5c7c270bde93e62f9bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6293979d93d4a451cd1d1e52bad055"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a8f6293979d93d4a451cd1d1e52bad055">operator-</a> (const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v1, const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:a8f6293979d93d4a451cd1d1e52bad055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caa84fd26ffc72a35668dd9f69d4662"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8caa84fd26ffc72a35668dd9f69d4662"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a8caa84fd26ffc72a35668dd9f69d4662">operator-</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a8caa84fd26ffc72a35668dd9f69d4662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30e88501f8f4eba8c8d36854e24ebc5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae30e88501f8f4eba8c8d36854e24ebc5"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ae30e88501f8f4eba8c8d36854e24ebc5">operator-</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:ae30e88501f8f4eba8c8d36854e24ebc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8d70910231348dc233cc60f55c07ae"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:afd8d70910231348dc233cc60f55c07ae"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01585.html">Minus</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#afd8d70910231348dc233cc60f55c07ae">operator-</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:afd8d70910231348dc233cc60f55c07ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af819765e4fd40306b2e7272b0c9ef024"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af819765e4fd40306b2e7272b0c9ef024"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#af819765e4fd40306b2e7272b0c9ef024">operator-</a> (const T &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:af819765e4fd40306b2e7272b0c9ef024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ae849dd2d74a7d93322306d7679750"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a44ae849dd2d74a7d93322306d7679750"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01585.html">Minus</a>&lt; <a class="el" href="a01301.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a44ae849dd2d74a7d93322306d7679750">operator-</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:a44ae849dd2d74a7d93322306d7679750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8308fb1780e1c580a1042dcc09a27d0f"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a8308fb1780e1c580a1042dcc09a27d0f"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a8308fb1780e1c580a1042dcc09a27d0f">operator-</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a8308fb1780e1c580a1042dcc09a27d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eae3a2df044ea04cc757344951a45f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40eae3a2df044ea04cc757344951a45f"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a40eae3a2df044ea04cc757344951a45f">operator-</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a40eae3a2df044ea04cc757344951a45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c44006ca3b703c77189d746e6323d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8f3c44006ca3b703c77189d746e6323d"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01585.html">Minus</a>&lt; T2, <a class="el" href="a01301.html">Constant</a>&lt; T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a8f3c44006ca3b703c77189d746e6323d">operator-</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:a8f3c44006ca3b703c77189d746e6323d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab920ce4c223b458acbce8f3dec8a4a77"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ab920ce4c223b458acbce8f3dec8a4a77">operator-</a> (const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v1, const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:ab920ce4c223b458acbce8f3dec8a4a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13bdd7709888a806c275753d12ea503"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#aa13bdd7709888a806c275753d12ea503">operator-</a> (<a class="el" href="a00640.html#a01949">Parameter</a> par1, <a class="el" href="a00640.html#a01949">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:aa13bdd7709888a806c275753d12ea503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db0303334ff0446ffaa8d9255a3569c"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a7db0303334ff0446ffaa8d9255a3569c">operator-</a> (<a class="el" href="a00640.html#a01949">Parameter</a> par1, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a7db0303334ff0446ffaa8d9255a3569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d754bfc3fcc10756af1068b0f9a39cf"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a7d754bfc3fcc10756af1068b0f9a39cf">operator-</a> (<a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="a00640.html#a01949">Parameter</a> par2)</td></tr>
<tr class="separator:a7d754bfc3fcc10756af1068b0f9a39cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6267811860a8bb98f1a914df2fe8b3f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6267811860a8bb98f1a914df2fe8b3f5"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a6267811860a8bb98f1a914df2fe8b3f5">operator/</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a6267811860a8bb98f1a914df2fe8b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690716952fb0f6482cad983fa448184b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a690716952fb0f6482cad983fa448184b"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a690716952fb0f6482cad983fa448184b">operator/</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a690716952fb0f6482cad983fa448184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0896a1dbd723a3eef55356c69dc692a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0896a1dbd723a3eef55356c69dc692a5"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a0896a1dbd723a3eef55356c69dc692a5">operator/</a> (const T &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a0896a1dbd723a3eef55356c69dc692a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf636c5faf60ed3d1a5f999262252b4f"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#aaf636c5faf60ed3d1a5f999262252b4f">operator/</a> (const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v1, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:aaf636c5faf60ed3d1a5f999262252b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dc58e9b41feba5a89a93826fd73c22"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:a54dc58e9b41feba5a89a93826fd73c22"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01325.html">Divide</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a54dc58e9b41feba5a89a93826fd73c22">operator/</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a54dc58e9b41feba5a89a93826fd73c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50088fd950900d64d11e9de4bbc0267e"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a50088fd950900d64d11e9de4bbc0267e">operator/</a> (const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v2, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a50088fd950900d64d11e9de4bbc0267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e44113c8c7fad75c3e8322730d0056"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad5e44113c8c7fad75c3e8322730d0056"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01325.html">Divide</a>&lt; <a class="el" href="a01301.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ad5e44113c8c7fad75c3e8322730d0056">operator/</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:ad5e44113c8c7fad75c3e8322730d0056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb214ec121e9fe94216ea14a5969980"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6fb214ec121e9fe94216ea14a5969980"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01325.html">Divide</a>&lt; T2, <a class="el" href="a01301.html">Constant</a>&lt; T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a6fb214ec121e9fe94216ea14a5969980">operator/</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:a6fb214ec121e9fe94216ea14a5969980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bd528ede4b1f7965dde856dc58a4a5"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a07bd528ede4b1f7965dde856dc58a4a5"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a07bd528ede4b1f7965dde856dc58a4a5">operator/</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a07bd528ede4b1f7965dde856dc58a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49b1764415ff5aea1765d20d6bdf294"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ad49b1764415ff5aea1765d20d6bdf294">operator/</a> (<a class="el" href="a00640.html#a01949">Parameter</a> par1, <a class="el" href="a00640.html#a01949">Parameter</a> const par2)</td></tr>
<tr class="separator:ad49b1764415ff5aea1765d20d6bdf294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa667417b38750ad07ee2bf114c2daa6c"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#aa667417b38750ad07ee2bf114c2daa6c">operator/</a> (<a class="el" href="a00640.html#a01949">Parameter</a> par1, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:aa667417b38750ad07ee2bf114c2daa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08c97f88f33ecdea89c8fb0729aa6f7"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ab08c97f88f33ecdea89c8fb0729aa6f7">operator/</a> (<a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="a00640.html#a01949">Parameter</a> par2)</td></tr>
<tr class="separator:ab08c97f88f33ecdea89c8fb0729aa6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a15cdb083719133399edb77f5ef3eb547">operator&lt;&lt;</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a15cdb083719133399edb77f5ef3eb547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a6fab8d226ee701c0755c60202fc30f6c">operator&lt;&lt;</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:a6fab8d226ee701c0755c60202fc30f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ad4d7f13d811f0d63d4ce49d31b6cfbe0">operator&lt;&lt;</a> (std::ostream &amp;os, std::pair&lt; T1, T2 &gt; const &amp;obj)</td></tr>
<tr class="separator:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa8037907332bf633dfc1bc3b40865c"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a3fa8037907332bf633dfc1bc3b40865c">operator&lt;&lt;</a> (ostream &amp;s, const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v)</td></tr>
<tr class="separator:a3fa8037907332bf633dfc1bc3b40865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacce78528c9499de97312cbe606ece4"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#aaacce78528c9499de97312cbe606ece4">operator&lt;&lt;</a> (ostream &amp;s, const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v)</td></tr>
<tr class="separator:aaacce78528c9499de97312cbe606ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , class charT , class traits &gt; </td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a21d7262b80d73f956ed1a477607b9053">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a21d7262b80d73f956ed1a477607b9053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a067a6647c6343cc50dee7a51fabb68"><td class="memItemLeft" align="right" valign="top">__host__ std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a8a067a6647c6343cc50dee7a51fabb68">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="a00640.html#a01949">Parameter</a> const &amp;var)</td></tr>
<tr class="separator:a8a067a6647c6343cc50dee7a51fabb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac071787192b20e972cf00234b76faea9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac071787192b20e972cf00234b76faea9"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ac071787192b20e972cf00234b76faea9">operator==</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ac071787192b20e972cf00234b76faea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec01a9cb1b436bae42e4507e49cb63f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afec01a9cb1b436bae42e4507e49cb63f"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#afec01a9cb1b436bae42e4507e49cb63f">operator==</a> (const T &amp;lhs, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:afec01a9cb1b436bae42e4507e49cb63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5843159f4dbcbdbdd1d0cc3e48e36757"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5843159f4dbcbdbdd1d0cc3e48e36757"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a5843159f4dbcbdbdd1d0cc3e48e36757">operator==</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a5843159f4dbcbdbdd1d0cc3e48e36757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc9da09d22eae43ed970a123baa27f1"><td class="memTemplParams" colspan="2">template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:aebc9da09d22eae43ed970a123baa27f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aebc9da09d22eae43ed970a123baa27f1">operator==</a> (const <a class="el" href="a00648.html#a01233">Decays</a>&lt; N1, hydra::detail::BackendPolicy&lt; BACKEND1 &gt; &gt; &amp;lhs, const <a class="el" href="a00648.html#a01233">Decays</a>&lt; N2, hydra::detail::BackendPolicy&lt; BACKEND2 &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:aebc9da09d22eae43ed970a123baa27f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a49a0907b93c595507fbd2ea319f2f5d6">operator==</a> (const <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bb8fdd61818627ed79ccfcd9d94884"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:ac2bb8fdd61818627ed79ccfcd9d94884"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ac2bb8fdd61818627ed79ccfcd9d94884">operator==</a> (const <a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:ac2bb8fdd61818627ed79ccfcd9d94884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename charT , class traits &gt; </td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a63ad8f84031200c3161c889507d3a9c0">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;is, <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a63ad8f84031200c3161c889507d3a9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d07aff11d25df4ff7d7e38604f015c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d07aff11d25df4ff7d7e38604f015c9"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a3d07aff11d25df4ff7d7e38604f015c9">polar</a> (const T &amp;m, const T &amp;theta=0)</td></tr>
<tr class="separator:a3d07aff11d25df4ff7d7e38604f015c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17e6f0c375b2466aa3f5f3cac2bbe7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad17e6f0c375b2466aa3f5f3cac2bbe7c"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ad17e6f0c375b2466aa3f5f3cac2bbe7c">pow</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ad17e6f0c375b2466aa3f5f3cac2bbe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ebd81e3e8bf8f08d2c22a944013dc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3ebd81e3e8bf8f08d2c22a944013dc4"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ab3ebd81e3e8bf8f08d2c22a944013dc4">pow</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ab3ebd81e3e8bf8f08d2c22a944013dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fc18905a529d3783d8c127d095c592"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17fc18905a529d3783d8c127d095c592"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a17fc18905a529d3783d8c127d095c592">pow</a> (const T &amp;x, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a17fc18905a529d3783d8c127d095c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae212a36bc65abcf66392bd49232ec06b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae212a36bc65abcf66392bd49232ec06b"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ae212a36bc65abcf66392bd49232ec06b">pow</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:ae212a36bc65abcf66392bd49232ec06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbfc53307695dddb5ac8b18945e8510"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3dbfc53307695dddb5ac8b18945e8510"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a3dbfc53307695dddb5ac8b18945e8510">pow</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const U &amp;y)</td></tr>
<tr class="separator:a3dbfc53307695dddb5ac8b18945e8510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b268e8ec63688dfa15b64c335dfdb7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa8b268e8ec63688dfa15b64c335dfdb7"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aa8b268e8ec63688dfa15b64c335dfdb7">pow</a> (const T &amp;x, const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:aa8b268e8ec63688dfa15b64c335dfdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#acb0c9817024c69efe44c2d9653928519">PrintToStream</a> (std::ostream &amp;ostream, const char *format, Args... args)</td></tr>
<tr class="separator:acb0c9817024c69efe44c2d9653928519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951671ac8d7193e176fe3a6ffb75aa22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a951671ac8d7193e176fe3a6ffb75aa22"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a951671ac8d7193e176fe3a6ffb75aa22">proj</a> (const T &amp;z)</td></tr>
<tr class="separator:a951671ac8d7193e176fe3a6ffb75aa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b257293c03a3475bb28e9575e941ad"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a68b257293c03a3475bb28e9575e941ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a68b257293c03a3475bb28e9575e941ad">rbegin</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a68b257293c03a3475bb28e9575e941ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a2906e8baa707b7e3cbe3ab1c1aa3fa7c">rbegin</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ac8a38d5cd44fe4f3f940d47e676ce"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a49ac8a38d5cd44fe4f3f940d47e676ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a49ac8a38d5cd44fe4f3f940d47e676ce">rbegin</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a49ac8a38d5cd44fe4f3f940d47e676ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffd7cc506e85ce42d0e99eefcf78441"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a4ffd7cc506e85ce42d0e99eefcf78441"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a4ffd7cc506e85ce42d0e99eefcf78441">rbegin</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a4ffd7cc506e85ce42d0e99eefcf78441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53513fea217a83151a1c98692a1bdbc7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a53513fea217a83151a1c98692a1bdbc7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a53513fea217a83151a1c98692a1bdbc7">rend</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a53513fea217a83151a1c98692a1bdbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc64d77a9d74b4606c449937491181"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a96fc64d77a9d74b4606c449937491181"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a96fc64d77a9d74b4606c449937491181">rend</a> (<a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a96fc64d77a9d74b4606c449937491181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875bce64e99a04ae98453f880d98beed"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a875bce64e99a04ae98453f880d98beed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a875bce64e99a04ae98453f880d98beed">rend</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a875bce64e99a04ae98453f880d98beed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91c3c9f02109abdb77527a81fdcf76c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ae91c3c9f02109abdb77527a81fdcf76c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ae91c3c9f02109abdb77527a81fdcf76c">rend</a> (<a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ae91c3c9f02109abdb77527a81fdcf76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53a2a0ba453b6b2a3372941b6e17fbc"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ab53a2a0ba453b6b2a3372941b6e17fbc">rotateEuler</a> (const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;rs, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> alpha, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> beta, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> gamma)</td></tr>
<tr class="separator:ab53a2a0ba453b6b2a3372941b6e17fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4412e9c9e2eec0cff2c3518f50109e"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#aef4412e9c9e2eec0cff2c3518f50109e">rotateEuler</a> (const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> phi, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> theta, <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> ksi)</td></tr>
<tr class="separator:aef4412e9c9e2eec0cff2c3518f50109e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc492c9f6771b3d5a0741568c2076fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebc492c9f6771b3d5a0741568c2076fe"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aebc492c9f6771b3d5a0741568c2076fe">sin</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:aebc492c9f6771b3d5a0741568c2076fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace70e751d07c5055a98d10ea4ca7b0e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace70e751d07c5055a98d10ea4ca7b0e8"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ace70e751d07c5055a98d10ea4ca7b0e8">sinh</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ace70e751d07c5055a98d10ea4ca7b0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c54fb833c00a61ad29f0203620ec27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9c54fb833c00a61ad29f0203620ec27"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ac9c54fb833c00a61ad29f0203620ec27">sqrt</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ac9c54fb833c00a61ad29f0203620ec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68439b2b58b78d0c3a9cc5ab9c9d56bc"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I&gt; </td></tr>
<tr class="memitem:a68439b2b58b78d0c3a9cc5ab9c9d56bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a68439b2b58b78d0c3a9cc5ab9c9d56bc">stream_array_helper</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="memdesc:a68439b2b58b78d0c3a9cc5ab9c9d56bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">array streamer helper  <a href="#a68439b2b58b78d0c3a9cc5ab9c9d56bc">More...</a><br /></td></tr>
<tr class="separator:a68439b2b58b78d0c3a9cc5ab9c9d56bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a6b2446e6e58a2466b66c1277d67075ad">stream_array_helper</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a6b2446e6e58a2466b66c1277d67075ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa85435e7d698dd282905782158cb160"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:aaa85435e7d698dd282905782158cb160"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#aaa85435e7d698dd282905782158cb160">stream_tuple_helper</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="memdesc:aaa85435e7d698dd282905782158cb160"><td class="mdescLeft">&#160;</td><td class="mdescRight">tuple streamer helper  <a href="#aaa85435e7d698dd282905782158cb160">More...</a><br /></td></tr>
<tr class="separator:aaa85435e7d698dd282905782158cb160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#af0ba407638beac5920ac997d3021b413">stream_tuple_helper</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:af0ba407638beac5920ac997d3021b413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc5a9f732999e9df34308b7bcbf4247"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a9cc5a9f732999e9df34308b7bcbf4247"><td class="memTemplItemLeft" align="right" valign="top">__host__ <a class="el" href="a01629.html">Sum</a>&lt; F1, F2, Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a9cc5a9f732999e9df34308b7bcbf4247">sum</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:a9cc5a9f732999e9df34308b7bcbf4247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bf180ccfd77a9a98b930f1a476fde5"><td class="memItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a37bf180ccfd77a9a98b930f1a476fde5">swap</a> (<a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v1, <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:a37bf180ccfd77a9a98b930f1a476fde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a72473a58a218963306ce701e5ff1c"><td class="memItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a08a72473a58a218963306ce701e5ff1c">swap</a> (<a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v1, <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:a08a72473a58a218963306ce701e5ff1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e37350fab9720792ac5d23ea047111"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2e37350fab9720792ac5d23ea047111"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#af2e37350fab9720792ac5d23ea047111">tan</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:af2e37350fab9720792ac5d23ea047111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6953c8ef19e2de75badc83057a19896e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6953c8ef19e2de75badc83057a19896e"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#a6953c8ef19e2de75badc83057a19896e">tanh</a> (const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a6953c8ef19e2de75badc83057a19896e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67692a9e684658ef31189029c802047"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:ad67692a9e684658ef31189029c802047"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00648.html#ad67692a9e684658ef31189029c802047">tie</a> (T &amp;&amp;...<a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::tie(std::forward&lt; T &gt;(<a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>)...))</td></tr>
<tr class="memdesc:ad67692a9e684658ef31189029c802047"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments.  <a href="#ad67692a9e684658ef31189029c802047">More...</a><br /></td></tr>
<tr class="separator:ad67692a9e684658ef31189029c802047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06bab1ad739e661a92fbf918012c9736"><td class="memTemplParams" colspan="2">template&lt;typename L , typename ... T&gt; </td></tr>
<tr class="memitem:ga06bab1ad739e661a92fbf918012c9736"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00643.html#ga06bab1ad739e661a92fbf918012c9736">wrap_lambda</a> (L const &amp;f, T ...pars) -&gt; decltype(detail::wrap_lambda_helper(f, typename detail::function_traits&lt; L &gt;::return_type(), typename detail::function_traits&lt; L &gt;::args_type(), std::array&lt; <a class="el" href="a00640.html#a01949">Parameter</a>, sizeof...(T)&gt;</td></tr>
<tr class="memdesc:ga06bab1ad739e661a92fbf918012c9736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template for wrap a C++11 lambda into a hydra lambda with a certain number of parameters.  <a href="a00643.html#ga06bab1ad739e661a92fbf918012c9736">More...</a><br /></td></tr>
<tr class="separator:ga06bab1ad739e661a92fbf918012c9736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53506830108537bc49811415296ba738"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:ga53506830108537bc49811415296ba738"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00643.html#ga53506830108537bc49811415296ba738">wrap_lambda</a> (L const &amp;f) -&gt; decltype(detail::wrap_lambda_helper(f, typename detail::function_traits&lt; L &gt;::return_type(), typename detail::function_traits&lt; L &gt;::args_type()))</td></tr>
<tr class="memdesc:ga53506830108537bc49811415296ba738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template for wrap a C++11 lambda into a hydra lambda.  <a href="a00643.html#ga53506830108537bc49811415296ba738">More...</a><br /></td></tr>
<tr class="separator:ga53506830108537bc49811415296ba738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab14adaa26f703b8c130df530167ebd23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ab14adaa26f703b8c130df530167ebd23">kFalse</a> = false</td></tr>
<tr class="separator:ab14adaa26f703b8c130df530167ebd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a1556536d7a73fa95e5a9c9610f76a3c1">kTrue</a> = true</td></tr>
<tr class="separator:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7accc9ea763820b1cb2152a2473ac2"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="a00640.html#a01949">Parameter</a>, sizeof...(T)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a5f7accc9ea763820b1cb2152a2473ac2">parameters</a> { pars...}</td></tr>
<tr class="separator:a5f7accc9ea763820b1cb2152a2473ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#a5afb8f1b6ea1ba2b8fc79444e5d20f20">PrintLevel</a> = <a class="el" href="a00648.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td></tr>
<tr class="separator:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ce9917997c3883840d3d5292f37860"><td class="memItemLeft" align="right" valign="top">traits::return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ab4ce9917997c3883840d3d5292f37860">r</a> = typename traits::return_type()</td></tr>
<tr class="separator:ab4ce9917997c3883840d3d5292f37860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76a4e62b2b1b3cfbc78ccce890374ac"><td class="memItemLeft" align="right" valign="top">traits::args_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a></td></tr>
<tr class="separator:ae76a4e62b2b1b3cfbc78ccce890374ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic policies definition. </p>
<dl class="todo"><dt><b><a class="el" href="a00638.html#_todo000004">Todo:</a></b></dt><dd>: fix compile error in nvcc adding variants to vectors</dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="a01217" id="a01217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01217">&#9670;&nbsp;</a></span>hydra::Cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Cache</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Backend, typename ... Functors&gt;<br />
class hydra::Cache&lt; Backend, Functors &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Cache&lt; Backend, Functors &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01215.svg" width="178" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01225" id="a01225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01225">&#9670;&nbsp;</a></span>hydra::Chains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Chains</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... Decays&gt;<br />
class hydra::Chains&lt; Decays &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Chains&lt; Decays &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01223.svg" width="183" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01233" id="a01233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01233">&#9670;&nbsp;</a></span>hydra::Decays</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Decays</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND&gt;<br />
class hydra::Decays&lt; N, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Decays&lt; N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01231.svg" width="226" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01253" id="a01253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01253">&#9670;&nbsp;</a></span>hydra::DenseHistogram</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::DenseHistogram</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T, typename = typename detail::dimensionality&lt;N&gt;::type, typename = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type&gt;<br />
class hydra::DenseHistogram&lt; N, T, typename, typename &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a02083.html#_a8">/home/augalves/Development/Release/Hydra/examples/async/async_mc.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::DenseHistogram&lt; N, T, typename, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01251.svg" width="214" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01837" id="a01837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01837">&#9670;&nbsp;</a></span>hydra::FCN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::FCN</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class hydra::FCN&lt; T &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::FCN&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a01836.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::FCN&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01835.svg" width="134" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01857" id="a01857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01857">&#9670;&nbsp;</a></span>hydra::GaussKronrodAdaptiveQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodAdaptiveQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01855.svg" width="207" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01865" id="a01865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01865">&#9670;&nbsp;</a></span>hydra::GaussKronrodQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01863.svg" width="220" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01877" id="a01877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01877">&#9670;&nbsp;</a></span>hydra::GaussKronrodRuleSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::GaussKronrodRuleSelector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N&gt;<br />
struct hydra::GaussKronrodRuleSelector&lt; N &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodRuleSelector&lt; N &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01875.svg" width="266" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01909" id="a01909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01909">&#9670;&nbsp;</a></span>hydra::GenzMalikQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND&gt;<br />
class hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01907.svg" width="199" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01921" id="a01921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01921">&#9670;&nbsp;</a></span>hydra::GenzMalikRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikRule</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t DIM, typename BACKEND&gt;<br />
class hydra::GenzMalikRule&lt; DIM, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01919.svg" width="162" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01849" id="a01849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01849">&#9670;&nbsp;</a></span>hydra::LambdaWrapper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::LambdaWrapper</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Sig, typename L, size_t N, typename = typename std::enable_if&lt;std::is_constructible&lt;std::function&lt;Sig&gt;, L&gt;::value&gt;::type&gt;<br />
class hydra::LambdaWrapper&lt; Sig, L, N, typename &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::LambdaWrapper&lt; Sig, L, N, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01847.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01929" id="a01929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01929">&#9670;&nbsp;</a></span>hydra::LogLikelihoodFCN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::LogLikelihoodFCN</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename PDF, typename Iterator, typename... Extensions&gt;<br />
class hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01927.svg" width="206" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01933" id="a01933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01933">&#9670;&nbsp;</a></span>hydra::multiarray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multiarray</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T, typename BACKEND&gt;<br />
class hydra::multiarray&lt; N, T, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a02083.html#_a6">/home/augalves/Development/Release/Hydra/examples/async/async_mc.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::multiarray&lt; N, T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01931.svg" width="150" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01941" id="a01941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01941">&#9670;&nbsp;</a></span>hydra::multivector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multivector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename BACKEND&gt;<br />
class hydra::multivector&lt; T, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01939.svg" width="139" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a02037" id="a02037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02037">&#9670;&nbsp;</a></span>hydra::null_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::null_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::null_type:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a02035.svg" width="126" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01973" id="a01973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01973">&#9670;&nbsp;</a></span>hydra::PhaseSpaceIntegrator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::PhaseSpaceIntegrator</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename Backend, typename GRND = HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt;<br />
class hydra::PhaseSpaceIntegrator&lt; N, Backend, GRND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::PhaseSpaceIntegrator&lt; N, Backend, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01971.svg" width="202" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a01993" id="a01993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01993">&#9670;&nbsp;</a></span>hydra::Plain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::Plain</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt;<br />
struct hydra::Plain&lt; N, BACKEND, GRND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Plain&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01991.svg" width="202" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a02009" id="a02009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02009">&#9670;&nbsp;</a></span>hydra::SparseHistogram</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::SparseHistogram</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T, typename = typename detail::dimensionality&lt;N&gt;::type, typename = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type&gt;<br />
class hydra::SparseHistogram&lt; N, T, typename, typename &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a02083.html#_a12">/home/augalves/Development/Release/Hydra/examples/async/async_mc.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::SparseHistogram&lt; N, T, typename, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a02007.svg" width="214" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a02053" id="a02053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02053">&#9670;&nbsp;</a></span>hydra::Vegas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Vegas</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt;<br />
class hydra::Vegas&lt; N, BACKEND, GRND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Vegas&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a02051.svg" width="210" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="a02069" id="a02069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02069">&#9670;&nbsp;</a></span>hydra::Weights</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Weights</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Backend&gt;<br />
class hydra::Weights&lt; Backend &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Weights&lt; Backend &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a02067.svg" width="196" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">&#9670;&nbsp;</a></span>BoolVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&gt; <a class="el" href="a00648.html#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">hydra::BoolVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="a00642.html#a02049" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector. </p>

</div>
</div>
<a id="a274b1c32d255fc13e78a08e96de133f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b1c32d255fc13e78a08e96de133f0">&#9670;&nbsp;</a></span>BoolVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&gt; <a class="el" href="a00648.html#a274b1c32d255fc13e78a08e96de133f0">hydra::BoolVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="a00642.html#a02045" title="This class represents three-dimensional Euclidian vectors and implements common operation performed o...">Vector3R</a> host vector. </p>
<p>Use it to store four-vectors at <b>host</b>. </p>

</div>
</div>
<a id="a4f9af1aefe36fa4f80f57289ffb84dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9af1aefe36fa4f80f57289ffb84dca">&#9670;&nbsp;</a></span>complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">hydra::complex</a> = typedef HYDRA_EXTERNAL_NS::thrust::complex&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7670b2993eb064d9c192d9200ab82b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7670b2993eb064d9c192d9200ab82b89">&#9670;&nbsp;</a></span>ComplexVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="a00648.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a>&gt; <a class="el" href="a00648.html#a7670b2993eb064d9c192d9200ab82b89">hydra::ComplexVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GReal_t device vector. </p>

</div>
</div>
<a id="af30019aaf18d88f73acd61f2f363f9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30019aaf18d88f73acd61f2f363f9f6">&#9670;&nbsp;</a></span>ComplexVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="a00648.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a>&gt; <a class="el" href="a00648.html#af30019aaf18d88f73acd61f2f363f9f6">hydra::ComplexVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GReal_t host vector. </p>

</div>
</div>
<a id="ada2d81895ace081c5204b9adc76a2808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2d81895ace081c5204b9adc76a2808">&#9670;&nbsp;</a></span>FourVectors_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="a00642.html#a02049">Vector4R</a>&gt; <a class="el" href="a00648.html#ada2d81895ace081c5204b9adc76a2808">hydra::FourVectors_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for complex number. </p>

</div>
</div>
<a id="aa8c251ed5017d0638da929130062bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c251ed5017d0638da929130062bcad">&#9670;&nbsp;</a></span>GBool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">hydra::GBool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean (0=false, 1=true) (bool) </p>

</div>
</div>
<a id="ae2da2ab0037e6bca3cb7c15adc5c4125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">&#9670;&nbsp;</a></span>GByte_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="a00648.html#ae2da2ab0037e6bca3cb7c15adc5c4125">hydra::GByte_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte (8 bits) (unsigned char) </p>

</div>
</div>
<a id="a7ab04a199389c4989174dc115507fa89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab04a199389c4989174dc115507fa89">&#9670;&nbsp;</a></span>GChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="a00648.html#a7ab04a199389c4989174dc115507fa89">hydra::GChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Character 1 byte (char) </p>

</div>
</div>
<a id="a7ab78a78009fd9969bce04250387d13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab78a78009fd9969bce04250387d13e">&#9670;&nbsp;</a></span>GComplex_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::complex&lt;<a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="a00648.html#a7ab78a78009fd9969bce04250387d13e">hydra::GComplex_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af986267d40d932c5cbf0ae874a506f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af986267d40d932c5cbf0ae874a506f83">&#9670;&nbsp;</a></span>GDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="a00648.html#af986267d40d932c5cbf0ae874a506f83">hydra::GDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 8 bytes. </p>

</div>
</div>
<a id="a71bab7b854d7b3c3042fe47201b765eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bab7b854d7b3c3042fe47201b765eb">&#9670;&nbsp;</a></span>GFloat_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="a00648.html#a71bab7b854d7b3c3042fe47201b765eb">hydra::GFloat_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Float 4 bytes (float) </p>

</div>
</div>
<a id="a0c9fb4d7195ab952da10a82d5c4ad30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">&#9670;&nbsp;</a></span>GInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="a00648.html#a0c9fb4d7195ab952da10a82d5c4ad30e">hydra::GInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer 4 bytes (int) </p>

</div>
</div>
<a id="a9d68c21fb715bbfb1edc5b1933b173e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d68c21fb715bbfb1edc5b1933b173e9">&#9670;&nbsp;</a></span>GLong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long long <a class="el" href="a00648.html#a9d68c21fb715bbfb1edc5b1933b173e9">hydra::GLong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable signed long integer 8 bytes. </p>

</div>
</div>
<a id="a5f57a4025b40929c2708cd544c3a1ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f57a4025b40929c2708cd544c3a1ccd">&#9670;&nbsp;</a></span>GLong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="a00648.html#a5f57a4025b40929c2708cd544c3a1ccd">hydra::GLong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed long integer 4 bytes (long) </p>

</div>
</div>
<a id="a751abe69b482cde879c718fd4775733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751abe69b482cde879c718fd4775733f">&#9670;&nbsp;</a></span>GLongDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long double <a class="el" href="a00648.html#a751abe69b482cde879c718fd4775733f">hydra::GLongDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Long Double. </p>

</div>
</div>
<a id="a971e94bcb8c43741d11f9d8eb98f5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971e94bcb8c43741d11f9d8eb98f5fab">&#9670;&nbsp;</a></span>GReal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">hydra::GReal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 16 bytes or float 4 bytes. </p>

</div>
</div>
<a id="a589c60d92ba893c28d814edd6e149a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589c60d92ba893c28d814edd6e149a9c">&#9670;&nbsp;</a></span>GShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef short <a class="el" href="a00648.html#a589c60d92ba893c28d814edd6e149a9c">hydra::GShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Short integer 2 bytes (short) </p>

</div>
</div>
<a id="abc842c1ec8321e9637dee714dcdaebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc842c1ec8321e9637dee714dcdaebff">&#9670;&nbsp;</a></span>GText_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="a00648.html#abc842c1ec8321e9637dee714dcdaebff">hydra::GText_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General string (char) </p>

</div>
</div>
<a id="a51ef97faee95aa79f3839eb7abdf5238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef97faee95aa79f3839eb7abdf5238">&#9670;&nbsp;</a></span>GUChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="a00648.html#a51ef97faee95aa79f3839eb7abdf5238">hydra::GUChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Character 1 byte (unsigned char) </p>

</div>
</div>
<a id="a251a7b1f515ac1ed9409afd67252a32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251a7b1f515ac1ed9409afd67252a32b">&#9670;&nbsp;</a></span>GUInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="a00648.html#a251a7b1f515ac1ed9409afd67252a32b">hydra::GUInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer 4 bytes (unsigned int) </p>

</div>
</div>
<a id="a55e8443cd746900da90cb1f77807e7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e8443cd746900da90cb1f77807e7c0">&#9670;&nbsp;</a></span>GULong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="a00648.html#a55e8443cd746900da90cb1f77807e7c0">hydra::GULong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable unsigned long integer 8 bytes. </p>

</div>
</div>
<a id="abf9a0d54fd4ed46052939549edd086c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a0d54fd4ed46052939549edd086c5">&#9670;&nbsp;</a></span>GULong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="a00648.html#abf9a0d54fd4ed46052939549edd086c5">hydra::GULong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a911a3042526fac189d0c87a089f52955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911a3042526fac189d0c87a089f52955">&#9670;&nbsp;</a></span>GUShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="a00648.html#a911a3042526fac189d0c87a089f52955">hydra::GUShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Short integer 2 bytes (unsigned short) </p>

</div>
</div>
<a id="a648839818fa9d4a58c2195a55a51e773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648839818fa9d4a58c2195a55a51e773">&#9670;&nbsp;</a></span>mc_device_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">hydra::mc_device_vector</a> = typedef HYDRA_EXTERNAL_NS::thrust::device_vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. </p>

</div>
</div>
<a id="a6de6f086a44380382022dafca75de4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de6f086a44380382022dafca75de4c9">&#9670;&nbsp;</a></span>mc_host_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">hydra::mc_host_vector</a> = typedef HYDRA_EXTERNAL_NS::thrust::host_vector&lt;T, HYDRA_EXTERNAL_NS::thrust::system::cuda::experimental::pinned_allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. mc_host_vectot will always allocate page locked memory on CUDA backends in order to maximize speed in memory transfers to the device. </p>

</div>
</div>
<a id="acf5241d6a56b2040e9cc9ea860b4cbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5241d6a56b2040e9cc9ea860b4cbff">&#9670;&nbsp;</a></span>pair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00648.html#acf5241d6a56b2040e9cc9ea860b4cbff">hydra::pair</a> = typedef HYDRA_EXTERNAL_NS::thrust::pair&lt;T1,T2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pair</code> template is an alias to the HYDRA_EXTERNAL_NS::thrust::pair structure. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of <code>pair's</code> first object type. There are no requirements on the type of <code>T1</code>. <code>T1</code>'s type is provided by <code>pair::first_type</code>.</td></tr>
    <tr><td class="paramname">T2</td><td>The type of <code>pair's</code> second object type. There are no requirements on the type of <code>T2</code>. <code>T2</code>'s type is provided by <code>pair::second_type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34184a169c185689e065d0c30f9ffba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34184a169c185689e065d0c30f9ffba">&#9670;&nbsp;</a></span>Particles_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="a00642.html#a02049">Vector4R</a>&gt; <a class="el" href="a00648.html#ae34184a169c185689e065d0c30f9ffba">hydra::Particles_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GComplex_t device vector. </p>

</div>
</div>
<a id="a9df2f3d6dc63cf297b0f74ba228f6c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2f3d6dc63cf297b0f74ba228f6c89">&#9670;&nbsp;</a></span>Particles_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="a00642.html#a02049">Vector4R</a>&gt; <a class="el" href="a00648.html#a9df2f3d6dc63cf297b0f74ba228f6c89">hydra::Particles_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GComplex_t host vector. </p>

</div>
</div>
<a id="a79fd090c6e39cfcdd744f369dacffabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fd090c6e39cfcdd744f369dacffabe">&#9670;&nbsp;</a></span>RealVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="a00648.html#a79fd090c6e39cfcdd744f369dacffabe">hydra::RealVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GBool_t device vector. </p>

</div>
</div>
<a id="a6d21da5996b50a240e6f400025e3b139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d21da5996b50a240e6f400025e3b139">&#9670;&nbsp;</a></span>RealVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="a00648.html#a6d21da5996b50a240e6f400025e3b139">hydra::RealVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GBool_t host vector. </p>

</div>
</div>
<a id="a7dcdb1155222988a4250114d880e8b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcdb1155222988a4250114d880e8b46">&#9670;&nbsp;</a></span>ThreeVectors_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00648.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="a00642.html#a02045">Vector3R</a>&gt; <a class="el" href="a00648.html#a7dcdb1155222988a4250114d880e8b46">hydra::ThreeVectors_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="a00642.html#a02049" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector. </p>
<p>Use it to store four-vectors at <b>host</b>. </p>

</div>
</div>
<a id="a5e59cc0127adfac6b799c5fd6785431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e59cc0127adfac6b799c5fd6785431b">&#9670;&nbsp;</a></span>tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00648.html#a5e59cc0127adfac6b799c5fd6785431b">hydra::tuple</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>tuple</code> template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can be instantiated with a indefinite number of arguments. </p>
<p>Each template argument specifies the type of element in the <code>tuple</code>. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of <code>tuple</code> with two arguments is similar to an instantiation of <code>pair</code> with the same two arguments. Individual elements of a <code>tuple</code> may be accessed with the <code>get</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TN</td><td>The type of the <code>N</code> <code>tuple</code> element.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to create a new <code>tuple</code> object and inspect and modify the value of its elements.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;hydra/tuple.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">// create a tuple containing an int, a float, and a string</span></div><div class="line">hydra::tuple&lt;int, float, <span class="keyword">const</span> <span class="keywordtype">char</span>*&gt; <a class="code" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>(13, 0.1f, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// individual members are accessed with the free function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The first element&#39;s value is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(<a class="code" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// or the member function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The second element&#39;s value is &quot;</span> &lt;&lt; <a class="code" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>.get&lt;1&gt;() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// we can also modify elements with the same function</span></div><div class="line">hydra::get&lt;0&gt;(<a class="code" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>) += 10;</div></div><!-- fragment --> 
</div>
</div>
<a id="a3ecb38ba9198aee2de36f374d07638de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecb38ba9198aee2de36f374d07638de">&#9670;&nbsp;</a></span>tuple_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00648.html#a3ecb38ba9198aee2de36f374d07638de">hydra::tuple_element</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00380.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;int, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; <a class="code" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(<a class="code" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>This metafunction returns the type of a <code>tuple's</code> <code>N</code>th element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>This parameter selects the element of interest. </td></tr>
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab06a4451f99b94119ead1dcadf2b8e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06a4451f99b94119ead1dcadf2b8e31">&#9670;&nbsp;</a></span>tuple_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00648.html#ab06a4451f99b94119ead1dcadf2b8e31">hydra::tuple_size</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This metafunction returns the number of elements of a <code>tuple</code> type of interest. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aed873b1b84fbec3791e721b22a52d1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed873b1b84fbec3791e721b22a52d1fe">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1fea4517ec382985cb7a39393c0da09e58d5"></a>INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26"></a>WARNING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1feadbc96f88184ea3a51f68df95e2b44851"></a>ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1107488f838687e73b39ddd8245f40d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1107488f838687e73b39ddd8245f40d0">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0aae772e8b4c5ada0e1e4c65495702176a"></a>MODE_IMPORTANCE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0a28550661921a3af1306fa74a26b8569c"></a>MODE_IMPORTANCE_ONLY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0acb2c0124fecbf6c1182f1cf7cd9bc37a"></a>MODE_STRATIFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0aba2629d0445cc7ef401fd6793f047da0"></a>BINS_MAX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab7ba86af6b39da2d26222b1bc200814c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ba86af6b39da2d26222b1bc200814c">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T hydra::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0f35a53dc5c3388a2ab13ddde5dc39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f35a53dc5c3388a2ab13ddde5dc39c">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a747815d02662791baa7a68032d4cac5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747815d02662791baa7a68032d4cac5e">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8cac9fee3f765860563dcc08a6a42e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cac9fee3f765860563dcc08a6a42e9">&#9670;&nbsp;</a></span>add_pdfs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01961.html">PDFSumExtendable</a>&lt;PDF1, PDF2, PDFs...&gt; hydra::add_pdfs </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; <a class="el" href="a00640.html#a01949">Parameter</a> *, sizeof...(PDFs)+2 &gt;const &amp;&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PDF1 const &amp;&#160;</td>
          <td class="paramname"><em>pdf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PDF2 const &amp;&#160;</td>
          <td class="paramname"><em>pdf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PDFs const &amp;...&#160;</td>
          <td class="paramname"><em>pdfs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to add pdfs without set template parameters explicitly. </p>

</div>
</div>
<a id="aedd00ebc1db7600324fe4e6b30c05d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd00ebc1db7600324fe4e6b30c05d7e">&#9670;&nbsp;</a></span>add_pdfs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt;PDF1, PDF2, PDFs...&gt; hydra::add_pdfs </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; <a class="el" href="a00640.html#a01949">Parameter</a> *, sizeof...(PDFs)+1 &gt;const &amp;&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PDF1 const &amp;&#160;</td>
          <td class="paramname"><em>pdf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PDF2 const &amp;&#160;</td>
          <td class="paramname"><em>pdf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PDFs const &amp;...&#160;</td>
          <td class="paramname"><em>pdfs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to add pdfs without set template parameters explicitly. </p>

</div>
</div>
<a id="a4f175cc8f2c59f6cf2c416354fdb951f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f175cc8f2c59f6cf2c416354fdb951f">&#9670;&nbsp;</a></span>apply_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01905.html">hydra::GenericRange</a>&lt; typename Container::iterator &gt; hydra::apply_filter </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a filter to the range [first, last] and return a pair of iterators for the filtered events. </p>
<p>This function will not change the size of the original range, [first, last], but will reorder the entries to put together the accepted entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the begin of the range to filter. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the range to filter. </td></tr>
    <tr><td class="paramname">filter</td><td>Functor returning bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac4363cbd28bb5e42f27241e5bca02f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4363cbd28bb5e42f27241e5bca02f0d">&#9670;&nbsp;</a></span>arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T hydra::arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7288f22488e57a5b739979864a86e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7288f22488e57a5b739979864a86e38">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a579b00aff8ca48e2f3a2e8b24ddeb571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b00aff8ca48e2f3a2e8b24ddeb571">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab20a2c3862e19a865286b0b3aaa3d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20a2c3862e19a865286b0b3aaa3d146">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7689f62c3b4d6a9c4cd9c167d19f0911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7689f62c3b4d6a9c4cd9c167d19f0911">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe8c272359dca5fb49f5a76d4cf93451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8c272359dca5fb49f5a76d4cf93451">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f1cb0e2e3473d8e25b079dd72b8bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1cb0e2e3473d8e25b079dd72b8bc8a">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6874d900b0238ec21d1490998de81f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6874d900b0238ec21d1490998de81f99">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca6d2db036860acb6cd33738ba85e357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6d2db036860acb6cd33738ba85e357">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52d2bb64b855258800238a7263f26699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d2bb64b855258800238a7263f26699">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a> hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56aaad7de821363b5a3f6a3853688a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56aaad7de821363b5a3f6a3853688a5f">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a> hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>boost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f1429976b67876d11b19469677d7223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1429976b67876d11b19469677d7223">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 , typename ... Ts, typename  = typename std::enable_if&lt;T0::is_functor::value &amp;&amp; T1::is_functor::value &amp;&amp; detail::all_true&lt;Ts::is_functor::value...&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01297.html">Compose</a>&lt;T0,T1,Ts...&gt; hydra::compose </td>
          <td>(</td>
          <td class="paramtype">T0 const &amp;&#160;</td>
          <td class="paramname"><em>F0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts const &amp;...&#160;</td>
          <td class="paramname"><em>Fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a9f167506a6f00739dccfab84d60c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9f167506a6f00739dccfab84d60c83">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28aa8ffeea73bf98ccab0fb7cd1c8116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aa8ffeea73bf98ccab0fb7cd1c8116">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator hydra::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98b97d9c4a1b0350ef7c2d646c8c504a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b97d9c4a1b0350ef7c2d646c8c504a">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::Backend Backend, typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator hydra::copy </td>
          <td>(</td>
          <td class="paramtype">hydra::detail::BackendPolicy&lt; Backend &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb7154a99c3dfc0f0718e0b2762f11ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7154a99c3dfc0f0718e0b2762f11ac">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b238296c1ef949b0b3d31134e23445a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b238296c1ef949b0b3d31134e23445a">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeafa4366407089182878f1f595038b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafa4366407089182878f1f595038b13">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a> hydra::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1016bfa0c15215b4c14afc007d932074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1016bfa0c15215b4c14afc007d932074">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ auto hydra::distance </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( HYDRA_EXTERNAL_NS::thrust::distance&lt;Iterator&gt;(first,last))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a762ed9329b60137d5230242c159b0c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762ed9329b60137d5230242c159b0c6d">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01325.html">Divide</a>&lt;T1,T2&gt; hydra::divide </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f434b6fb7d95b6ca2a386e25e6b6733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f434b6fb7d95b6ca2a386e25e6b6733">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4f44ac4277e27b370317451862a091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f44ac4277e27b370317451862a091d">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7f8d7b0cfc77696dd1ba9aaf31d23a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f8d7b0cfc77696dd1ba9aaf31d23a7">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c20a7a5048641695b7f0e61b725f416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c20a7a5048641695b7f0e61b725f416">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77f0de94ba6edf1f98d40ea2afd91a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f0de94ba6edf1f98d40ea2afd91a94">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a02083.html#a1">/home/augalves/Development/Release/Hydra/examples/async/async_mc.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a5ad01484e7c92de1226a1d341df3325e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad01484e7c92de1226a1d341df3325e">&#9670;&nbsp;</a></span>get() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00380.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;int, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; <a class="code" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(<a class="code" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>) &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
<a id="a7540bfa2632da70c72f837a0f2693c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7540bfa2632da70c72f837a0f2693c25">&#9670;&nbsp;</a></span>get() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d13dee5e010004d3e43db4763165557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d13dee5e010004d3e43db4763165557">&#9670;&nbsp;</a></span>get() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::pair&lt;T1,T2&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bd95a2e510a972665cc8e93abb7ad00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd95a2e510a972665cc8e93abb7ad00">&#9670;&nbsp;</a></span>get() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.column(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa301daa15842709092a044086afe7547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa301daa15842709092a044086afe7547">&#9670;&nbsp;</a></span>get() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.column(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a263225f66d8e954e0391c8445e50bc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263225f66d8e954e0391c8445e50bc04">&#9670;&nbsp;</a></span>get_pdf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get_pdf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01961.html">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdfs</em></td><td>)</td>
          <td> -&gt; std::pair&lt; <a class="el" href="a00640.html#a01949">Parameter</a>, typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I,
typename <a class="el" href="a01961.html">PDFSumExtendable</a>&lt;PDF1, PDF2, PDFs...&gt;::pdfs_tuple_type&gt;::type  &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa89ec49a297773352fad3ddb84214fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89ec49a297773352fad3ddb84214fb6">&#9670;&nbsp;</a></span>get_pdf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get_pdf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdfs</em></td><td>)</td>
          <td> -&gt; std::pair&lt; <a class="el" href="a00640.html#a01949">Parameter</a>, typename HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;I,
typename <a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt;PDF1, PDF2, PDFs...&gt;::pdfs_tuple_type&gt;::type  &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7582acf570b53c033d52c6ff0fecb43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7582acf570b53c033d52c6ff0fecb43e">&#9670;&nbsp;</a></span>GetFormatedString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hydra::GetFormatedString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa215df4feed1826c6bc64bade76c39a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa215df4feed1826c6bc64bade76c39a0">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af38d0dd2b2ee0784014d04554b67db6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38d0dd2b2ee0784014d04554b67db6b">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66310c43220a83278f7e1588cf2d0feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66310c43220a83278f7e1588cf2d0feb">&#9670;&nbsp;</a></span>make_chain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ... N, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00648.html#a01225">Chains</a>&lt; <a class="el" href="a00648.html#a01233">Decays</a>&lt;N, hydra::detail::BackendPolicy&lt;BACKEND&gt; &gt;...&gt; hydra::make_chain </td>
          <td>(</td>
          <td class="paramtype">hydra::detail::BackendPolicy&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2940519393c31b1d5566e1894e01bad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2940519393c31b1d5566e1894e01bad7">&#9670;&nbsp;</a></span>make_loglikehood_fcn() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename Integrator , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::make_loglikehood_fcn </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00640.html#a01957">Pdf</a>&lt; Functor, <a class="el" href="a01565.html">Integrator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="a00648.html#a01929">LogLikelihoodFCN</a>&lt; <a class="el" href="a00640.html#a01957">Pdf</a>&lt;Functor,<a class="el" href="a01565.html">Integrator</a>&gt;, Iterator &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25b7d583d231a242249f3a8a2c3ff7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b7d583d231a242249f3a8a2c3ff7d0">&#9670;&nbsp;</a></span>make_loglikehood_fcn() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Pdfs, typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::make_loglikehood_fcn </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01961.html">PDFSumExtendable</a>&lt; Pdfs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="a00648.html#a01929">LogLikelihoodFCN</a>&lt; <a class="el" href="a01961.html">PDFSumExtendable</a>&lt;Pdfs...&gt;, Iterator &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f369bd2cc9adc9091ec7cf15a83739f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f369bd2cc9adc9091ec7cf15a83739f">&#9670;&nbsp;</a></span>make_loglikehood_fcn() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Pdfs, typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::make_loglikehood_fcn </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt; Pdfs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="a00648.html#a01929">LogLikelihoodFCN</a>&lt; <a class="el" href="a01965.html">PDFSumNonExtendable</a>&lt;Pdfs...&gt;, Iterator &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47f6ab65f6835130e8c8237785c2e188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f6ab65f6835130e8c8237785c2e188">&#9670;&nbsp;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::make_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_pair( std::forward&lt;T1&gt;(t1),std::forward&lt;T2&gt;(t2) ))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>The first object to copy from. </td></tr>
    <tr><td class="paramname">T2</td><td>The second object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> object with members which are copies of <code>t</code>. </dd></dl>

</div>
</div>
<a id="a2d468a0d98a74f41479f8ccb95f5533e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d468a0d98a74f41479f8ccb95f5533e">&#9670;&nbsp;</a></span>make_pdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FUNCTOR , typename INTEGRATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00640.html#a01957">Pdf</a>&lt;FUNCTOR, INTEGRATOR&gt; hydra::make_pdf </td>
          <td>(</td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGRATOR&#160;</td>
          <td class="paramname"><em>integrator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="a00640.html#a01957" title="Class describing probability density functions. ">hydra::Pdf</a> given a shape described by a functor and a integrator (algorithm or functor). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>shape. </td></tr>
    <tr><td class="paramname">integrator</td><td>algorithm or functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="a00640.html#a01957" title="Class describing probability density functions. ">hydra::Pdf</a> instance. </dd></dl>

</div>
</div>
<a id="a8d210727c4d8b6989542eff5fd3f6319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d210727c4d8b6989542eff5fd3f6319">&#9670;&nbsp;</a></span>make_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01905.html">GenericRange</a>&lt;Iterator&gt; hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5314ace45b4baa7084a9addb625ca99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5314ace45b4baa7084a9addb625ca99">&#9670;&nbsp;</a></span>make_splot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02021.html">SPlot</a>&lt;PDF1, PDF2, PDFs...&gt; hydra::make_splot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01961.html">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cd7ac5f41262275e8887b4edcb9357c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd7ac5f41262275e8887b4edcb9357c">&#9670;&nbsp;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple( std::forward&lt;T&gt;(<a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>)...))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The first object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are copies of <code>t</code>. </dd></dl>

</div>
</div>
<a id="aa9c135b2a31b8adc650408759756cd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c135b2a31b8adc650408759756cd30">&#9670;&nbsp;</a></span>minus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a01585.html">Minus</a>&lt;T1,T2&gt; hydra::minus </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a50c2051805f64f02bd175de858ed4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a50c2051805f64f02bd175de858ed4b">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01589.html">Multiply</a>&lt;F1,F2,Fs...&gt; hydra::multiply </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae69f12b645e7126856ef32ba8917fb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69f12b645e7126856ef32ba8917fb71">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T hydra::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a913357a180c5a5e87f79873cabd0ae5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913357a180c5a5e87f79873cabd0ae5d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45a25d4e1e31a1d0d0d44dd7de38a9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a25d4e1e31a1d0d0d44dd7de38a9a2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78094f07d3ecae48d4ee065254f63fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78094f07d3ecae48d4ee065254f63fa">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74f09f60eaa232f756f2e5ee0ccb5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f09f60eaa232f756f2e5ee0ccb5326">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01233">Decays</a>&lt; N1, hydra::detail::BackendPolicy&lt; BACKEND1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01233">Decays</a>&lt; N2, hydra::detail::BackendPolicy&lt; BACKEND2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a258cacce52e3670d4880af1576a16a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258cacce52e3670d4880af1576a16a22">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9653c961d5b4bb192f5af6ec0159dcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9653c961d5b4bb192f5af6ec0159dcef">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a453f3462b38832622a8a719e348d1d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453f3462b38832622a8a719e348d1d26">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae15264ba6f6e6f2329ea89b8c4adf1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15264ba6f6e6f2329ea89b8c4adf1c1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfa9b12786f7b702aaac2486c906a9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa9b12786f7b702aaac2486c906a9e6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb35eb14984b6f9d742e7184f98fb4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb35eb14984b6f9d742e7184f98fb4a8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad56864f196d50c23d6ef4bd0fa5320ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56864f196d50c23d6ef4bd0fa5320ee">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16922c01d5d589efdcafaf9f3c4c852e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16922c01d5d589efdcafaf9f3c4c852e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8059091b90cfa8bfd6a7bbabf84e851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8059091b90cfa8bfd6a7bbabf84e851">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ea48ebde3804da5519a849fd697a9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea48ebde3804da5519a849fd697a9ed">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4041f5a5f507aa261b2e722d8aea605c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4041f5a5f507aa261b2e722d8aea605c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01589.html">Multiply</a>&lt;T1,T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc68502df5d8b6b8f5fba9b1ba7ac2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc68502df5d8b6b8f5fba9b1ba7ac2e9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef450a625d3a4b0d301d4cc516024e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef450a625d3a4b0d301d4cc516024e7e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01589.html">Multiply</a>&lt;<a class="el" href="a01301.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad246bd46bbecdf62fad753ebc2dce9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad246bd46bbecdf62fad753ebc2dce9f6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02e1e189bc887ae3654818288261ad66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e1e189bc887ae3654818288261ad66">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01589.html">Multiply</a>&lt;<a class="el" href="a01301.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af587b7c92737fe70358655f15e30ccc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af587b7c92737fe70358655f15e30ccc7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00640.html#a01949">Parameter</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e396d4f239faf8395afd30c288a2116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e396d4f239faf8395afd30c288a2116">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e7545311b9dadd924decb19aa5c678e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7545311b9dadd924decb19aa5c678e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc2e80d981cfe98af22638389ac78a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2e80d981cfe98af22638389ac78a89">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ee0958a1405d293624a05ff2d16ae60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee0958a1405d293624a05ff2d16ae60">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a9fac87dd53e628338c40ad17db0302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9fac87dd53e628338c40ad17db0302">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb95fa627ccd32ea676dd48ac231177b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb95fa627ccd32ea676dd48ac231177b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79c990f0b58881363c9b28525a379371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c990f0b58881363c9b28525a379371">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac71a6353509fb42628cb8cb677b1e580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71a6353509fb42628cb8cb677b1e580">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01629.html">Sum</a>&lt;T1, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38fefe9fcea2b9c4770e7ee42c98dfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fefe9fcea2b9c4770e7ee42c98dfa7">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01629.html">Sum</a>&lt;<a class="el" href="a01301.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a099a6b58b45d6bcb7a10985101771603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099a6b58b45d6bcb7a10985101771603">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01629.html">Sum</a>&lt;<a class="el" href="a01301.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d67c62da7414fa54685256891397394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d67c62da7414fa54685256891397394">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fb1d38b677c0b1cd04e858dfd2b1743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb1d38b677c0b1cd04e858dfd2b1743">&#9670;&nbsp;</a></span>operator+() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00640.html#a01949">Parameter</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf413cf8a4ae5c7c270bde93e62f9bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf413cf8a4ae5c7c270bde93e62f9bfe">&#9670;&nbsp;</a></span>operator+() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f6293979d93d4a451cd1d1e52bad055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6293979d93d4a451cd1d1e52bad055">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8caa84fd26ffc72a35668dd9f69d4662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8caa84fd26ffc72a35668dd9f69d4662">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae30e88501f8f4eba8c8d36854e24ebc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30e88501f8f4eba8c8d36854e24ebc5">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd8d70910231348dc233cc60f55c07ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8d70910231348dc233cc60f55c07ae">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01585.html">Minus</a>&lt;T1,T2&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af819765e4fd40306b2e7272b0c9ef024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af819765e4fd40306b2e7272b0c9ef024">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44ae849dd2d74a7d93322306d7679750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ae849dd2d74a7d93322306d7679750">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01585.html">Minus</a>&lt;<a class="el" href="a01301.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8308fb1780e1c580a1042dcc09a27d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8308fb1780e1c580a1042dcc09a27d0f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40eae3a2df044ea04cc757344951a45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40eae3a2df044ea04cc757344951a45f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f3c44006ca3b703c77189d746e6323d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3c44006ca3b703c77189d746e6323d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01585.html">Minus</a>&lt;T2,<a class="el" href="a01301.html">Constant</a>&lt;T1&gt; &gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab920ce4c223b458acbce8f3dec8a4a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab920ce4c223b458acbce8f3dec8a4a77">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa13bdd7709888a806c275753d12ea503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13bdd7709888a806c275753d12ea503">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00640.html#a01949">Parameter</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7db0303334ff0446ffaa8d9255a3569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db0303334ff0446ffaa8d9255a3569c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d754bfc3fcc10756af1068b0f9a39cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d754bfc3fcc10756af1068b0f9a39cf">&#9670;&nbsp;</a></span>operator-() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6267811860a8bb98f1a914df2fe8b3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6267811860a8bb98f1a914df2fe8b3f5">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a690716952fb0f6482cad983fa448184b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690716952fb0f6482cad983fa448184b">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0896a1dbd723a3eef55356c69dc692a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0896a1dbd723a3eef55356c69dc692a5">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf636c5faf60ed3d1a5f999262252b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf636c5faf60ed3d1a5f999262252b4f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54dc58e9b41feba5a89a93826fd73c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dc58e9b41feba5a89a93826fd73c22">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01325.html">Divide</a>&lt;T1,T2&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50088fd950900d64d11e9de4bbc0267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50088fd950900d64d11e9de4bbc0267e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5e44113c8c7fad75c3e8322730d0056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e44113c8c7fad75c3e8322730d0056">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01325.html">Divide</a>&lt;<a class="el" href="a01301.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fb214ec121e9fe94216ea14a5969980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb214ec121e9fe94216ea14a5969980">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01325.html">Divide</a>&lt;T2,<a class="el" href="a01301.html">Constant</a>&lt;T1&gt; &gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07bd528ede4b1f7965dde856dc58a4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bd528ede4b1f7965dde856dc58a4a5">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad49b1764415ff5aea1765d20d6bdf294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49b1764415ff5aea1765d20d6bdf294">&#9670;&nbsp;</a></span>operator/() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00640.html#a01949">Parameter</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a> const&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa667417b38750ad07ee2bf114c2daa6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa667417b38750ad07ee2bf114c2daa6c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab08c97f88f33ecdea89c8fb0729aa6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08c97f88f33ecdea89c8fb0729aa6f7">&#9670;&nbsp;</a></span>operator/() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15cdb083719133399edb77f5ef3eb547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cdb083719133399edb77f5ef3eb547">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fab8d226ee701c0755c60202fc30f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fab8d226ee701c0755c60202fc30f6c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d7f13d811f0d63d4ce49d31b6cfbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d7f13d811f0d63d4ce49d31b6cfbe0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa8037907332bf633dfc1bc3b40865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa8037907332bf633dfc1bc3b40865c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaacce78528c9499de97312cbe606ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacce78528c9499de97312cbe606ece4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21d7262b80d73f956ed1a477607b9053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d7262b80d73f956ed1a477607b9053">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , class charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT,traits &gt;&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a067a6647c6343cc50dee7a51fabb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a067a6647c6343cc50dee7a51fabb68">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00640.html#a01949">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac071787192b20e972cf00234b76faea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac071787192b20e972cf00234b76faea9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afec01a9cb1b436bae42e4507e49cb63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec01a9cb1b436bae42e4507e49cb63f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5843159f4dbcbdbdd1d0cc3e48e36757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5843159f4dbcbdbdd1d0cc3e48e36757">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc9da09d22eae43ed970a123baa27f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc9da09d22eae43ed970a123baa27f1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01233">Decays</a>&lt; N1, hydra::detail::BackendPolicy&lt; BACKEND1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01233">Decays</a>&lt; N2, hydra::detail::BackendPolicy&lt; BACKEND2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a0907b93c595507fbd2ea319f2f5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a0907b93c595507fbd2ea319f2f5d6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2bb8fdd61818627ed79ccfcd9d94884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bb8fdd61818627ed79ccfcd9d94884">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, hydra::detail::BackendPolicy&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ad8f84031200c3161c889507d3a9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ad8f84031200c3161c889507d3a9c0">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; charT,traits &gt;&amp; hydra::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d07aff11d25df4ff7d7e38604f015c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d07aff11d25df4ff7d7e38604f015c9">&#9670;&nbsp;</a></span>polar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::polar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad17e6f0c375b2466aa3f5f3cac2bbe7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17e6f0c375b2466aa3f5f3cac2bbe7c">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3ebd81e3e8bf8f08d2c22a944013dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ebd81e3e8bf8f08d2c22a944013dc4">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17fc18905a529d3783d8c127d095c592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fc18905a529d3783d8c127d095c592">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae212a36bc65abcf66392bd49232ec06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae212a36bc65abcf66392bd49232ec06b">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dbfc53307695dddb5ac8b18945e8510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbfc53307695dddb5ac8b18945e8510">&#9670;&nbsp;</a></span>pow() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b268e8ec63688dfa15b64c335dfdb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b268e8ec63688dfa15b64c335dfdb7">&#9670;&nbsp;</a></span>pow() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb0c9817024c69efe44c2d9653928519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0c9817024c69efe44c2d9653928519">&#9670;&nbsp;</a></span>PrintToStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::PrintToStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a951671ac8d7193e176fe3a6ffb75aa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951671ac8d7193e176fe3a6ffb75aa22">&#9670;&nbsp;</a></span>proj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::proj </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68b257293c03a3475bb28e9575e941ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b257293c03a3475bb28e9575e941ad">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2906e8baa707b7e3cbe3ab1c1aa3fa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2906e8baa707b7e3cbe3ab1c1aa3fa7c">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49ac8a38d5cd44fe4f3f940d47e676ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ac8a38d5cd44fe4f3f940d47e676ce">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ffd7cc506e85ce42d0e99eefcf78441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffd7cc506e85ce42d0e99eefcf78441">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53513fea217a83151a1c98692a1bdbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53513fea217a83151a1c98692a1bdbc7">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96fc64d77a9d74b4606c449937491181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fc64d77a9d74b4606c449937491181">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01941">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a875bce64e99a04ae98453f880d98beed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875bce64e99a04ae98453f880d98beed">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae91c3c9f02109abdb77527a81fdcf76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91c3c9f02109abdb77527a81fdcf76c">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00648.html#a01933">multiarray</a>&lt; N, T, detail::BackendPolicy&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="a01981.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab53a2a0ba453b6b2a3372941b6e17fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53a2a0ba453b6b2a3372941b6e17fbc">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02049">Vector4R</a> hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef4412e9c9e2eec0cff2c3518f50109e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4412e9c9e2eec0cff2c3518f50109e">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00642.html#a02045">Vector3R</a> hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00648.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>ksi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc492c9f6771b3d5a0741568c2076fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc492c9f6771b3d5a0741568c2076fe">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace70e751d07c5055a98d10ea4ca7b0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace70e751d07c5055a98d10ea4ca7b0e8">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9c54fb833c00a61ad29f0203620ec27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c54fb833c00a61ad29f0203620ec27">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a02083.html#a2">/home/augalves/Development/Release/Hydra/examples/async/async_mc.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a68439b2b58b78d0c3a9cc5ab9c9d56bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68439b2b58b78d0c3a9cc5ab9c9d56bc">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array streamer helper </p>

</div>
</div>
<a id="a6b2446e6e58a2466b66c1277d67075ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2446e6e58a2466b66c1277d67075ad">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa85435e7d698dd282905782158cb160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa85435e7d698dd282905782158cb160">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tuple streamer helper </p>

</div>
</div>
<a id="af0ba407638beac5920ac997d3021b413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba407638beac5920ac997d3021b413">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cc5a9f732999e9df34308b7bcbf4247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc5a9f732999e9df34308b7bcbf4247">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ <a class="el" href="a01629.html">Sum</a>&lt;F1, F2,Fs...&gt; hydra::sum </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37bf180ccfd77a9a98b930f1a476fde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bf180ccfd77a9a98b930f1a476fde5">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ void hydra::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00642.html#a02045">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08a72473a58a218963306ce701e5ff1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a72473a58a218963306ce701e5ff1c">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ void hydra::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00642.html#a02049">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2e37350fab9720792ac5d23ea047111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e37350fab9720792ac5d23ea047111">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6953c8ef19e2de75badc83057a19896e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6953c8ef19e2de75badc83057a19896e">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00648.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad67692a9e684658ef31189029c802047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67692a9e684658ef31189029c802047">&#9670;&nbsp;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::tie </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::tie(std::forward&lt;T&gt;(<a class="el" href="a00648.html#ae76a4e62b2b1b3cfbc78ccce890374ac">t</a>)...))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The objects to reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are references to <code>t</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab14adaa26f703b8c130df530167ebd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14adaa26f703b8c130df530167ebd23">&#9670;&nbsp;</a></span>kFalse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kFalse = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1556536d7a73fa95e5a9c9610f76a3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1556536d7a73fa95e5a9c9610f76a3c1">&#9670;&nbsp;</a></span>kTrue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00648.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kTrue = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f7accc9ea763820b1cb2152a2473ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7accc9ea763820b1cb2152a2473ac2">&#9670;&nbsp;</a></span>parameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="a00640.html#a01949">Parameter</a>, sizeof...(T)&gt; hydra::parameters { pars...}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5afb8f1b6ea1ba2b8fc79444e5d20f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afb8f1b6ea1ba2b8fc79444e5d20f20">&#9670;&nbsp;</a></span>PrintLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hydra::PrintLevel = <a class="el" href="a00648.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4ce9917997c3883840d3d5292f37860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ce9917997c3883840d3d5292f37860">&#9670;&nbsp;</a></span>r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">traits::return_type hydra::r = typename traits::return_type()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae76a4e62b2b1b3cfbc78ccce890374ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76a4e62b2b1b3cfbc78ccce890374ac">&#9670;&nbsp;</a></span>t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">traits::args_type hydra::t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00648.html">hydra</a></li>
    <li class="footer">Generated on Mon Nov 13 2017 02:21:58 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
