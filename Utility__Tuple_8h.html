<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: Utility_Tuple.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('Utility__Tuple_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utility_Tuple.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="">hydra/detail/Config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/Types.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/utility/Generic.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/TypeTraits.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/FunctorTraits.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/Parameter.h</a>&gt;</code><br />
<code>#include &lt;hydra/detail/external/thrust/tuple.h&gt;</code><br />
<code>#include &lt;hydra/detail/external/thrust/detail/type_traits.h&gt;</code><br />
<code>#include &lt;hydra/detail/external/thrust/iterator/detail/tuple_of_iterator_references.h&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Utility_Tuple.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="Utility__Tuple_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="Utility__Tuple_8h__dep__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CompareTuples.html">hydra::detail::CompareTuples&lt; N, COM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">hydra::detail::is_homogeneous&lt; A, Tuple &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base.html">hydra::detail::is_homogeneous_base&lt; A, Tp, I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base_3_01A_00_01Tp_00_010_01_4.html">hydra::detail::is_homogeneous_base&lt; A, Tp, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1references__tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1references__tuple__type">hydra::detail::references_tuple_type&lt; N, T &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1references__tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4">hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type&lt; N, T &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html">hydra</a></td></tr>
<tr class="memdesc:namespacehydra"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic policies definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html">hydra::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ea1b8b8cc199f447e160aea1396f9e9"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I&gt; </td></tr>
<tr class="memitem:a9ea1b8b8cc199f447e160aea1396f9e9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I==HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9ea1b8b8cc199f447e160aea1396f9e9">hydra::detail::_get_element</a> (const size_t, T &amp;, R *&amp;)</td></tr>
<tr class="separator:a9ea1b8b8cc199f447e160aea1396f9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4514d4ab6052308b21ba01f378e0bdc5"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a4514d4ab6052308b21ba01f378e0bdc5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4514d4ab6052308b21ba01f378e0bdc5">hydra::detail::_get_element</a> (const size_t index, T &amp;t, R *&amp;ptr)</td></tr>
<tr class="separator:a4514d4ab6052308b21ba01f378e0bdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356ee10be86b27828f8b71eb4723fd8f"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a356ee10be86b27828f8b71eb4723fd8f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a356ee10be86b27828f8b71eb4723fd8f">hydra::detail::accumulate</a> (ArgType &amp;x, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a356ee10be86b27828f8b71eb4723fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86df3c6b6fe3b2b5b2a0bf35f5538e24"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a86df3c6b6fe3b2b5b2a0bf35f5538e24"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a86df3c6b6fe3b2b5b2a0bf35f5538e24">hydra::detail::accumulate</a> (ArgType const &amp;x, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a86df3c6b6fe3b2b5b2a0bf35f5538e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7202798eb972c5d3683dc48aa481e1e6"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a7202798eb972c5d3683dc48aa481e1e6"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7202798eb972c5d3683dc48aa481e1e6">hydra::detail::accumulate2</a> (ArgType1 &amp;x, ArgType2 &amp;y, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a7202798eb972c5d3683dc48aa481e1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c18a4f04978272c9323fa33d0b03be"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a48c18a4f04978272c9323fa33d0b03be"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a48c18a4f04978272c9323fa33d0b03be">hydra::detail::accumulate2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a48c18a4f04978272c9323fa33d0b03be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063e551533f8994778522360e11eba07"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a063e551533f8994778522360e11eba07"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a063e551533f8994778522360e11eba07">hydra::detail::add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:a063e551533f8994778522360e11eba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cc0535eaa61a3995028f8a1bc30684"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a24cc0535eaa61a3995028f8a1bc30684"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a24cc0535eaa61a3995028f8a1bc30684">hydra::detail::add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;user_parameters, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a24cc0535eaa61a3995028f8a1bc30684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d63e6634cc0bbd8e30d4045f38e5d"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a579d63e6634cc0bbd8e30d4045f38e5d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I==sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a579d63e6634cc0bbd8e30d4045f38e5d">hydra::detail::add_tuple_values</a> (GReal_t &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="separator:a579d63e6634cc0bbd8e30d4045f38e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338f13caa00838e2c524eb3d4b20fedf"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:a338f13caa00838e2c524eb3d4b20fedf"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a338f13caa00838e2c524eb3d4b20fedf">hydra::detail::add_tuple_values</a> (GReal_t &amp;result, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;tpl)</td></tr>
<tr class="separator:a338f13caa00838e2c524eb3d4b20fedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de2fcc403354268ee8cd0f3d36369d6"><td class="memItemLeft" align="right" valign="top">OtherTypes void ::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2de2fcc403354268ee8cd0f3d36369d6">hydra::detail::assignArrayToTuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a2de2fcc403354268ee8cd0f3d36369d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade860710c76fecbba43b0f56bf39a29a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:ade860710c76fecbba43b0f56bf39a29a"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ade860710c76fecbba43b0f56bf39a29a">hydra::detail::assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:ade860710c76fecbba43b0f56bf39a29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304f632a689f2da94f0adec802c2c24c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a304f632a689f2da94f0adec802c2c24c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a304f632a689f2da94f0adec802c2c24c">hydra::detail::assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a304f632a689f2da94f0adec802c2c24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e880a2f7b75282f1b1e46b2c3749d0f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a1e880a2f7b75282f1b1e46b2c3749d0f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1e880a2f7b75282f1b1e46b2c3749d0f">hydra::detail::assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a1e880a2f7b75282f1b1e46b2c3749d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f84a5781e447b6b5aa848a436af1b96"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a1f84a5781e447b6b5aa848a436af1b96"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1f84a5781e447b6b5aa848a436af1b96">hydra::detail::assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a1f84a5781e447b6b5aa848a436af1b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ef566daf99fc14b95ceeb35c69c284"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a33ef566daf99fc14b95ceeb35c69c284"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a33ef566daf99fc14b95ceeb35c69c284">hydra::detail::assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a33ef566daf99fc14b95ceeb35c69c284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bc8fc9dd6bd74339e020f9ac32eb39"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a47bc8fc9dd6bd74339e020f9ac32eb39"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a47bc8fc9dd6bd74339e020f9ac32eb39">hydra::detail::assignTupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a47bc8fc9dd6bd74339e020f9ac32eb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f81e341b211140f449dda2fd42890f3"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5f81e341b211140f449dda2fd42890f3"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5f81e341b211140f449dda2fd42890f3">hydra::detail::eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a>, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, FuncT const &amp;)</td></tr>
<tr class="separator:a5f81e341b211140f449dda2fd42890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8735530d4a1fbdaf571d195f62c7b098"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:a8735530d4a1fbdaf571d195f62c7b098"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8735530d4a1fbdaf571d195f62c7b098">hydra::detail::eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, FuncT const &amp;f)</td></tr>
<tr class="separator:a8735530d4a1fbdaf571d195f62c7b098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ea2c9cff400282415093123e68bf5f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:af2ea2c9cff400282415093123e68bf5f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af2ea2c9cff400282415093123e68bf5f">hydra::detail::eval_tuple_element</a> (Return_Type &amp;, <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:af2ea2c9cff400282415093123e68bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055ed6d4ace68ec83b0f05abe635c338"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a055ed6d4ace68ec83b0f05abe635c338"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a055ed6d4ace68ec83b0f05abe635c338">hydra::detail::eval_tuple_element</a> (Return_Type &amp;r, <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:a055ed6d4ace68ec83b0f05abe635c338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Tuple &gt; </td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a96a946dad2a4b9f834836d9b954ad8b6">hydra::detail::extract</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> idx, const Tuple &amp;t)</td></tr>
<tr class="separator:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a2d7a14d0022028fba61ddf02a207c"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ... T&gt; </td></tr>
<tr class="memitem:a14a2d7a14d0022028fba61ddf02a207c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ R &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a14a2d7a14d0022028fba61ddf02a207c">hydra::detail::get_element</a> (const size_t index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a14a2d7a14d0022028fba61ddf02a207c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6983a19fe9f9e2d985b801cbea16b0"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5a6983a19fe9f9e2d985b801cbea16b0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5a6983a19fe9f9e2d985b801cbea16b0">hydra::detail::get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a5a6983a19fe9f9e2d985b801cbea16b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d0b80a94e55172ec18dff3dfcf7176"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a02d0b80a94e55172ec18dff3dfcf7176"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02d0b80a94e55172ec18dff3dfcf7176">hydra::detail::get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, T &amp;x)</td></tr>
<tr class="separator:a02d0b80a94e55172ec18dff3dfcf7176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a227e0b524804a0ceef56b4a1da1953d4">hydra::detail::get_zip_iterator</a> (std::array&lt; Iterator, N &gt;const &amp;array_of_iterators) -&gt; decltype(get_zip_iterator_helper(array_of_iterators, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a227e0b524804a0ceef56b4a1da1953d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae9da0535b5305aaf5cfe698c42ebc8d6">hydra::detail::get_zip_iterator</a> (IteratorHead head, std::array&lt; IteratorTail, N &gt;const &amp;array_of_iterators) -&gt; decltype(get_zip_iterator_helper(head, array_of_iterators, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97931692365b3a0511b8cce8c4c2510"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t ... Index&gt; </td></tr>
<tr class="memitem:ae97931692365b3a0511b8cce8c4c2510"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae97931692365b3a0511b8cce8c4c2510">hydra::detail::get_zip_iterator_helper</a> (std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;array_of_iterators, index_sequence&lt; Index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_zip_iterator(HYDRA_EXTERNAL_NS::thrust::make_tuple(array_of_iterators[Index]...)))</td></tr>
<tr class="separator:ae97931692365b3a0511b8cce8c4c2510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382e7e9b98c32dec47168237f889f0af"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </td></tr>
<tr class="memitem:a382e7e9b98c32dec47168237f889f0af"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a382e7e9b98c32dec47168237f889f0af">hydra::detail::get_zip_iterator_helper</a> (IteratorHead head, std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;array_of_iterators, index_sequence&lt; Index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_zip_iterator(HYDRA_EXTERNAL_NS::thrust::make_tuple(head, array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a382e7e9b98c32dec47168237f889f0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b94bf95ea506b05197dbb497cf97d8"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:ac2b94bf95ea506b05197dbb497cf97d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac2b94bf95ea506b05197dbb497cf97d8">hydra::detail::invoke</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:ac2b94bf95ea506b05197dbb497cf97d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaca93c22dd2ed068aa89fbf8ff3b678"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:aaaca93c22dd2ed068aa89fbf8ff3b678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aaaca93c22dd2ed068aa89fbf8ff3b678">hydra::detail::invoke</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, tup, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:aaaca93c22dd2ed068aa89fbf8ff3b678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadb98e1ab2655b60e31f95f1fd4ce1b"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:acadb98e1ab2655b60e31f95f1fd4ce1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acadb98e1ab2655b60e31f95f1fd4ce1b">hydra::detail::invoke</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:acadb98e1ab2655b60e31f95f1fd4ce1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fe39a5d0a4394580f0bbf09bbf05fa"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a47fe39a5d0a4394580f0bbf09bbf05fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a47fe39a5d0a4394580f0bbf09bbf05fa">hydra::detail::invoke</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, y, tup, make_index_sequence&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a47fe39a5d0a4394580f0bbf09bbf05fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b40e8f707d09db5f0316163e818156e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a2b40e8f707d09db5f0316163e818156e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2b40e8f707d09db5f0316163e818156e">hydra::detail::invoke_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a2b40e8f707d09db5f0316163e818156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150db1fa61de62253b5581bcf2901452"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a150db1fa61de62253b5581bcf2901452"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a150db1fa61de62253b5581bcf2901452">hydra::detail::invoke_helper</a> (ArgType const &amp;x, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a150db1fa61de62253b5581bcf2901452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5380f8ef24226d0fdfa988d670efd14c"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:a5380f8ef24226d0fdfa988d670efd14c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5380f8ef24226d0fdfa988d670efd14c">hydra::detail::invoke_helper</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y))...))</td></tr>
<tr class="separator:a5380f8ef24226d0fdfa988d670efd14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87094195c5cf716ddd42bf599d0cc71"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:ac87094195c5cf716ddd42bf599d0cc71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac87094195c5cf716ddd42bf599d0cc71">hydra::detail::invoke_helper</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(tup)(x, y)...))</td></tr>
<tr class="separator:ac87094195c5cf716ddd42bf599d0cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9360a30d9cffc4d39b34187a56f0bb92">hydra::detail::invoke_helper</a> (x, y, tup, make_index_sequence&lt; Size &gt; { })</td></tr>
<tr class="separator:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1111a8172c75b5f252be5adc38828af0"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType &gt; </td></tr>
<tr class="memitem:a1111a8172c75b5f252be5adc38828af0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1111a8172c75b5f252be5adc38828af0">hydra::detail::invoke_normalized</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, tup, make_index_sequence&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a1111a8172c75b5f252be5adc38828af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d54980b3fd3e5fb960701ec95c9bf17"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;typename HYDRA_EXTERNAL_NS::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:a9d54980b3fd3e5fb960701ec95c9bf17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d54980b3fd3e5fb960701ec95c9bf17">hydra::detail::invoke_normalized</a> (ArgType &amp;&amp;x, Tup const &amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a9d54980b3fd3e5fb960701ec95c9bf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e09107d2672f4d56c179b193082906"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a71e09107d2672f4d56c179b193082906"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a71e09107d2672f4d56c179b193082906">hydra::detail::invoke_normalized_helper</a> (ArgType const &amp;x, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a71e09107d2672f4d56c179b193082906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173eb394103a0e94fbf9abbc1918a894"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a173eb394103a0e94fbf9abbc1918a894">hydra::detail::invoke_normalized_helper</a> (x, tup, make_index_sequence&lt; Size &gt; { })</td></tr>
<tr class="separator:a173eb394103a0e94fbf9abbc1918a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d93d2ab06e98530b6e09554baff41a"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a80d93d2ab06e98530b6e09554baff41a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#a0916cfff5efbb734ef0bc4dc20ffa31a">__hydra_exec_check_disable__</a> __hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a80d93d2ab06e98530b6e09554baff41a">hydra::detail::invoke_normalized_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(HYDRA_EXTERNAL_NS::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a80d93d2ab06e98530b6e09554baff41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c762e6869221cc4c1f83e0e0eecf76e"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a9c762e6869221cc4c1f83e0e0eecf76e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9c762e6869221cc4c1f83e0e0eecf76e">hydra::detail::make_rtuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t) -&gt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:a9c762e6869221cc4c1f83e0e0eecf76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6155319b5f6821c59294fd4904f8881a"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I&gt; </td></tr>
<tr class="memitem:a6155319b5f6821c59294fd4904f8881a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6155319b5f6821c59294fd4904f8881a">hydra::detail::make_rtuple_helper</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t, index_sequence&lt; I... &gt;) -&gt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:a6155319b5f6821c59294fd4904f8881a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccf298d7fa30a13efd0d4d848248222"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a2ccf298d7fa30a13efd0d4d848248222"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2ccf298d7fa30a13efd0d4d848248222">hydra::detail::multiply_array_tuple</a> (GReal_t(&amp;fCoeficients)[sizeof...(T)], HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;tpl) -&gt; decltype(multiply_array_tuple_helper(fCoeficients, tpl, make_index_sequence&lt; sizeof...(T)&gt;</td></tr>
<tr class="separator:a2ccf298d7fa30a13efd0d4d848248222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a9cfc48d39212a6856ce4a6458280"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , size_t ... I&gt; </td></tr>
<tr class="memitem:a643a9cfc48d39212a6856ce4a6458280"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ tuple_type&lt; sizeof...(I), GReal_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a643a9cfc48d39212a6856ce4a6458280">hydra::detail::multiply_array_tuple_helper</a> (GReal_t(&amp;fCoeficients)[sizeof...(I)], Tuple const &amp;tpl, index_sequence&lt; I... &gt;)</td></tr>
<tr class="separator:a643a9cfc48d39212a6856ce4a6458280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d6569d3430295c91bb45ca5a1a0ab"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a2c6d6569d3430295c91bb45ca5a1a0ab"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2c6d6569d3430295c91bb45ca5a1a0ab">hydra::detail::multiply_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;)</td></tr>
<tr class="separator:a2c6d6569d3430295c91bb45ca5a1a0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef40c2dd3f84192e6dba30c7a065808"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:abef40c2dd3f84192e6dba30c7a065808"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abef40c2dd3f84192e6dba30c7a065808">hydra::detail::multiply_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;t)</td></tr>
<tr class="separator:abef40c2dd3f84192e6dba30c7a065808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307118c3cdbf74e7c7a9382b76727b5f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a307118c3cdbf74e7c7a9382b76727b5f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a307118c3cdbf74e7c7a9382b76727b5f">hydra::detail::multiply_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;)</td></tr>
<tr class="separator:a307118c3cdbf74e7c7a9382b76727b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02223b7d9b237863aa694751f86067c2"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a02223b7d9b237863aa694751f86067c2"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02223b7d9b237863aa694751f86067c2">hydra::detail::multiply_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a02223b7d9b237863aa694751f86067c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff67efcc02bd52b3de9a5f3a142f9547"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:aff67efcc02bd52b3de9a5f3a142f9547"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aff67efcc02bd52b3de9a5f3a142f9547">hydra::detail::print_parameters_in_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:aff67efcc02bd52b3de9a5f3a142f9547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30711a263078d73843b26cdc802cdb3f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a30711a263078d73843b26cdc802cdb3f"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a30711a263078d73843b26cdc802cdb3f">hydra::detail::print_parameters_in_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a30711a263078d73843b26cdc802cdb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbb591af6fb8f27221cb826ec5cf743"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:acfbb591af6fb8f27221cb826ec5cf743"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acfbb591af6fb8f27221cb826ec5cf743">hydra::detail::product</a> (ArgType const &amp;x, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:acfbb591af6fb8f27221cb826ec5cf743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac332ab75d99d58297479b2abd51a6aa9"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ac332ab75d99d58297479b2abd51a6aa9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac332ab75d99d58297479b2abd51a6aa9">hydra::detail::product</a> (ArgType &amp;x, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ac332ab75d99d58297479b2abd51a6aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00868a4a0a332adf5621d4516e9aee36"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a00868a4a0a332adf5621d4516e9aee36"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a00868a4a0a332adf5621d4516e9aee36">hydra::detail::product2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a00868a4a0a332adf5621d4516e9aee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac617b7fba01a202565c65f9e8e6e2faf"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ac617b7fba01a202565c65f9e8e6e2faf"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac617b7fba01a202565c65f9e8e6e2faf">hydra::detail::product2</a> (ArgType1 &amp;x, ArgType2 &amp;y, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ac617b7fba01a202565c65f9e8e6e2faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf7fdd753b13871dc75f4bac1ce205c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a8bf7fdd753b13871dc75f4bac1ce205c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8bf7fdd753b13871dc75f4bac1ce205c">hydra::detail::product_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a8bf7fdd753b13871dc75f4bac1ce205c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f1effc46b8b39cf2725fd4eeb119bb"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:ad8f1effc46b8b39cf2725fd4eeb119bb"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad8f1effc46b8b39cf2725fd4eeb119bb">hydra::detail::product_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:ad8f1effc46b8b39cf2725fd4eeb119bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3939b105248efa44d81293b0d626bb49"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3939b105248efa44d81293b0d626bb49"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3939b105248efa44d81293b0d626bb49">hydra::detail::product_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:a3939b105248efa44d81293b0d626bb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ecd0ff858976f61e4cb99e844ae1df"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a33ecd0ff858976f61e4cb99e844ae1df"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a33ecd0ff858976f61e4cb99e844ae1df">hydra::detail::product_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;arg)</td></tr>
<tr class="separator:a33ecd0ff858976f61e4cb99e844ae1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb35ba072cba0508cceedd65ad28a058"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:acb35ba072cba0508cceedd65ad28a058"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acb35ba072cba0508cceedd65ad28a058">hydra::detail::product_tuple2</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:acb35ba072cba0508cceedd65ad28a058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac719625de76a2d30f5349c7b3b256559"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:ac719625de76a2d30f5349c7b3b256559"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac719625de76a2d30f5349c7b3b256559">hydra::detail::product_tuple2</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:ac719625de76a2d30f5349c7b3b256559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef10b1dbcdecce1e1653b819236810b"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a2ef10b1dbcdecce1e1653b819236810b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2ef10b1dbcdecce1e1653b819236810b">hydra::detail::product_tuple2</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a2ef10b1dbcdecce1e1653b819236810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745d0ee8999ce4a0ad9673151e42816c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a745d0ee8999ce4a0ad9673151e42816c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a745d0ee8999ce4a0ad9673151e42816c">hydra::detail::product_tuple2</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a745d0ee8999ce4a0ad9673151e42816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34392ddaffc23de2780ae0749a03208"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab34392ddaffc23de2780ae0749a03208"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab34392ddaffc23de2780ae0749a03208">hydra::detail::product_tuple3</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:ab34392ddaffc23de2780ae0749a03208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab65052d499d9f865047111cdea23ee"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a2ab65052d499d9f865047111cdea23ee"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2ab65052d499d9f865047111cdea23ee">hydra::detail::product_tuple3</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:a2ab65052d499d9f865047111cdea23ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f4e39dc40a329a6057ffb730917ab"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab80f4e39dc40a329a6057ffb730917ab"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab80f4e39dc40a329a6057ffb730917ab">hydra::detail::product_tuple3</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:ab80f4e39dc40a329a6057ffb730917ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98912ab33ddf035d25186f41b328518"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:af98912ab33ddf035d25186f41b328518"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af98912ab33ddf035d25186f41b328518">hydra::detail::product_tuple3</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:af98912ab33ddf035d25186f41b328518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c089b0ed387eb4afd66bc273159b83"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad7c089b0ed387eb4afd66bc273159b83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad7c089b0ed387eb4afd66bc273159b83">hydra::detail::ptr_setter</a> (T1 *&amp;ptr, typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; HYDRA_EXTERNAL_NS::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *el)</td></tr>
<tr class="separator:ad7c089b0ed387eb4afd66bc273159b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae973390d66b56d0371b6bc77f489ced4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae973390d66b56d0371b6bc77f489ced4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae973390d66b56d0371b6bc77f489ced4">hydra::detail::ptr_setter</a> (T1 *&amp;, typename HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;!HYDRA_EXTERNAL_NS::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *)</td></tr>
<tr class="separator:ae973390d66b56d0371b6bc77f489ced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e518ba4ea2d09339231ca9b58d3af1b"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a3e518ba4ea2d09339231ca9b58d3af1b"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3e518ba4ea2d09339231ca9b58d3af1b">hydra::detail::set_functors_in_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;)</td></tr>
<tr class="separator:a3e518ba4ea2d09339231ca9b58d3af1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762905616f6f7eaecdef5d116e9c9032"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a762905616f6f7eaecdef5d116e9c9032"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a762905616f6f7eaecdef5d116e9c9032">hydra::detail::set_functors_in_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:a762905616f6f7eaecdef5d116e9c9032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c190a56fcea0dae4ffb6ac42e9ebf4"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:a65c190a56fcea0dae4ffb6ac42e9ebf4"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a65c190a56fcea0dae4ffb6ac42e9ebf4">hydra::detail::set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, std::tuple&lt; Tp... &gt; &amp;, Ptr *&amp;)</td></tr>
<tr class="separator:a65c190a56fcea0dae4ffb6ac42e9ebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9154bbb7529e3dd6e3d5e9920101867"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:ae9154bbb7529e3dd6e3d5e9920101867"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae9154bbb7529e3dd6e3d5e9920101867">hydra::detail::set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, std::tuple&lt; Tp... &gt; &amp;t, Ptr *&amp;ptr)</td></tr>
<tr class="separator:ae9154bbb7529e3dd6e3d5e9920101867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182f9fd9358a9c673cab53a0dd7ee62c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:a182f9fd9358a9c673cab53a0dd7ee62c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I==HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;::value) &amp;&amp;is_homogeneous&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a182f9fd9358a9c673cab53a0dd7ee62c">hydra::detail::set_ptrs_to_tuple</a> (T &amp;, Array_Type **)</td></tr>
<tr class="separator:a182f9fd9358a9c673cab53a0dd7ee62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e9e052ec5ff4f303bc14644aa2077a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:ab8e9e052ec5ff4f303bc14644aa2077a"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;::value) &amp;&amp;is_homogeneous&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab8e9e052ec5ff4f303bc14644aa2077a">hydra::detail::set_ptrs_to_tuple</a> (T &amp;t, Array_Type **Array)</td></tr>
<tr class="separator:ab8e9e052ec5ff4f303bc14644aa2077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce3012fbd53a2b5da267b8728a9d8a9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a9ce3012fbd53a2b5da267b8728a9d8a9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9ce3012fbd53a2b5da267b8728a9d8a9">hydra::detail::set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a9ce3012fbd53a2b5da267b8728a9d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1d4819c5159a38d63346d9f2f3212c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a2d1d4819c5159a38d63346d9f2f3212c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2d1d4819c5159a38d63346d9f2f3212c">hydra::detail::set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;t, const T &amp;x)</td></tr>
<tr class="separator:a2d1d4819c5159a38d63346d9f2f3212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26f750aee2b4a44078dec88b62be49b"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2&gt; </td></tr>
<tr class="memitem:ae26f750aee2b4a44078dec88b62be49b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae26f750aee2b4a44078dec88b62be49b">hydra::detail::split_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1... &gt; &amp;t1, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T2... &gt; &amp;t2, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1..., T2... &gt; const &amp;t)</td></tr>
<tr class="separator:ae26f750aee2b4a44078dec88b62be49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d5385e5dadaf062d323e7d891b617d"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename ... T&gt; </td></tr>
<tr class="memitem:a05d5385e5dadaf062d323e7d891b617d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a05d5385e5dadaf062d323e7d891b617d">hydra::detail::split_tuple</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t) -&gt; decltype(split_tuple_helper(t, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a05d5385e5dadaf062d323e7d891b617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef3d0c17270ab8b76059d11e90ac2e2"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:afef3d0c17270ab8b76059d11e90ac2e2"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afef3d0c17270ab8b76059d11e90ac2e2">hydra::detail::split_tuple_helper</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1... &gt; &amp;t1, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T2... &gt; &amp;t2, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T1..., T2... &gt; const &amp;t, index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt;)</td></tr>
<tr class="separator:afef3d0c17270ab8b76059d11e90ac2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d06336a86ab7a875909eaccec8fafd"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:a63d06336a86ab7a875909eaccec8fafd"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a63d06336a86ab7a875909eaccec8fafd">hydra::detail::split_tuple_helper</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t, index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt;) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_pair(HYDRA_EXTERNAL_NS::thrust::tie(HYDRA_EXTERNAL_NS::thrust::get&lt; I1 &gt;(t)...), HYDRA_EXTERNAL_NS::thrust::tie(HYDRA_EXTERNAL_NS::thrust::get&lt; I2++sizeof...(I1)&gt;(t)...)))</td></tr>
<tr class="separator:a63d06336a86ab7a875909eaccec8fafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf971ae71a711b13306a58d79c0bc854"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:acf971ae71a711b13306a58d79c0bc854"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acf971ae71a711b13306a58d79c0bc854">hydra::detail::sum_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:acf971ae71a711b13306a58d79c0bc854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3635135537b34ed7b9b690c046caba3e"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3635135537b34ed7b9b690c046caba3e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3635135537b34ed7b9b690c046caba3e">hydra::detail::sum_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;arg)</td></tr>
<tr class="separator:a3635135537b34ed7b9b690c046caba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd1ab802c1cf0813124fa1a2084064"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a02dd1ab802c1cf0813124fa1a2084064"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02dd1ab802c1cf0813124fa1a2084064">hydra::detail::sum_tuple</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a02dd1ab802c1cf0813124fa1a2084064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7809fae326d609265168b9218c81afad"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a7809fae326d609265168b9218c81afad"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7809fae326d609265168b9218c81afad">hydra::detail::sum_tuple</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:a7809fae326d609265168b9218c81afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a768cdf608f16f197f2f28465f4c5"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a672a768cdf608f16f197f2f28465f4c5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a672a768cdf608f16f197f2f28465f4c5">hydra::detail::sum_tuple2</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a672a768cdf608f16f197f2f28465f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef0b917781becc3f2a075581dc5f4c5"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:adef0b917781becc3f2a075581dc5f4c5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#adef0b917781becc3f2a075581dc5f4c5">hydra::detail::sum_tuple2</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:adef0b917781becc3f2a075581dc5f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40defb7c8c498e5e08f8d3c638cd9246"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a40defb7c8c498e5e08f8d3c638cd9246"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a40defb7c8c498e5e08f8d3c638cd9246">hydra::detail::sum_tuple2</a> (Return_Type &amp;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt;const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a40defb7c8c498e5e08f8d3c638cd9246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000714f04bcbbe987d1d6571d572d5c4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a000714f04bcbbe987d1d6571d572d5c4"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a000714f04bcbbe987d1d6571d572d5c4">hydra::detail::sum_tuple2</a> (Return_Type &amp;r, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:a000714f04bcbbe987d1d6571d572d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace544073fe8587547403cd411de880a9"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:ace544073fe8587547403cd411de880a9"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ace544073fe8587547403cd411de880a9">hydra::detail::tupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;)</td></tr>
<tr class="separator:ace544073fe8587547403cd411de880a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3336cd369617ffa6dc20218a0ba53a4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:af3336cd369617ffa6dc20218a0ba53a4"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af3336cd369617ffa6dc20218a0ba53a4">hydra::detail::tupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:af3336cd369617ffa6dc20218a0ba53a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc89e34e642e54d06e05eecd35e6586"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a9fc89e34e642e54d06e05eecd35e6586"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9fc89e34e642e54d06e05eecd35e6586">hydra::detail::tupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, typename std::remove_reference&lt; FistType &gt;::type *)</td></tr>
<tr class="separator:a9fc89e34e642e54d06e05eecd35e6586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99132bf945fc5a95c270e53644d7ca60"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a99132bf945fc5a95c270e53644d7ca60"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a99132bf945fc5a95c270e53644d7ca60">hydra::detail::tupleToArray</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, typename std::remove_reference&lt; FistType &gt;::type *Array)</td></tr>
<tr class="separator:a99132bf945fc5a95c270e53644d7ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6e5ce23b23364c64166f4c390f0f5f03">hydra::detail::make_index_sequence&lt; sizeof...(T) -N &gt;</a></td></tr>
<tr class="separator:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structhydra_1_1detail_1_1references__tuple__type" id="structhydra_1_1detail_1_1references__tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1references__tuple__type">&#9670;&nbsp;</a></span>hydra::detail::references_tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::references_tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::references_tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::references_tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1references__tuple__type__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a359cfd315141fd3d5bd521ab97ea56ec"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, tuple_of_iterator_references &gt;::<a class="el" href="namespacehydra_1_1detail.html#a359cfd315141fd3d5bd521ab97ea56ec">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type" id="structhydra_1_1detail_1_1tuple__cat__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Tuple1, typename Tuple2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type__coll__graph.svg" width="200" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename ... &gt;class Tuple, typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; Tuple&lt; T1... &gt;, Tuple&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01Tuple_3_01T1_8_8_8_01_4_00_01Tuple_3_01T2_8_8_8_01_4_01_4__coll__graph.svg" width="174" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8a6f9bf15607fb5fb21b31448d616c0e"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__type" id="structhydra_1_1detail_1_1tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__type__coll__graph.svg" width="140" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a94810d8d67c44ca227f9c4a1e456b1d6"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, <a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b">tuple</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a94810d8d67c44ca227f9c4a1e456b1d6">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_92a1ff494355b06c14c0e1fe7b982d29.html">Hydra</a></li><li class="navelem"><a class="el" href="dir_108162cc96056bf8ace3602d16680a1c.html">hydra</a></li><li class="navelem"><a class="el" href="dir_3834ae61da54c887219d23c23fa56bea.html">detail</a></li><li class="navelem"><a class="el" href="dir_50b81e2dbdc2d397ec548125a86506fb.html">utility</a></li><li class="navelem"><a class="el" href="Utility__Tuple_8h.html">Utility_Tuple.h</a></li>
    <li class="footer">Generated on Fri Mar 23 2018 12:08:58 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
