<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">2.2.1</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacehydra.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hydra Namespace Reference<div class="ingroups"><a class="el" href="group__policy.html">Policy</a> &#124; <a class="el" href="group__common__functions.html">Common functors</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic policies definition.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra_1_1cpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1device"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1host"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1host.html">host</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1math__constants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1math__constants.html">math_constants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1placeholders"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1tbb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1tbb.html">tbb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structhydra_1_1__half"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a></td></tr>
<tr class="separator:structhydra_1_1__half"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1__unit"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1__unit">_unit</a></td></tr>
<tr class="separator:structhydra_1_1__unit"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1AnalyticalIntegral.html">AnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1AnalyticalIntegral_3_01Functor_00_011_01_4.html">AnalyticalIntegral&lt; Functor, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ArgusShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ArgusShape">ArgusShape</a></td></tr>
<tr class="memdesc:classhydra_1_1ArgusShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation describing the ARGUS background shape.  <a href="group__common__functions.html#classhydra_1_1ArgusShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ArgusShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BaseCompositeFunctor.html">BaseCompositeFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BaseFunctor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functor.html#classhydra_1_1BaseFunctor">BaseFunctor</a></td></tr>
<tr class="memdesc:classhydra_1_1BaseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all functors in hydra.  <a href="group__functor.html#classhydra_1_1BaseFunctor">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1BaseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BifurcatedGaussian"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1BifurcatedGaussian">BifurcatedGaussian</a></td></tr>
<tr class="separator:classhydra_1_1BifurcatedGaussian"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BreitWignerLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1BreitWignerLineShape">BreitWignerLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1BreitWignerLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breit-Wigner line shape for 3 body resonant decays \( A -&gt; r c , r-&gt; a b\) , where A is a "long-lived" particle and \( a, b\) and \(c\) are the final states.  <a href="group__common__functions.html#classhydra_1_1BreitWignerLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1BreitWignerLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BreitWignerNR.html">BreitWignerNR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Cache"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Cache">Cache</a></td></tr>
<tr class="separator:classhydra_1_1Cache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Cache_3_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01Functors_8_8_8_01_4.html">Cache&lt; hydra::detail::BackendPolicy&lt; BACKEND &gt;, Functors... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Chains"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Chains">Chains</a></td></tr>
<tr class="separator:classhydra_1_1Chains"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4">Chains&lt; Decays&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;... &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides memory storage for a chain of decays.  <a href="group__phsp.html#classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Chebychev"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Chebychev">Chebychev</a></td></tr>
<tr class="memdesc:classhydra_1_1Chebychev"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Chebyshev polynomials \( T_n \) (first kind) are polynomials with the largest possible leading coefficient, but subject to the condition that their absolute value on the interval [−1,1] is bounded by 1.  <a href="group__common__functions.html#classhydra_1_1Chebychev">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Chebychev"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ChiSquare"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ChiSquare">ChiSquare</a></td></tr>
<tr class="memdesc:classhydra_1_1ChiSquare"><td class="mdescLeft">&#160;</td><td class="mdescRight">The chi-squared distribution (also chi-square or \( \chi^2 \) -distribution) with \( k \) degrees of freedom is the distribution of a sum of the squares of k independent standard normal random variables.  <a href="group__common__functions.html#classhydra_1_1ChiSquare">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ChiSquare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Compose.html">Compose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Convolution.html">Convolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CosHelicityAngle.html">CosHelicityAngle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CrystalBallShape.html">CrystalBallShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation the Crystal Ball line shape.  <a href="classhydra_1_1CrystalBallShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CubicSpiline.html">CubicSpiline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 A simple method for a one—dimensional interpolation on a given set of data points (xi, yi).  <a href="classhydra_1_1CubicSpiline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Decays"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a></td></tr>
<tr class="separator:classhydra_1_1Decays"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">Decays&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides storage for N-particle final states.  <a href="group__phsp.html#classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DeltaDMassBackground"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1DeltaDMassBackground">DeltaDMassBackground</a></td></tr>
<tr class="separator:classhydra_1_1DeltaDMassBackground"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775">DenseHistogram&lt; T, 1, hydra::detail::BackendPolicy&lt; BACKEND &gt;, detail::unidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing one-dimensional dense histogram.  <a href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">DenseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, detail::multidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing multidimensional dense histograms.  <a href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Divide.html">Divide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Exponential"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Exponential">Exponential</a></td></tr>
<tr class="memdesc:classhydra_1_1Exponential"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.wikipedia.org/wiki/Exponential_function">https://en.wikipedia.org/wiki/Exponential_function</a>  <a href="group__common__functions.html#classhydra_1_1Exponential">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Exponential"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a></td></tr>
<tr class="memdesc:classhydra_1_1FCN"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__fit.html#classhydra_1_1FCN" title="FCN base class. ">FCN</a> base class.  <a href="group__fit.html#classhydra_1_1FCN">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1FCN"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_01_4_01_4.html">FCN&lt; Estimator&lt; PDF, Iterator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_01_4">FCN&lt; Estimator&lt; PDF, Iterator, Iterators... &gt; &gt;</a></td></tr>
<tr class="separator:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Gaussian"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Gaussian">Gaussian</a></td></tr>
<tr class="memdesc:classhydra_1_1Gaussian"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 <a class="el" href="group__common__functions.html#classhydra_1_1Gaussian" title="   Gaussian functions are often used to represent the probability density function of a normally dist...">Gaussian</a> functions are often used to represent the probability density function of a normally distributed random variable with expected value \( \mu \) and variance \( \sigma \).  <a href="group__common__functions.html#classhydra_1_1Gaussian">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Gaussian"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussianKDE"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1GaussianKDE">GaussianKDE</a></td></tr>
<tr class="separator:classhydra_1_1GaussianKDE"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussKronrodAdaptiveQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GaussKronrodAdaptiveQuadrature">GaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GaussKronrodAdaptiveQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussKronrodAdaptiveQuadrature_3_01NRULE_00_01NBIN_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodBinary.html">GaussKronrodBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodCall.html">GaussKronrodCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussKronrodQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GaussKronrodQuadrature">GaussKronrodQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GaussKronrodQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussKronrodQuadrature_3_01NRULE_00_01NBIN_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">GaussKronrodQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRule"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRule">GaussKronrodRule</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRule">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1GaussKronrodRuleSelector">GaussKronrodRuleSelector</a></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4">GaussKronrodRuleSelector&lt; 15 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4">GaussKronrodRuleSelector&lt; 21 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4">GaussKronrodRuleSelector&lt; 31 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4">GaussKronrodRuleSelector&lt; 41 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4">GaussKronrodRuleSelector&lt; 51 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4">GaussKronrodRuleSelector&lt; 61 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodUnary.html">GaussKronrodUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenzMalikQuadrature">GenzMalikQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GenzMalikQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">GenzMalikQuadrature&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-adaptive Genz-Malik multidimensional quadrature.  <a href="group__numerical__integration.html#classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikRule"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenzMalikRule">GenzMalikRule</a></td></tr>
<tr class="separator:classhydra_1_1GenzMalikRule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">GenzMalikRule&lt; DIM, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing Genz-Malik rule.  <a href="group__numerical__integration.html#classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GenzMalikRuleBase.html">GenzMalikRuleBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Integral.html">Integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Integral_3_01Algorithm_00_011_01_4.html">Integral&lt; Algorithm, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula.html">IntegrationFormula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01ArgusShape_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; ArgusShape&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01BifurcatedGaussian_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; BifurcatedGaussian&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01BreitWignerNR_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; BreitWignerNR&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Chebychev_3_01Order_00_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; Chebychev&lt; Order, ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgIndex_01_4_00_011_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgIndex_01_4_00_011_01_4">IntegrationFormula&lt; ChiSquare&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgIndex_01_4_00_011_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01CrystalBallShape_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; CrystalBallShape&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01DeltaDMassBackground_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; DeltaDMassBackground&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Exponential_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; Exponential&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Gaussian_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; Gaussian&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Ipatia_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; Ipatia&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01JohnsonSUShape_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; JohnsonSUShape&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01LogNormal_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; LogNormal&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Polynomial_3_01Order_00_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; Polynomial&lt; Order, ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01TrapezoidalShape_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; TrapezoidalShape&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01TriangularShape_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; TriangularShape&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01UniformShape_3_01ArgIndex_01_4_00_011_01_4.html">IntegrationFormula&lt; UniformShape&lt; ArgIndex &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Ipatia"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Ipatia">Ipatia</a></td></tr>
<tr class="memdesc:classhydra_1_1Ipatia"><td class="mdescLeft">&#160;</td><td class="mdescRight">version of the <a class="el" href="group__common__functions.html#classhydra_1_1Ipatia" title="version of the Ipatia distribution as described in the reference https://doi.org/10.1016/j.nima.2014.06.081. ">Ipatia</a> distribution as described in the reference <a href="https://doi.org/10.1016/j.nima.2014.06.081">https://doi.org/10.1016/j.nima.2014.06.081</a>.  <a href="group__common__functions.html#classhydra_1_1Ipatia">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Ipatia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1JohnsonSUShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1JohnsonSUShape">JohnsonSUShape</a></td></tr>
<tr class="memdesc:classhydra_1_1JohnsonSUShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation the JohnsonSU line shape.  <a href="group__common__functions.html#classhydra_1_1JohnsonSUShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1JohnsonSUShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LambdaWrapper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1LambdaWrapper">LambdaWrapper</a></td></tr>
<tr class="separator:classhydra_1_1LambdaWrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functor.html#classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4">LambdaWrapper&lt; ReturnType(ArgType...), L, N &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for lambda functions.  <a href="group__functor.html#classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">LogLikelihoodFCN&lt; Pdf&lt; Functor, Integrator &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogLikehood object for not composed models represented by <a class="el" href="group__fit.html#classhydra_1_1Pdf" title="Class representing probability density functions. ">hydra::Pdf</a> objects.  <a href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">LogLikelihoodFCN&lt; PDFSumExtendable&lt; Pdfs... &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogLikehood object for composed models represented by hydra::PDFSumExtendable&lt;Pdfs...&gt; objects.  <a href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">LogLikelihoodFCN&lt; PDFSumNonExtendable&lt; Pdfs... &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogLikehood object for composed models represented by hydra::PDFSumNonExtendable&lt;Pdfs...&gt; objects.  <a href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogNormal"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1LogNormal">LogNormal</a></td></tr>
<tr class="memdesc:classhydra_1_1LogNormal"><td class="mdescLeft">&#160;</td><td class="mdescRight">In probability theory, a log-normal (or lognormal) distribution is a continuous probability distribution of a random variable whose logarithm is normally distributed.  <a href="group__common__functions.html#classhydra_1_1LogNormal">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogNormal"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1M12PhaseSpaceLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1M12PhaseSpaceLineShape">M12PhaseSpaceLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1M12PhaseSpaceLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body phase-space distribution for \( m_{12}\): </p><p class="formulaDsp">
\[ \frac{dN}{dm_{m_12}} \propto q.p \]
</p>
<p>.  <a href="group__common__functions.html#classhydra_1_1M12PhaseSpaceLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1M12PhaseSpaceLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1M12SqPhaseSpaceLineShape">M12SqPhaseSpaceLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body phase-space distribution for \( m_{12}^2\): </p><p class="formulaDsp">
\[ \frac{dN}{dm^2_{12}} \propto q.p/m^2_{12} \]
</p>
<p>.  <a href="group__common__functions.html#classhydra_1_1M12SqPhaseSpaceLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Minus.html">Minus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1multiarray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a></td></tr>
<tr class="separator:classhydra_1_1multiarray"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multiarray_3_01T_00_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">multiarray&lt; T, N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Multiply.html">Multiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1multivector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a></td></tr>
<tr class="separator:classhydra_1_1multivector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html">multivector&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements storage in SoA layouts for table where all elements have the same type.  <a href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1null__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1null__type">null_type</a></td></tr>
<tr class="separator:structhydra_1_1null__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1NumericalIntegral.html">NumericalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Parameter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a></td></tr>
<tr class="memdesc:structhydra_1_1Parameter"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
,  <a href="group__fit.html#structhydra_1_1Parameter">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1Parameter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Pdf"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a></td></tr>
<tr class="memdesc:classhydra_1_1Pdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing probability density functions.  <a href="group__fit.html#classhydra_1_1Pdf">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Pdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PDFSumExtendable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a></td></tr>
<tr class="memdesc:classhydra_1_1PDFSumExtendable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pdf object built summing up other pdfs.  <a href="group__fit.html#classhydra_1_1PDFSumExtendable">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PDFSumExtendable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PDFSumNonExtendable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a></td></tr>
<tr class="memdesc:classhydra_1_1PDFSumNonExtendable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pdf object built summing a pdf adding other pdfs.  <a href="group__fit.html#classhydra_1_1PDFSumNonExtendable">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PDFSumNonExtendable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpace"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpace">PhaseSpace</a></td></tr>
<tr class="memdesc:classhydra_1_1PhaseSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements phase-space Monte Carlo generation in hydra.  <a href="group__phsp.html#classhydra_1_1PhaseSpace">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PhaseSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpaceIntegrator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpaceIntegrator">PhaseSpaceIntegrator</a></td></tr>
<tr class="separator:classhydra_1_1PhaseSpaceIntegrator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">PhaseSpaceIntegrator&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="separator:classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Plain"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a></td></tr>
<tr class="separator:structhydra_1_1Plain"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">Plain&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a> MC numerical integration algorithm in Hydra.  <a href="group__numerical__integration.html#classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1PlainState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1PlainState">PlainState</a></td></tr>
<tr class="memdesc:structhydra_1_1PlainState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple structure to hold the results of the <a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a> MC numerical integration.  <a href="group__numerical__integration.html#structhydra_1_1PlainState">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1PlainState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PlanesDeltaAngle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1PlanesDeltaAngle">PlanesDeltaAngle</a></td></tr>
<tr class="memdesc:classhydra_1_1PlanesDeltaAngle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor calculates the delta angle between decay plane of the particle with four-vector d2 and d3 (same plane) and h1 (other plane)  <a href="group__common__functions.html#classhydra_1_1PlanesDeltaAngle">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PlanesDeltaAngle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Polynomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Polynomial">Polynomial</a></td></tr>
<tr class="memdesc:classhydra_1_1Polynomial"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 From : <a href="https://en.wikipedia.org/wiki/Polynomial">https://en.wikipedia.org/wiki/Polynomial</a>  <a href="group__common__functions.html#classhydra_1_1Polynomial">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Polynomial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Print.html">Print</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1ProcessGaussKronrodAdaptiveQuadrature.html">ProcessGaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Random"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#classhydra_1_1Random">Random</a></td></tr>
<tr class="memdesc:classhydra_1_1Random"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements functionalities associated to random number generation and pdf sampling.  <a href="group__random.html#classhydra_1_1Random">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Random"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Range"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a></td></tr>
<tr class="separator:classhydra_1_1Range"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Range_3_01Iterator_01_4.html">Range&lt; Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Range_3_01Iterator_00_01Functor_01_4.html">Range&lt; Iterator, Functor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4">SparseHistogram&lt; T, 1, detail::BackendPolicy&lt; BACKEND &gt;, detail::unidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing one-dimensional sparse histogram.  <a href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">SparseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, detail::multidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing multidimensional sparse histogram.  <a href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1SPlot.html">SPlot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Sum.html">Sum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ThreeBodyMassThresholdBackground"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ThreeBodyMassThresholdBackground">ThreeBodyMassThresholdBackground</a></td></tr>
<tr class="separator:classhydra_1_1ThreeBodyMassThresholdBackground"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1TrapezoidalShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1TrapezoidalShape">TrapezoidalShape</a></td></tr>
<tr class="memdesc:classhydra_1_1TrapezoidalShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">In probability theory and statistics, the trapezoidal distribution is a continuous probability distribution the graph of whose probability density function resembles a trapezoid.  <a href="group__common__functions.html#classhydra_1_1TrapezoidalShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1TrapezoidalShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1TrapezoidalShapeAnalyticalIntegral.html">TrapezoidalShapeAnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1TriangularShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1TriangularShape">TriangularShape</a></td></tr>
<tr class="memdesc:classhydra_1_1TriangularShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">From: <a href="https://en.wikipedia.org/wiki/Triangular_distribution">https://en.wikipedia.org/wiki/Triangular_distribution</a>.  <a href="group__common__functions.html#classhydra_1_1TriangularShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1TriangularShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1UniformShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1UniformShape">UniformShape</a></td></tr>
<tr class="memdesc:classhydra_1_1UniformShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">From: <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)</a>  <a href="group__common__functions.html#classhydra_1_1UniformShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1UniformShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1UserParameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a></td></tr>
<tr class="memdesc:classhydra_1_1UserParameters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a interface to ROOT::Minuit2::MnUserParameters.  <a href="group__fit.html#classhydra_1_1UserParameters">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1UserParameters"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vector3R"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a></td></tr>
<tr class="memdesc:classhydra_1_1Vector3R"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents three-dimensional Euclidian vectors and implements common operation performed on it.  <a href="group__phsp.html#classhydra_1_1Vector3R">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Vector3R"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vector4R"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a></td></tr>
<tr class="memdesc:classhydra_1_1Vector4R"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents four-dimensional relativistic vectors and implements common operation performed on it.  <a href="group__phsp.html#classhydra_1_1Vector4R">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Vector4R"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vegas"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Vegas">Vegas</a></td></tr>
<tr class="separator:classhydra_1_1Vegas"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">Vegas&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to perform numerical integration using <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">Vegas</a> algorithm.  <a href="group__numerical__integration.html#classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1VegasState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1VegasState">VegasState</a></td></tr>
<tr class="memdesc:classhydra_1_1VegasState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">hydra::Vegas</a> integration algorithm.  <a href="group__numerical__integration.html#classhydra_1_1VegasState">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1VegasState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">VegasState&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">hydra::Vegas</a> integration algorithm.  <a href="group__numerical__integration.html#classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Weights"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Weights">Weights</a></td></tr>
<tr class="memdesc:classhydra_1_1Weights"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIXME : add filler methods...  <a href="namespacehydra.html#classhydra_1_1Weights">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Weights"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Weights_3_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">Weights&lt; hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1WignerD"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1WignerD">WignerD</a></td></tr>
<tr class="separator:classhydra_1_1WignerD"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1WignerD_3_01T_3_01J_01_4_00_01T_3_01M_01_4_00_01T_3_01N_01_4_00_01ArgIndex_01_4.html">WignerD&lt; T&lt; J &gt;, T&lt; M &gt;, T&lt; N &gt;, ArgIndex &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1WignerDMatrix"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1WignerDMatrix">WignerDMatrix</a></td></tr>
<tr class="memdesc:classhydra_1_1WignerDMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the beta-term </p><p class="formulaDsp">
\[ d^j_{mn}(beta) \]
</p>
<p> in the matrix element of the finite rotation operator (Wigner's D-function), according to formula 4.3.4(eq.  <a href="group__common__functions.html#classhydra_1_1WignerDMatrix">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1WignerDMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ZemachFunction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ZemachFunction">ZemachFunction</a></td></tr>
<tr class="memdesc:classhydra_1_1ZemachFunction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zemach's angular probability distribution for 3-body decays of spinless particle into spinless final states as a function of \(\theta\), the helicity angle:  <a href="group__common__functions.html#classhydra_1_1ZemachFunction">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ZemachFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">BoolVector_d</a></td></tr>
<tr class="memdesc:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="group__phsp.html#classhydra_1_1Vector4R" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector.  <a href="#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">More...</a><br /></td></tr>
<tr class="separator:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b1c32d255fc13e78a08e96de133f0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a274b1c32d255fc13e78a08e96de133f0">BoolVector_h</a></td></tr>
<tr class="memdesc:a274b1c32d255fc13e78a08e96de133f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__phsp.html#classhydra_1_1Vector3R" title="This class represents three-dimensional Euclidian vectors and implements common operation performed o...">Vector3R</a> host vector.  <a href="#a274b1c32d255fc13e78a08e96de133f0">More...</a><br /></td></tr>
<tr class="separator:a274b1c32d255fc13e78a08e96de133f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a> = HYDRA_EXTERNAL_NS::thrust::complex&lt; T &gt;</td></tr>
<tr class="separator:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7670b2993eb064d9c192d9200ab82b89"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7670b2993eb064d9c192d9200ab82b89">ComplexVector_d</a></td></tr>
<tr class="memdesc:a7670b2993eb064d9c192d9200ab82b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GReal_t device vector.  <a href="#a7670b2993eb064d9c192d9200ab82b89">More...</a><br /></td></tr>
<tr class="separator:a7670b2993eb064d9c192d9200ab82b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30019aaf18d88f73acd61f2f363f9f6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af30019aaf18d88f73acd61f2f363f9f6">ComplexVector_h</a></td></tr>
<tr class="memdesc:af30019aaf18d88f73acd61f2f363f9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GReal_t host vector.  <a href="#af30019aaf18d88f73acd61f2f363f9f6">More...</a><br /></td></tr>
<tr class="separator:af30019aaf18d88f73acd61f2f363f9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e747e9ec41024e3efe0349f8ac10062"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1e747e9ec41024e3efe0349f8ac10062">default_random_engine</a></td></tr>
<tr class="memdesc:a1e747e9ec41024e3efe0349f8ac10062"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation-defined "default" random number engine.  <a href="#a1e747e9ec41024e3efe0349f8ac10062">More...</a><br /></td></tr>
<tr class="separator:a1e747e9ec41024e3efe0349f8ac10062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2d81895ace081c5204b9adc76a2808"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ada2d81895ace081c5204b9adc76a2808">FourVectors_h</a></td></tr>
<tr class="memdesc:ada2d81895ace081c5204b9adc76a2808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for complex number.  <a href="#ada2d81895ace081c5204b9adc76a2808">More...</a><br /></td></tr>
<tr class="separator:ada2d81895ace081c5204b9adc76a2808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c251ed5017d0638da929130062bcad"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a></td></tr>
<tr class="memdesc:aa8c251ed5017d0638da929130062bcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean (0=false, 1=true) (bool)  <a href="#aa8c251ed5017d0638da929130062bcad">More...</a><br /></td></tr>
<tr class="separator:aa8c251ed5017d0638da929130062bcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2da2ab0037e6bca3cb7c15adc5c4125">GByte_t</a></td></tr>
<tr class="memdesc:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte (8 bits) (unsigned char)  <a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">More...</a><br /></td></tr>
<tr class="separator:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab04a199389c4989174dc115507fa89"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7ab04a199389c4989174dc115507fa89">GChar_t</a></td></tr>
<tr class="memdesc:a7ab04a199389c4989174dc115507fa89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Character 1 byte (char)  <a href="#a7ab04a199389c4989174dc115507fa89">More...</a><br /></td></tr>
<tr class="separator:a7ab04a199389c4989174dc115507fa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab78a78009fd9969bce04250387d13e"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::complex&lt; <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a></td></tr>
<tr class="separator:a7ab78a78009fd9969bce04250387d13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986267d40d932c5cbf0ae874a506f83"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af986267d40d932c5cbf0ae874a506f83">GDouble_t</a></td></tr>
<tr class="memdesc:af986267d40d932c5cbf0ae874a506f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 8 bytes.  <a href="#af986267d40d932c5cbf0ae874a506f83">More...</a><br /></td></tr>
<tr class="separator:af986267d40d932c5cbf0ae874a506f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bab7b854d7b3c3042fe47201b765eb"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a71bab7b854d7b3c3042fe47201b765eb">GFloat_t</a></td></tr>
<tr class="memdesc:a71bab7b854d7b3c3042fe47201b765eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float 4 bytes (float)  <a href="#a71bab7b854d7b3c3042fe47201b765eb">More...</a><br /></td></tr>
<tr class="separator:a71bab7b854d7b3c3042fe47201b765eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0c9fb4d7195ab952da10a82d5c4ad30e">GInt_t</a></td></tr>
<tr class="memdesc:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer 4 bytes (int)  <a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">More...</a><br /></td></tr>
<tr class="separator:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memItemLeft" align="right" valign="top">typedef long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9d68c21fb715bbfb1edc5b1933b173e9">GLong64_t</a></td></tr>
<tr class="memdesc:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable signed long integer 8 bytes.  <a href="#a9d68c21fb715bbfb1edc5b1933b173e9">More...</a><br /></td></tr>
<tr class="separator:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5f57a4025b40929c2708cd544c3a1ccd">GLong_t</a></td></tr>
<tr class="memdesc:a5f57a4025b40929c2708cd544c3a1ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed long integer 4 bytes (long)  <a href="#a5f57a4025b40929c2708cd544c3a1ccd">More...</a><br /></td></tr>
<tr class="separator:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751abe69b482cde879c718fd4775733f"><td class="memItemLeft" align="right" valign="top">typedef long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a751abe69b482cde879c718fd4775733f">GLongDouble_t</a></td></tr>
<tr class="memdesc:a751abe69b482cde879c718fd4775733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Long Double.  <a href="#a751abe69b482cde879c718fd4775733f">More...</a><br /></td></tr>
<tr class="separator:a751abe69b482cde879c718fd4775733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td></tr>
<tr class="memdesc:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 16 bytes or float 4 bytes.  <a href="#a971e94bcb8c43741d11f9d8eb98f5fab">More...</a><br /></td></tr>
<tr class="separator:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589c60d92ba893c28d814edd6e149a9c"><td class="memItemLeft" align="right" valign="top">typedef short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a589c60d92ba893c28d814edd6e149a9c">GShort_t</a></td></tr>
<tr class="memdesc:a589c60d92ba893c28d814edd6e149a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Short integer 2 bytes (short)  <a href="#a589c60d92ba893c28d814edd6e149a9c">More...</a><br /></td></tr>
<tr class="separator:a589c60d92ba893c28d814edd6e149a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc842c1ec8321e9637dee714dcdaebff"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abc842c1ec8321e9637dee714dcdaebff">GText_t</a></td></tr>
<tr class="memdesc:abc842c1ec8321e9637dee714dcdaebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">General string (char)  <a href="#abc842c1ec8321e9637dee714dcdaebff">More...</a><br /></td></tr>
<tr class="separator:abc842c1ec8321e9637dee714dcdaebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef97faee95aa79f3839eb7abdf5238"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a51ef97faee95aa79f3839eb7abdf5238">GUChar_t</a></td></tr>
<tr class="memdesc:a51ef97faee95aa79f3839eb7abdf5238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Character 1 byte (unsigned char)  <a href="#a51ef97faee95aa79f3839eb7abdf5238">More...</a><br /></td></tr>
<tr class="separator:a51ef97faee95aa79f3839eb7abdf5238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a7b1f515ac1ed9409afd67252a32b"><td class="memItemLeft" align="right" valign="top">typedef unsigned <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a251a7b1f515ac1ed9409afd67252a32b">GUInt_t</a></td></tr>
<tr class="memdesc:a251a7b1f515ac1ed9409afd67252a32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer 4 bytes (unsigned int)  <a href="#a251a7b1f515ac1ed9409afd67252a32b">More...</a><br /></td></tr>
<tr class="separator:a251a7b1f515ac1ed9409afd67252a32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e8443cd746900da90cb1f77807e7c0"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a55e8443cd746900da90cb1f77807e7c0">GULong64_t</a></td></tr>
<tr class="memdesc:a55e8443cd746900da90cb1f77807e7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable unsigned long integer 8 bytes.  <a href="#a55e8443cd746900da90cb1f77807e7c0">More...</a><br /></td></tr>
<tr class="separator:a55e8443cd746900da90cb1f77807e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a0d54fd4ed46052939549edd086c5"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abf9a0d54fd4ed46052939549edd086c5">GULong_t</a></td></tr>
<tr class="separator:abf9a0d54fd4ed46052939549edd086c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911a3042526fac189d0c87a089f52955"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a911a3042526fac189d0c87a089f52955">GUShort_t</a></td></tr>
<tr class="memdesc:a911a3042526fac189d0c87a089f52955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Short integer 2 bytes (unsigned short)  <a href="#a911a3042526fac189d0c87a089f52955">More...</a><br /></td></tr>
<tr class="separator:a911a3042526fac189d0c87a089f52955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648839818fa9d4a58c2195a55a51e773"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a648839818fa9d4a58c2195a55a51e773"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a> = HYDRA_EXTERNAL_NS::thrust::device_vector&lt; T &gt;</td></tr>
<tr class="memdesc:a648839818fa9d4a58c2195a55a51e773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector.  <a href="#a648839818fa9d4a58c2195a55a51e773">More...</a><br /></td></tr>
<tr class="separator:a648839818fa9d4a58c2195a55a51e773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de6f086a44380382022dafca75de4c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6de6f086a44380382022dafca75de4c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a> = HYDRA_EXTERNAL_NS::thrust::host_vector&lt; T, HYDRA_EXTERNAL_NS::thrust::system::cuda::experimental::pinned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a6de6f086a44380382022dafca75de4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector.  <a href="#a6de6f086a44380382022dafca75de4c9">More...</a><br /></td></tr>
<tr class="separator:a6de6f086a44380382022dafca75de4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccdd58e3a4c27246dadd0930e3fb569"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::minstd_rand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeccdd58e3a4c27246dadd0930e3fb569">minstd_rand</a></td></tr>
<tr class="memdesc:aeccdd58e3a4c27246dadd0930e3fb569"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm.  <a href="#aeccdd58e3a4c27246dadd0930e3fb569">More...</a><br /></td></tr>
<tr class="separator:aeccdd58e3a4c27246dadd0930e3fb569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::minstd_rand0&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab7c3603cf7a6c467176d8be9dd2c82fd">minstd_rand0</a></td></tr>
<tr class="memdesc:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm.  <a href="#ab7c3603cf7a6c467176d8be9dd2c82fd">More...</a><br /></td></tr>
<tr class="separator:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acf5241d6a56b2040e9cc9ea860b4cbff">pair</a> = HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt;</td></tr>
<tr class="memdesc:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pair</code> template is an alias to the HYDRA_EXTERNAL_NS::thrust::pair structure.  <a href="#acf5241d6a56b2040e9cc9ea860b4cbff">More...</a><br /></td></tr>
<tr class="separator:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34184a169c185689e065d0c30f9ffba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae34184a169c185689e065d0c30f9ffba">Particles_d</a></td></tr>
<tr class="memdesc:ae34184a169c185689e065d0c30f9ffba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GComplex_t device vector.  <a href="#ae34184a169c185689e065d0c30f9ffba">More...</a><br /></td></tr>
<tr class="separator:ae34184a169c185689e065d0c30f9ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9df2f3d6dc63cf297b0f74ba228f6c89">Particles_h</a></td></tr>
<tr class="memdesc:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GComplex_t host vector.  <a href="#a9df2f3d6dc63cf297b0f74ba228f6c89">More...</a><br /></td></tr>
<tr class="separator:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::ranlux24&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a943a0571fdadbbb4bc9b17ba7ae4b59b">ranlux24</a></td></tr>
<tr class="memdesc:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements the RANLUX level-3 random number generation algorithm.  <a href="#a943a0571fdadbbb4bc9b17ba7ae4b59b">More...</a><br /></td></tr>
<tr class="separator:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6950c5abef4e2015f833501684940b5d"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::ranlux48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6950c5abef4e2015f833501684940b5d">ranlux48</a></td></tr>
<tr class="memdesc:a6950c5abef4e2015f833501684940b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements the RANLUX level-4 random number generation algorithm.  <a href="#a6950c5abef4e2015f833501684940b5d">More...</a><br /></td></tr>
<tr class="separator:a6950c5abef4e2015f833501684940b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fd090c6e39cfcdd744f369dacffabe"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a79fd090c6e39cfcdd744f369dacffabe">RealVector_d</a></td></tr>
<tr class="memdesc:a79fd090c6e39cfcdd744f369dacffabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GBool_t device vector.  <a href="#a79fd090c6e39cfcdd744f369dacffabe">More...</a><br /></td></tr>
<tr class="separator:a79fd090c6e39cfcdd744f369dacffabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d21da5996b50a240e6f400025e3b139"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6d21da5996b50a240e6f400025e3b139">RealVector_h</a></td></tr>
<tr class="memdesc:a6d21da5996b50a240e6f400025e3b139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GBool_t host vector.  <a href="#a6d21da5996b50a240e6f400025e3b139">More...</a><br /></td></tr>
<tr class="separator:a6d21da5996b50a240e6f400025e3b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2633cfe1492c02cfb2aef6a79804f191"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::taus88&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2633cfe1492c02cfb2aef6a79804f191">taus88</a></td></tr>
<tr class="memdesc:a2633cfe1492c02cfb2aef6a79804f191"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements L'Ecuyer's 1996 three-component Tausworthe random number generator.  <a href="#a2633cfe1492c02cfb2aef6a79804f191">More...</a><br /></td></tr>
<tr class="separator:a2633cfe1492c02cfb2aef6a79804f191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcdb1155222988a4250114d880e8b46"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7dcdb1155222988a4250114d880e8b46">ThreeVectors_h</a></td></tr>
<tr class="memdesc:a7dcdb1155222988a4250114d880e8b46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector.  <a href="#a7dcdb1155222988a4250114d880e8b46">More...</a><br /></td></tr>
<tr class="separator:a7dcdb1155222988a4250114d880e8b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e59cc0127adfac6b799c5fd6785431b"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a5e59cc0127adfac6b799c5fd6785431b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b">tuple</a> = HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;</td></tr>
<tr class="memdesc:a5e59cc0127adfac6b799c5fd6785431b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>tuple</code> template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can be instantiated with a indefinite number of arguments.  <a href="#a5e59cc0127adfac6b799c5fd6785431b">More...</a><br /></td></tr>
<tr class="separator:a5e59cc0127adfac6b799c5fd6785431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecb38ba9198aee2de36f374d07638de"><td class="memTemplParams" colspan="2">template&lt;int N, class T &gt; </td></tr>
<tr class="memitem:a3ecb38ba9198aee2de36f374d07638de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3ecb38ba9198aee2de36f374d07638de">tuple_element</a> = HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, T &gt;</td></tr>
<tr class="memdesc:a3ecb38ba9198aee2de36f374d07638de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest.  <a href="#a3ecb38ba9198aee2de36f374d07638de">More...</a><br /></td></tr>
<tr class="separator:a3ecb38ba9198aee2de36f374d07638de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab06a4451f99b94119ead1dcadf2b8e31">tuple_size</a> = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;</td></tr>
<tr class="memdesc:ab06a4451f99b94119ead1dcadf2b8e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This metafunction returns the number of elements of a <code>tuple</code> type of interest.  <a href="#ab06a4451f99b94119ead1dcadf2b8e31">More...</a><br /></td></tr>
<tr class="separator:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aed873b1b84fbec3791e721b22a52d1fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1fea4517ec382985cb7a39393c0da09e58d5">INFO</a> =0, 
<a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a> =1, 
<a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1feadbc96f88184ea3a51f68df95e2b44851">ERROR</a> =2
 }</td></tr>
<tr class="separator:aed873b1b84fbec3791e721b22a52d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1107488f838687e73b39ddd8245f40d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0aae772e8b4c5ada0e1e4c65495702176a">MODE_IMPORTANCE</a> = 1, 
<a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0a28550661921a3af1306fa74a26b8569c">MODE_IMPORTANCE_ONLY</a> = 0, 
<a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0acb2c0124fecbf6c1182f1cf7cd9bc37a">MODE_STRATIFIED</a> = -1, 
<a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0aba2629d0445cc7ef401fd6793f047da0">BINS_MAX</a> = 50
 }</td></tr>
<tr class="separator:a1107488f838687e73b39ddd8245f40d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#ga0dc858c0fb14ade1e8abc19cdd0959e2">Wave</a> { <br />
&#160;&#160;<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd">SWave</a> =0, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45">PWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3">DWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1">FWave</a>, 
<br />
&#160;&#160;<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032">GWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426">HWave</a>
<br />
 }</td></tr>
<tr class="memdesc:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orbital angular momentum tags.  <a href="group__common__functions.html#ga0dc858c0fb14ade1e8abc19cdd0959e2">More...</a><br /></td></tr>
<tr class="separator:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5e095cca28f6bec603156fd48914aefe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e095cca28f6bec603156fd48914aefe"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5e095cca28f6bec603156fd48914aefe">abs</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5e095cca28f6bec603156fd48914aefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256097a85b1ce0eafa6e497f46d87383"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a256097a85b1ce0eafa6e497f46d87383"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a256097a85b1ce0eafa6e497f46d87383">acos</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a256097a85b1ce0eafa6e497f46d87383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec91f5ec5ff214023b38f72ec4ac1e76">acosh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5917e6644c8742bd0d3586066ee5de0"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:gad5917e6644c8742bd0d3586066ee5de0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gad5917e6644c8742bd0d3586066ee5de0">add_pdfs</a> (std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(PDFs)+1 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:gad5917e6644c8742bd0d3586066ee5de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build up non-extendable pdfs models.  <a href="group__fit.html#gad5917e6644c8742bd0d3586066ee5de0">More...</a><br /></td></tr>
<tr class="separator:gad5917e6644c8742bd0d3586066ee5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7e7cc3bb04eac1d1350bb41b254fc92b">add_pdfs</a> (std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(PDFs)+2 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build up extendable pdfs models.  <a href="group__fit.html#ga7e7cc3bb04eac1d1350bb41b254fc92b">More...</a><br /></td></tr>
<tr class="separator:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74342b65e8d5baef11d2518da6fae223"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a74342b65e8d5baef11d2518da6fae223"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74342b65e8d5baef11d2518da6fae223">apply_filter</a> (Iterable &amp;&amp;container, Functor const  &amp;filter)</td></tr>
<tr class="memdesc:a74342b65e8d5baef11d2518da6fae223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a filter to the range [first, last] and return a pair of iterators for the filtered events.  <a href="#a74342b65e8d5baef11d2518da6fae223">More...</a><br /></td></tr>
<tr class="separator:a74342b65e8d5baef11d2518da6fae223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96191cbaa62c58f63b7e58924362c24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae96191cbaa62c58f63b7e58924362c24"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ae96191cbaa62c58f63b7e58924362c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9a7e65b9bb4aca1f24356f2d43f91bda">asin</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd779382ac3242158686664a9a3ca3a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd779382ac3242158686664a9a3ca3a0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abd779382ac3242158686664a9a3ca3a0">asinh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:abd779382ac3242158686664a9a3ca3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9772b7e92ecdf60524cde428c1670bd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9772b7e92ecdf60524cde428c1670bd4"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9772b7e92ecdf60524cde428c1670bd4">atan</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a9772b7e92ecdf60524cde428c1670bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b7bc13880335fdf6964df5034ade29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24b7bc13880335fdf6964df5034ade29"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24b7bc13880335fdf6964df5034ade29">atanh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a24b7bc13880335fdf6964df5034ade29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd995d684b15024c891571fe47518404"><td class="memTemplParams" colspan="2">template&lt;hydra::Wave L&gt; </td></tr>
<tr class="memitem:gacd995d684b15024c891571fe47518404"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">BarrierFactor</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> d, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="memdesc:gacd995d684b15024c891571fe47518404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blatt-Weisskopf B' functions.  <a href="group__common__functions.html#gacd995d684b15024c891571fe47518404">More...</a><br /></td></tr>
<tr class="separator:gacd995d684b15024c891571fe47518404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a03f4e98f986e55037e1a01fe4d9b8fc8">BarrierFactor&lt; hydra::DWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a1e302e48427c947ab2084811df1df"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac5a1e302e48427c947ab2084811df1df"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac5a1e302e48427c947ab2084811df1df">BarrierFactor&lt; hydra::FWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ac5a1e302e48427c947ab2084811df1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac0e0a9c294368d8d5b74fb919e261bef">BarrierFactor&lt; hydra::GWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223d417259cf7e660fd89a54438d45b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae223d417259cf7e660fd89a54438d45b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae223d417259cf7e660fd89a54438d45b">BarrierFactor&lt; hydra::HWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ae223d417259cf7e660fd89a54438d45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78649879f76b3b52249830df2482980"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa78649879f76b3b52249830df2482980"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa78649879f76b3b52249830df2482980">BarrierFactor&lt; hydra::PWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:aa78649879f76b3b52249830df2482980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab59597f876fc220d388f5911bb9822c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aab59597f876fc220d388f5911bb9822c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aab59597f876fc220d388f5911bb9822c">BarrierFactor&lt; hydra::SWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>)</td></tr>
<tr class="separator:aab59597f876fc220d388f5911bb9822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d562f964ef193664077363da8859e2"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:ab9d562f964ef193664077363da8859e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a> (const C &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="separator:ab9d562f964ef193664077363da8859e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7e149bee61e4ddabca7fa0aafa121fe1">begin</a> (C &amp;&amp;c) -&gt; decltype(std::forward&lt; C &gt;(c).begin())</td></tr>
<tr class="separator:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c64031cbdf1765fdf74577297ddb758"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a6c64031cbdf1765fdf74577297ddb758"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6c64031cbdf1765fdf74577297ddb758">begin</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a6c64031cbdf1765fdf74577297ddb758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f46840c85ee014f1d237601913ae1"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:afd4f46840c85ee014f1d237601913ae1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd4f46840c85ee014f1d237601913ae1">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:afd4f46840c85ee014f1d237601913ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6483cec578e17112f07ba012a4dc50ed"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6483cec578e17112f07ba012a4dc50ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6483cec578e17112f07ba012a4dc50ed">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a6483cec578e17112f07ba012a4dc50ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8c272359dca5fb49f5a76d4cf93451"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:afe8c272359dca5fb49f5a76d4cf93451"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afe8c272359dca5fb49f5a76d4cf93451">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:afe8c272359dca5fb49f5a76d4cf93451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4f1cb0e2e3473d8e25b079dd72b8bc8a">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca77c714b3e8b913c37d323cfd5640"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a39ca77c714b3e8b913c37d323cfd5640">boostTo</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;rs, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;p4, <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> inverse=false)</td></tr>
<tr class="separator:a39ca77c714b3e8b913c37d323cfd5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1de9e4fabdb747b9e3352ef6298476"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c1de9e4fabdb747b9e3352ef6298476">boostTo</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;rs, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;boost, <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> inverse=false)</td></tr>
<tr class="separator:a1c1de9e4fabdb747b9e3352ef6298476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19bb84d35c2b4edaea63abe6c1298ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae19bb84d35c2b4edaea63abe6c1298ef"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae19bb84d35c2b4edaea63abe6c1298ef">chebychev_1st_kind</a> (unsigned n, const T x)</td></tr>
<tr class="memdesc:ae19bb84d35c2b4edaea63abe6c1298ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of first kind \( P_n(n) \) using the recursive relation.  <a href="#ae19bb84d35c2b4edaea63abe6c1298ef">More...</a><br /></td></tr>
<tr class="separator:ae19bb84d35c2b4edaea63abe6c1298ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d6c3636b0ee33dcebe0f10bb9d7d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a610d6c3636b0ee33dcebe0f10bb9d7d1"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a610d6c3636b0ee33dcebe0f10bb9d7d1">chebychev_2nd_kind</a> (unsigned n, const T x)</td></tr>
<tr class="memdesc:a610d6c3636b0ee33dcebe0f10bb9d7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of second kind \( P_n(n) \) using the recursive relation.  <a href="#a610d6c3636b0ee33dcebe0f10bb9d7d1">More...</a><br /></td></tr>
<tr class="separator:a610d6c3636b0ee33dcebe0f10bb9d7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e8cd28634fb5e58ded42387beb6703"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ad7e8cd28634fb5e58ded42387beb6703"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ std::enable_if&lt; N==0, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad7e8cd28634fb5e58ded42387beb6703">Chebyshev_polynomial</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>)</td></tr>
<tr class="separator:ad7e8cd28634fb5e58ded42387beb6703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb49a5479f420438ed05226f53aba61"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:aabb49a5479f420438ed05226f53aba61"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ std::enable_if&lt; N==1, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aabb49a5479f420438ed05226f53aba61">Chebyshev_polynomial</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:aabb49a5479f420438ed05226f53aba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2e51621fdfc76eb1b18fb93060eab4"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:aba2e51621fdfc76eb1b18fb93060eab4"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ std::enable_if&lt;(N &gt;2), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aba2e51621fdfc76eb1b18fb93060eab4">Chebyshev_polynomial</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:aba2e51621fdfc76eb1b18fb93060eab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014b131fb12345722ffb14274f76b8e6"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Index , typename Iterable_Values &gt; </td></tr>
<tr class="memitem:a014b131fb12345722ffb14274f76b8e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a014b131fb12345722ffb14274f76b8e6">collect</a> (Iterable_Index &amp;indexing_scheme, Iterable_Values &amp;collected_values) -&gt; typename std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Index &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Values &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::permutation_iterator&lt; decltype(std::declval&lt; Iterable_Values &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterable_Index &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type</td></tr>
<tr class="separator:a014b131fb12345722ffb14274f76b8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </td></tr>
<tr class="memitem:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec19ef09aa95bbdb2230bd31d879b94d">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac897e7fcbfbb068d5d29122253491201"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </td></tr>
<tr class="memitem:ac897e7fcbfbb068d5d29122253491201"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac897e7fcbfbb068d5d29122253491201">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ac897e7fcbfbb068d5d29122253491201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361c44c79db73248056ed6b5dec531e3"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename ... Ts, typename  = typename std::enable_if&lt;T0::is_functor::value &amp;&amp;								 T1::is_functor::value &amp;&amp;								 detail::all_true&lt;Ts::is_functor::value...&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a361c44c79db73248056ed6b5dec531e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1Compose.html">Compose</a>&lt; T0, T1, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a361c44c79db73248056ed6b5dec531e3">compose</a> (T0 const &amp;F0, T1 const &amp;F1, Ts const &amp;...Fs)</td></tr>
<tr class="separator:a361c44c79db73248056ed6b5dec531e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad2ffe3ace108474a31b8cb84ceae7f14">conj</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52f376acf56fca42cc13e010498c668"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:ab52f376acf56fca42cc13e010498c668"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::constant_iterator&lt; Value_Type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab52f376acf56fca42cc13e010498c668">constant_range</a> (const Value_Type &amp;value)</td></tr>
<tr class="separator:ab52f376acf56fca42cc13e010498c668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e92ed315afaaf9c66edd4739e345daf"><td class="memTemplParams" colspan="2">template&lt;unsigned int ArgIndex, typename Functor , typename Kernel &gt; </td></tr>
<tr class="memitem:a1e92ed315afaaf9c66edd4739e345daf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1e92ed315afaaf9c66edd4739e345daf">convolute</a> (Functor const &amp;functor, Kernel const &amp;kernel, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> kmin, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> kmax, size_t nsamples=100) -&gt; <a class="el" href="classhydra_1_1Convolution.html">Convolution</a>&lt; Functor, Kernel, ArgIndex &gt;</td></tr>
<tr class="separator:a1e92ed315afaaf9c66edd4739e345daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target &gt; </td></tr>
<tr class="memitem:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0b928198a46f83eb9d2793e8e079ba5a">copy</a> (Iterable_Source &amp;&amp;source, Iterable_Target &amp;&amp;destination)</td></tr>
<tr class="separator:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82497912f037617b630d048bfcc515c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82497912f037617b630d048bfcc515c0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a82497912f037617b630d048bfcc515c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9aa7456a15f61cd1ed2b5ef7227409e">cosh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55d71b4eca1da2fac83a615ea4b990"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6d55d71b4eca1da2fac83a615ea4b990">cross</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;p1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;p2)</td></tr>
<tr class="separator:a6d55d71b4eca1da2fac83a615ea4b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ec2838ed0b3d9f3e77d8b51f270c81"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a31ec2838ed0b3d9f3e77d8b51f270c81"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a31ec2838ed0b3d9f3e77d8b51f270c81">distance</a> (Iterator first, Iterator last) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::distance&lt; Iterator &gt;(first, last))</td></tr>
<tr class="separator:a31ec2838ed0b3d9f3e77d8b51f270c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd869e5bd355b1c4646e2c5e1f4ed332"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:afd869e5bd355b1c4646e2c5e1f4ed332"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd869e5bd355b1c4646e2c5e1f4ed332">divide</a> (T1 const &amp;F1, T1 const &amp;F2)</td></tr>
<tr class="separator:afd869e5bd355b1c4646e2c5e1f4ed332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274268d147e9a988f379326b73682b0"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a4274268d147e9a988f379326b73682b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a> (const C &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="separator:a4274268d147e9a988f379326b73682b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1d1cd86c2f2c422730b87a5890dbaee3">end</a> (C &amp;&amp;c) -&gt; decltype(std::forward&lt; C &gt;(c).end())</td></tr>
<tr class="separator:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3e7ed93e81eae920f0c85fea012dc23c">end</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f64a7db637f2f1865093311d69f0bc"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a03f64a7db637f2f1865093311d69f0bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a03f64a7db637f2f1865093311d69f0bc">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a03f64a7db637f2f1865093311d69f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07ef1a981144fec2ec0227a346bedf8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ab07ef1a981144fec2ec0227a346bedf8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab07ef1a981144fec2ec0227a346bedf8">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ab07ef1a981144fec2ec0227a346bedf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5f434b6fb7d95b6ca2a386e25e6b6733">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f44ac4277e27b370317451862a091d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:ae4f44ac4277e27b370317451862a091d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae4f44ac4277e27b370317451862a091d">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ae4f44ac4277e27b370317451862a091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#gadea4fcd2b0a13095c4408fbee01c2c72">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functor const  &amp;functor, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>) -&gt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a hydra functor on a range using the parallel policy.  <a href="group__generic.html#gadea4fcd2b0a13095c4408fbee01c2c72">More...</a><br /></td></tr>
<tr class="separator:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d2db3d23126c08839d5304f84401a2"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Functors&gt; </td></tr>
<tr class="memitem:gaf3d2db3d23126c08839d5304f84401a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#gaf3d2db3d23126c08839d5304f84401a2">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;,HYDRA_EXTERNAL_NS::thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; typename Functors::return_type ... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;</td></tr>
<tr class="memdesc:gaf3d2db3d23126c08839d5304f84401a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of hydra functors on a range using the parallel policy.  <a href="group__generic.html#gaf3d2db3d23126c08839d5304f84401a2">More...</a><br /></td></tr>
<tr class="separator:gaf3d2db3d23126c08839d5304f84401a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Functor , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga8564abe3d04aa014ba0a6a40e6c5d599">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functor const  &amp;functor, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterators... begins) -&gt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a functor over a list of ranges.  <a href="group__generic.html#ga8564abe3d04aa014ba0a6a40e6c5d599">More...</a><br /></td></tr>
<tr class="separator:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b93fd9a039de79768e3c72de1db6842"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Iterators, typename ... Functors&gt; </td></tr>
<tr class="memitem:ga3b93fd9a039de79768e3c72de1db6842"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga3b93fd9a039de79768e3c72de1db6842">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterators... begins) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; typename Functors::return_type ... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;</td></tr>
<tr class="memdesc:ga3b93fd9a039de79768e3c72de1db6842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of functors over a list of ranges.  <a href="group__generic.html#ga3b93fd9a039de79768e3c72de1db6842">More...</a><br /></td></tr>
<tr class="separator:ga3b93fd9a039de79768e3c72de1db6842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5acb87c4eb594ddbf0c4322a11cf4d8a">exp</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab056ed3df61b0755f67d96f8537c657f"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ab056ed3df61b0755f67d96f8537c657f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab056ed3df61b0755f67d96f8537c657f">for_each</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ab056ed3df61b0755f67d96f8537c657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75feeef216747fa3b7c90b590f2761e8"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </td></tr>
<tr class="memitem:a75feeef216747fa3b7c90b590f2761e8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Map &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a75feeef216747fa3b7c90b590f2761e8">gather</a> (Iterable_Source &amp;&amp;source, Iterable_Map &amp;&amp;map, Iterable_Target &amp;&amp;target)</td></tr>
<tr class="separator:a75feeef216747fa3b7c90b590f2761e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878a4b407da6caf1173b3939f3943d33"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:a878a4b407da6caf1173b3939f3943d33"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a878a4b407da6caf1173b3939f3943d33">get</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;t)</td></tr>
<tr class="memdesc:a878a4b407da6caf1173b3939f3943d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a reference to a <code>tuple</code> element of interest.  <a href="#a878a4b407da6caf1173b3939f3943d33">More...</a><br /></td></tr>
<tr class="separator:a878a4b407da6caf1173b3939f3943d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5d06da4c888dd9915f5b9b68ff324d"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:a7c5d06da4c888dd9915f5b9b68ff324d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7c5d06da4c888dd9915f5b9b68ff324d">get</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a7c5d06da4c888dd9915f5b9b68ff324d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b44fb8fa5030736b4603699cf172253"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7b44fb8fa5030736b4603699cf172253"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7b44fb8fa5030736b4603699cf172253">get</a> (HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a7b44fb8fa5030736b4603699cf172253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2658beb74af1f617373f6f640e2949e4"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2658beb74af1f617373f6f640e2949e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">get</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="memdesc:a2658beb74af1f617373f6f640e2949e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>.  <a href="#a2658beb74af1f617373f6f640e2949e4">More...</a><br /></td></tr>
<tr class="separator:a2658beb74af1f617373f6f640e2949e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63079c411073c082f1099994bd539af"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:af63079c411073c082f1099994bd539af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af63079c411073c082f1099994bd539af">get</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="memdesc:af63079c411073c082f1099994bd539af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>.  <a href="#af63079c411073c082f1099994bd539af">More...</a><br /></td></tr>
<tr class="separator:af63079c411073c082f1099994bd539af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9bd95a2e510a972665cc8e93abb7ad00">get</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7582acf570b53c033d52c6ff0fecb43e">GetFormatedString</a> (const char *format, Args... args)</td></tr>
<tr class="separator:a7582acf570b53c033d52c6ff0fecb43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7640497da0f9e58a93fbb73a130008af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7640497da0f9e58a93fbb73a130008af"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7640497da0f9e58a93fbb73a130008af">hermite</a> (unsigned n, const T x)</td></tr>
<tr class="memdesc:a7640497da0f9e58a93fbb73a130008af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Hermite polynomials \( P_n(n) \) using the recursive relation.  <a href="#a7640497da0f9e58a93fbb73a130008af">More...</a><br /></td></tr>
<tr class="separator:a7640497da0f9e58a93fbb73a130008af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56f5771a38cd48141f2e02712ac025f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae56f5771a38cd48141f2e02712ac025f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae56f5771a38cd48141f2e02712ac025f">jacobi</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> a, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> b, unsigned n, const T x)</td></tr>
<tr class="memdesc:ae56f5771a38cd48141f2e02712ac025f"><td class="mdescLeft">&#160;</td><td class="mdescRight">P_{n-1}^{(,)}(z) - 2 (n+ - 1) (n + -1) (2n+ + ) P_{n-2}^{(, )}(z), {align}&lt;/math&gt;  <a href="#ae56f5771a38cd48141f2e02712ac025f">More...</a><br /></td></tr>
<tr class="separator:ae56f5771a38cd48141f2e02712ac025f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcbd1b972dcec1554ce96916da38a6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fcbd1b972dcec1554ce96916da38a6f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9fcbd1b972dcec1554ce96916da38a6f">laguerre</a> (unsigned n, const T x)</td></tr>
<tr class="memdesc:a9fcbd1b972dcec1554ce96916da38a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Laguerre polynomials \( P_n(n) \) using the recursive relation.  <a href="#a9fcbd1b972dcec1554ce96916da38a6f">More...</a><br /></td></tr>
<tr class="separator:a9fcbd1b972dcec1554ce96916da38a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17470c2d2376f96c63d7c89ed6b6cd5c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17470c2d2376f96c63d7c89ed6b6cd5c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a17470c2d2376f96c63d7c89ed6b6cd5c">legendre</a> (unsigned n, const T x)</td></tr>
<tr class="memdesc:a17470c2d2376f96c63d7c89ed6b6cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Legendre polynomials \( P_n(n) \) using the recursive relation.  <a href="#a17470c2d2376f96c63d7c89ed6b6cd5c">More...</a><br /></td></tr>
<tr class="separator:a17470c2d2376f96c63d7c89ed6b6cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a58122210680157c763df0d84203f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35a58122210680157c763df0d84203f2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a35a58122210680157c763df0d84203f2">legendre</a> (unsigned n, const T x)</td></tr>
<tr class="memdesc:a35a58122210680157c763df0d84203f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Legendre polynomials \( P_n(n) \) using the recursive relation (Bonnet’s recursion formula)  <a href="#a35a58122210680157c763df0d84203f2">More...</a><br /></td></tr>
<tr class="separator:a35a58122210680157c763df0d84203f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725e178af11595cbeba053c1f84dfa8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2725e178af11595cbeba053c1f84dfa8"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2725e178af11595cbeba053c1f84dfa8">log</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a2725e178af11595cbeba053c1f84dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d53a33e43032b9e482284fd1a38b08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64d53a33e43032b9e482284fd1a38b08"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a64d53a33e43032b9e482284fd1a38b08">log10</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a64d53a33e43032b9e482284fd1a38b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245247898bcad6233daf9f9fe49bbffa"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Functors&gt; </td></tr>
<tr class="memitem:a245247898bcad6233daf9f9fe49bbffa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a245247898bcad6233daf9f9fe49bbffa">make_cache</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Iterator first, Iterator last, Functors &amp;... functors) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Cache">Cache</a>&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functors... &gt;</td></tr>
<tr class="separator:a245247898bcad6233daf9f9fe49bbffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c36400392fc1613db3bcabd7c74575"><td class="memTemplParams" colspan="2">template&lt;size_t ... N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ac9c36400392fc1613db3bcabd7c74575"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__phsp.html#classhydra_1_1Chains">Chains</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9c36400392fc1613db3bcabd7c74575">make_chain</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, size_t entries)</td></tr>
<tr class="separator:ac9c36400392fc1613db3bcabd7c74575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2864fe6d4fb9b0015aeda0dd27b6389"><td class="memTemplParams" colspan="2">template&lt;size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ae2864fe6d4fb9b0015aeda0dd27b6389"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2864fe6d4fb9b0015aeda0dd27b6389">make_decays</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, size_t entries)</td></tr>
<tr class="separator:ae2864fe6d4fb9b0015aeda0dd27b6389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ecdc6e5a05bddea819b4affc65a8fa"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga71ecdc6e5a05bddea819b4affc65a8fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga71ecdc6e5a05bddea819b4affc65a8fa">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt; const &amp;lowerlimits, std::array&lt; T, N &gt; const &amp;upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga71ecdc6e5a05bddea819b4affc65a8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga71ecdc6e5a05bddea819b4affc65a8fa">More...</a><br /></td></tr>
<tr class="separator:ga71ecdc6e5a05bddea819b4affc65a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ccbcab5a2abc07308abe45e22589c2d"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:ga4ccbcab5a2abc07308abe45e22589c2d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga4ccbcab5a2abc07308abe45e22589c2d">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt; lowerlimits, std::array&lt; T, N &gt; upperlimits, Iterable &amp;&amp;data)</td></tr>
<tr class="memdesc:ga4ccbcab5a2abc07308abe45e22589c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga4ccbcab5a2abc07308abe45e22589c2d">More...</a><br /></td></tr>
<tr class="separator:ga4ccbcab5a2abc07308abe45e22589c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9110cb1abf49fb7f3fcaa31f24d3e84"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gac9110cb1abf49fb7f3fcaa31f24d3e84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gac9110cb1abf49fb7f3fcaa31f24d3e84">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t grid, T lowerlimits, T upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:gac9110cb1abf49fb7f3fcaa31f24d3e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#gac9110cb1abf49fb7f3fcaa31f24d3e84">More...</a><br /></td></tr>
<tr class="separator:gac9110cb1abf49fb7f3fcaa31f24d3e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec47177241d6057ab5d2e4ad5fc84a6"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga6ec47177241d6057ab5d2e4ad5fc84a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga6ec47177241d6057ab5d2e4ad5fc84a6">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt; const &amp;pdf, Iterator first, Iterator last, Iterators... weights) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt;, Iterator, Iterators... &gt;</td></tr>
<tr class="memdesc:ga6ec47177241d6057ab5d2e4ad5fc84a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga6ec47177241d6057ab5d2e4ad5fc84a6">More...</a><br /></td></tr>
<tr class="separator:ga6ec47177241d6057ab5d2e4ad5fc84a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f620a60b4ae802f5dc2e219e7e8dbd"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga89f620a60b4ae802f5dc2e219e7e8dbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga89f620a60b4ae802f5dc2e219e7e8dbd">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;const &amp;pdf, Iterator first, Iterator last, Iterators... weights) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt;</td></tr>
<tr class="memdesc:ga89f620a60b4ae802f5dc2e219e7e8dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga89f620a60b4ae802f5dc2e219e7e8dbd">More...</a><br /></td></tr>
<tr class="separator:ga89f620a60b4ae802f5dc2e219e7e8dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedfd3c104a7e4ee0ec981db5b9d1ab85"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:gaedfd3c104a7e4ee0ec981db5b9d1ab85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gaedfd3c104a7e4ee0ec981db5b9d1ab85">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterator first, Iterator last, Iterators... weights) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt;</td></tr>
<tr class="memdesc:gaedfd3c104a7e4ee0ec981db5b9d1ab85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#gaedfd3c104a7e4ee0ec981db5b9d1ab85">More...</a><br /></td></tr>
<tr class="separator:gaedfd3c104a7e4ee0ec981db5b9d1ab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956732407bfa5db6dd53fb7a1bb7062b"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterable , typename ... Iterables, typename U &gt; </td></tr>
<tr class="memitem:a956732407bfa5db6dd53fb7a1bb7062b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; Iterable &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; Iterable &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;U::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt;, decltype(std::declval&lt; const Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Iterables &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a956732407bfa5db6dd53fb7a1bb7062b">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt; const &amp;pdf, Iterable const &amp;points, Iterables const &amp;... weights)</td></tr>
<tr class="separator:a956732407bfa5db6dd53fb7a1bb7062b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e11a3c268f89943b3fd17cab69e8dd"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Iterable , typename ... Iterables, typename U &gt; </td></tr>
<tr class="memitem:ga70e11a3c268f89943b3fd17cab69e8dd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; Iterable &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; Iterable &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;U::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; const Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga70e11a3c268f89943b3fd17cab69e8dd">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt; const  &amp;functor, Iterable const  &amp;points, Iterables const  &amp;... weights)</td></tr>
<tr class="memdesc:ga70e11a3c268f89943b3fd17cab69e8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga70e11a3c268f89943b3fd17cab69e8dd">More...</a><br /></td></tr>
<tr class="separator:ga70e11a3c268f89943b3fd17cab69e8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe3d480c21e975f0899d3bd2e7f5383f"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename T , size_t N, hydra::detail::Backend BACKEND, typename D &gt; </td></tr>
<tr class="memitem:gabe3d480c21e975f0899d3bd2e7f5383f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt;, decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gabe3d480c21e975f0899d3bd2e7f5383f">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt; const  &amp;pdf, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &amp;points)</td></tr>
<tr class="memdesc:gabe3d480c21e975f0899d3bd2e7f5383f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns for densely binned datasets.  <a href="group__fit.html#gabe3d480c21e975f0899d3bd2e7f5383f">More...</a><br /></td></tr>
<tr class="separator:gabe3d480c21e975f0899d3bd2e7f5383f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8512d7e57b7f4ba0afedb5184b4ffd9e"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Iterable , typename ... Iterables, typename U &gt; </td></tr>
<tr class="memitem:ga8512d7e57b7f4ba0afedb5184b4ffd9e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; Iterable &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; Iterable &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;U::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; const Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga8512d7e57b7f4ba0afedb5184b4ffd9e">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const  &amp;functor, Iterable const  &amp;points, Iterables const  &amp;... weights)</td></tr>
<tr class="memdesc:ga8512d7e57b7f4ba0afedb5184b4ffd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga8512d7e57b7f4ba0afedb5184b4ffd9e">More...</a><br /></td></tr>
<tr class="separator:ga8512d7e57b7f4ba0afedb5184b4ffd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0b61bc429890381ac9bb0be71f3b00"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename T , size_t N, hydra::detail::Backend BACKEND, typename D &gt; </td></tr>
<tr class="memitem:gabf0b61bc429890381ac9bb0be71f3b00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gabf0b61bc429890381ac9bb0be71f3b00">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt; const &amp;functor, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &amp;points)</td></tr>
<tr class="memdesc:gabf0b61bc429890381ac9bb0be71f3b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns for densely binned datasets.  <a href="group__fit.html#gabf0b61bc429890381ac9bb0be71f3b00">More...</a><br /></td></tr>
<tr class="separator:gabf0b61bc429890381ac9bb0be71f3b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1720a8aed6a942b814dad14efc2148e5"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename T , size_t N, hydra::detail::Backend BACKEND, typename D &gt; </td></tr>
<tr class="memitem:ga1720a8aed6a942b814dad14efc2148e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt;, decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga1720a8aed6a942b814dad14efc2148e5">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt; const  &amp;pdf, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &amp;points)</td></tr>
<tr class="memdesc:ga1720a8aed6a942b814dad14efc2148e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns for densely binned datasets.  <a href="group__fit.html#ga1720a8aed6a942b814dad14efc2148e5">More...</a><br /></td></tr>
<tr class="separator:ga1720a8aed6a942b814dad14efc2148e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c4af135808c1321a7c324da5286a37"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename T , size_t N, hydra::detail::Backend BACKEND, typename D &gt; </td></tr>
<tr class="memitem:gaa7c4af135808c1321a7c324da5286a37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gaa7c4af135808c1321a7c324da5286a37">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const  &amp;functor, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &amp;points)</td></tr>
<tr class="memdesc:gaa7c4af135808c1321a7c324da5286a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns for densely binned datasets.  <a href="group__fit.html#gaa7c4af135808c1321a7c324da5286a37">More...</a><br /></td></tr>
<tr class="separator:gaa7c4af135808c1321a7c324da5286a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7349049c62f48deb6085df613832ddbc"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename T , size_t N, hydra::detail::Backend BACKEND, typename D &gt; </td></tr>
<tr class="memitem:ga7349049c62f48deb6085df613832ddbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7349049c62f48deb6085df613832ddbc">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt; const  &amp;functor, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &amp;points)</td></tr>
<tr class="memdesc:ga7349049c62f48deb6085df613832ddbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns for densely binned datasets.  <a href="group__fit.html#ga7349049c62f48deb6085df613832ddbc">More...</a><br /></td></tr>
<tr class="separator:ga7349049c62f48deb6085df613832ddbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e764d25d35a8556ad8a31e78f92417"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename T , size_t N, hydra::detail::Backend BACKEND, typename D &gt; </td></tr>
<tr class="memitem:ga26e764d25d35a8556ad8a31e78f92417"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga26e764d25d35a8556ad8a31e78f92417">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const  &amp;functor, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &amp;points)</td></tr>
<tr class="memdesc:ga26e764d25d35a8556ad8a31e78f92417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns for densely binned datasets.  <a href="group__fit.html#ga26e764d25d35a8556ad8a31e78f92417">More...</a><br /></td></tr>
<tr class="separator:ga26e764d25d35a8556ad8a31e78f92417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0b61bc429890381ac9bb0be71f3b00"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename T , size_t N, hydra::detail::Backend BACKEND, typename D &gt; </td></tr>
<tr class="memitem:gabf0b61bc429890381ac9bb0be71f3b00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gabf0b61bc429890381ac9bb0be71f3b00">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt; const &amp;functor, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, D &gt; &amp;points)</td></tr>
<tr class="memdesc:gabf0b61bc429890381ac9bb0be71f3b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns for densely binned datasets.  <a href="group__fit.html#gabf0b61bc429890381ac9bb0be71f3b00">More...</a><br /></td></tr>
<tr class="separator:gabf0b61bc429890381ac9bb0be71f3b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b9fd25a44634ab41c7c102a97e42cb"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ab8b9fd25a44634ab41c7c102a97e42cb"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab8b9fd25a44634ab41c7c102a97e42cb">make_pair</a> (T1 &amp;&amp;t1, T2 &amp;&amp;t2) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_pair(std::forward&lt; T1 &gt;(t1), std::forward&lt; T2 &gt;(t2)))</td></tr>
<tr class="memdesc:ab8b9fd25a44634ab41c7c102a97e42cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects.  <a href="#ab8b9fd25a44634ab41c7c102a97e42cb">More...</a><br /></td></tr>
<tr class="separator:ab8b9fd25a44634ab41c7c102a97e42cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplParams" colspan="2">template&lt;typename FUNCTOR , typename INTEGRATOR &gt; </td></tr>
<tr class="memitem:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; FUNCTOR, INTEGRATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga2d468a0d98a74f41479f8ccb95f5533e">make_pdf</a> (FUNCTOR const &amp;functor, INTEGRATOR integrator)</td></tr>
<tr class="memdesc:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="group__fit.html#classhydra_1_1Pdf" title="Class representing probability density functions. ">hydra::Pdf</a> given a shape described by a functor and a integrator (algorithm or functor).  <a href="group__fit.html#ga2d468a0d98a74f41479f8ccb95f5533e">More...</a><br /></td></tr>
<tr class="separator:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7f979949a9340e95660a70b83358dd"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:aca7f979949a9340e95660a70b83358dd"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator, Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aca7f979949a9340e95660a70b83358dd">make_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const &amp;functor)</td></tr>
<tr class="separator:aca7f979949a9340e95660a70b83358dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed731c061feb7b22667628e351da610b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aed731c061feb7b22667628e351da610b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aed731c061feb7b22667628e351da610b">make_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="separator:aed731c061feb7b22667628e351da610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848831bc77a005363d36d66a5a76dab9"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a848831bc77a005363d36d66a5a76dab9"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a848831bc77a005363d36d66a5a76dab9">make_range</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a848831bc77a005363d36d66a5a76dab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeb94a482290a0c2c1764865e7d16dcf8">make_range</a> (Iterable const &amp;container)</td></tr>
<tr class="separator:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997423cc7da26ee78b795e07a6910c29"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a997423cc7da26ee78b795e07a6910c29"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a997423cc7da26ee78b795e07a6910c29">make_range</a> (Iterable &amp;&amp;container)</td></tr>
<tr class="separator:a997423cc7da26ee78b795e07a6910c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41a92d68bff7650655ef587d27611c4"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ad41a92d68bff7650655ef587d27611c4"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad41a92d68bff7650655ef587d27611c4">make_range</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ad41a92d68bff7650655ef587d27611c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8920bd6c86e10092b7f5f0a3ac594f0c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:a8920bd6c86e10092b7f5f0a3ac594f0c"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::reverse_iterator&lt; Iterator &gt;, Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8920bd6c86e10092b7f5f0a3ac594f0c">make_reverse_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const &amp;functor)</td></tr>
<tr class="separator:a8920bd6c86e10092b7f5f0a3ac594f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6560e735b887aef4c3e73e342f5994"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a9b6560e735b887aef4c3e73e342f5994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::reverse_iterator&lt; Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9b6560e735b887aef4c3e73e342f5994">make_reverse_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="separator:a9b6560e735b887aef4c3e73e342f5994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be66889f53db6bbae8365d509c13cd1"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a8be66889f53db6bbae8365d509c13cd1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8be66889f53db6bbae8365d509c13cd1">make_reverse_range</a> (Iterable const &amp;container)</td></tr>
<tr class="separator:a8be66889f53db6bbae8365d509c13cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd548971df59145c8bcf4db33538645"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a4bd548971df59145c8bcf4db33538645"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4bd548971df59145c8bcf4db33538645">make_reverse_range</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a4bd548971df59145c8bcf4db33538645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb731a7ec634ab03b448a6cc6230d68"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:abdb731a7ec634ab03b448a6cc6230d68"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abdb731a7ec634ab03b448a6cc6230d68">make_reverse_range</a> (Iterable &amp;&amp;container)</td></tr>
<tr class="separator:abdb731a7ec634ab03b448a6cc6230d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1391215774750e4ae5daf419b5768c7b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a1391215774750e4ae5daf419b5768c7b"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1391215774750e4ae5daf419b5768c7b">make_reverse_range</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a1391215774750e4ae5daf419b5768c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga2cea405a4f933f25af1f2afe7e67c381">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt; const  &amp;lowerlimits, std::array&lt; T, N &gt; const  &amp;upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga2cea405a4f933f25af1f2afe7e67c381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#ga2cea405a4f933f25af1f2afe7e67c381">More...</a><br /></td></tr>
<tr class="separator:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f3da2c2a9505237640a47c3e088fae"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:af2f3da2c2a9505237640a47c3e088fae"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af2f3da2c2a9505237640a47c3e088fae">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt; const &amp;lowerlimits, std::array&lt; T, N &gt; const &amp;upperlimits, Iterable &amp;&amp;iterable)</td></tr>
<tr class="separator:af2f3da2c2a9505237640a47c3e088fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1d65c69312c606d2379539278aa702"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga9a1d65c69312c606d2379539278aa702"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga9a1d65c69312c606d2379539278aa702">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t grid, T lowerlimits, T upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga9a1d65c69312c606d2379539278aa702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#ga9a1d65c69312c606d2379539278aa702">More...</a><br /></td></tr>
<tr class="separator:ga9a1d65c69312c606d2379539278aa702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c92f763d48eb14a538692a07da5e38"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a34c92f763d48eb14a538692a07da5e38"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a34c92f763d48eb14a538692a07da5e38">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, size_t grid, T lowerlimits, T upperlimits, Iterable &amp;&amp;iterable)</td></tr>
<tr class="separator:a34c92f763d48eb14a538692a07da5e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5314ace45b4baa7084a9addb625ca99"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:af5314ace45b4baa7084a9addb625ca99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1SPlot.html">SPlot</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af5314ace45b4baa7084a9addb625ca99">make_splot</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdf)</td></tr>
<tr class="separator:af5314ace45b4baa7084a9addb625ca99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70a2baeff9ebf89f64ebd08ebaab2d7"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:ac70a2baeff9ebf89f64ebd08ebaab2d7"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac70a2baeff9ebf89f64ebd08ebaab2d7">make_tuple</a> (T const &amp;... t) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(t...))</td></tr>
<tr class="memdesc:ac70a2baeff9ebf89f64ebd08ebaab2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects.  <a href="#ac70a2baeff9ebf89f64ebd08ebaab2d7">More...</a><br /></td></tr>
<tr class="separator:ac70a2baeff9ebf89f64ebd08ebaab2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ca94258b9800a2b2fe700f7012f545"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a16ca94258b9800a2b2fe700f7012f545"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a16ca94258b9800a2b2fe700f7012f545">make_tuple</a> (T &amp;&amp;... t) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(std::forward&lt; T &gt;(t)...))</td></tr>
<tr class="memdesc:a16ca94258b9800a2b2fe700f7012f545"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects.  <a href="#a16ca94258b9800a2b2fe700f7012f545">More...</a><br /></td></tr>
<tr class="separator:a16ca94258b9800a2b2fe700f7012f545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b91350feefa178d4403a6e8b92e97b"><td class="memTemplParams" colspan="2">template&lt;unsigned int ArgIndex = 0, template&lt; int &gt; class T, int J, int M, int N&gt; </td></tr>
<tr class="memitem:a42b91350feefa178d4403a6e8b92e97b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1WignerD">WignerD</a>&lt; T&lt; J &gt;, T&lt; M &gt;, T&lt; N &gt;, ArgIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a42b91350feefa178d4403a6e8b92e97b">Make_WignerD</a> (T&lt; J &gt; const &amp;obj1, T&lt; M &gt; const &amp;obj2, T&lt; N &gt; const &amp;obj3)</td></tr>
<tr class="separator:a42b91350feefa178d4403a6e8b92e97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb8665ee28f5e766b614992c0491dd7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:acdb8665ee28f5e766b614992c0491dd7"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acdb8665ee28f5e766b614992c0491dd7">minus</a> (T1 const &amp;F1, T1 const &amp;F2)</td></tr>
<tr class="separator:acdb8665ee28f5e766b614992c0491dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237ae37875016b34f82e3664703be679"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a237ae37875016b34f82e3664703be679"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; F1, F2, Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a237ae37875016b34f82e3664703be679">multiply</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:a237ae37875016b34f82e3664703be679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f06ee4cd16c4cd697a380053748bf67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f06ee4cd16c4cd697a380053748bf67"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2f06ee4cd16c4cd697a380053748bf67">nint</a> (const T x)</td></tr>
<tr class="memdesc:a2f06ee4cd16c4cd697a380053748bf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest integer.  <a href="#a2f06ee4cd16c4cd697a380053748bf67">More...</a><br /></td></tr>
<tr class="separator:a2f06ee4cd16c4cd697a380053748bf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab5fd2d8f62c3075ccdd36241e8dc6881">norm</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24943c0d2419a40a68f0fb61e0a1b05f">operator!=</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716c80436ab96c757325cae3cd517960"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a716c80436ab96c757325cae3cd517960"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a716c80436ab96c757325cae3cd517960">operator!=</a> (const T &amp;lhs, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a716c80436ab96c757325cae3cd517960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d952f42e31697e4b457b1a58424cb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91d952f42e31697e4b457b1a58424cb5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a91d952f42e31697e4b457b1a58424cb5">operator!=</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a91d952f42e31697e4b457b1a58424cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memTemplParams" colspan="2">template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74f09f60eaa232f756f2e5ee0ccb5326">operator!=</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;lhs, const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51499fa04d39681eb6244313d32a16c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:aa51499fa04d39681eb6244313d32a16c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa51499fa04d39681eb6244313d32a16c">operator!=</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:aa51499fa04d39681eb6244313d32a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258cacce52e3670d4880af1576a16a22"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a258cacce52e3670d4880af1576a16a22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a258cacce52e3670d4880af1576a16a22">operator!=</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a258cacce52e3670d4880af1576a16a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01febd59c4dfebc87b5d363955d65db"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad01febd59c4dfebc87b5d363955d65db">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:ad01febd59c4dfebc87b5d363955d65db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa868eaf400c854297996c269f401e69e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa868eaf400c854297996c269f401e69e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa868eaf400c854297996c269f401e69e">operator*</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:aa868eaf400c854297996c269f401e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dce6130507b07eaac142c1815ade3f2"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0dce6130507b07eaac142c1815ade3f2">operator*</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a0dce6130507b07eaac142c1815ade3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2021f911a26d3c79b62d1a2f1fa9dcf0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2021f911a26d3c79b62d1a2f1fa9dcf0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2021f911a26d3c79b62d1a2f1fa9dcf0">operator*</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:a2021f911a26d3c79b62d1a2f1fa9dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd42c2a636a5bfb4e605ddd9f1ea069a"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd42c2a636a5bfb4e605ddd9f1ea069a">operator*</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:afd42c2a636a5bfb4e605ddd9f1ea069a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9d6d9136eecf2c929dd9b12356d833"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:afa9d6d9136eecf2c929dd9b12356d833"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afa9d6d9136eecf2c929dd9b12356d833">operator*</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:afa9d6d9136eecf2c929dd9b12356d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bae5caa4d9b5c0190220e55f650859"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5bae5caa4d9b5c0190220e55f650859">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:ae5bae5caa4d9b5c0190220e55f650859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0be1f22ac4914bd6ce0bc97411bff"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2b0be1f22ac4914bd6ce0bc97411bff">operator*</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:ae2b0be1f22ac4914bd6ce0bc97411bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb096b020e55914fe7a1e885dd66b17e"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adb096b020e55914fe7a1e885dd66b17e">operator*</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:adb096b020e55914fe7a1e885dd66b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bdba87b791f8a68e8571eaa00788cd"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a31bdba87b791f8a68e8571eaa00788cd"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a31bdba87b791f8a68e8571eaa00788cd">operator*</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a31bdba87b791f8a68e8571eaa00788cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b98f3604eca3a6023551cd4ce98020a"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0b98f3604eca3a6023551cd4ce98020a">operator*</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a0b98f3604eca3a6023551cd4ce98020a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac480ecaec81a0040f3b466ca5904ed5b"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac480ecaec81a0040f3b466ca5904ed5b">operator*</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:ac480ecaec81a0040f3b466ca5904ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bc15a0070c95cad2a9b6e300b430cc"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa0bc15a0070c95cad2a9b6e300b430cc">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:aa0bc15a0070c95cad2a9b6e300b430cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab71f63c56b41e970fee5c7fa48915"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:a81ab71f63c56b41e970fee5c7fa48915"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a81ab71f63c56b41e970fee5c7fa48915">operator+</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a81ab71f63c56b41e970fee5c7fa48915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bc87dddca38c44ed5276eedb78a176"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a58bc87dddca38c44ed5276eedb78a176"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a58bc87dddca38c44ed5276eedb78a176">operator+</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:a58bc87dddca38c44ed5276eedb78a176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8f4a42269c2f7b4316a413efe5190e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:acd8f4a42269c2f7b4316a413efe5190e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acd8f4a42269c2f7b4316a413efe5190e">operator+</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:acd8f4a42269c2f7b4316a413efe5190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1fc13eb2a4a440f72991b4347a472c"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c1fc13eb2a4a440f72991b4347a472c">operator+</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:a1c1fc13eb2a4a440f72991b4347a472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781df21a8dca74210f8dc39b340b58ec"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a781df21a8dca74210f8dc39b340b58ec"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a781df21a8dca74210f8dc39b340b58ec">operator+</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a781df21a8dca74210f8dc39b340b58ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a4c9bed0e1a2cf2ed9ba9ab057dd0"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af68a4c9bed0e1a2cf2ed9ba9ab057dd0">operator+</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:af68a4c9bed0e1a2cf2ed9ba9ab057dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e3492eb046c39e1b578738cd5ad7b7"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a26e3492eb046c39e1b578738cd5ad7b7">operator+</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a26e3492eb046c39e1b578738cd5ad7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357a28a5ec78cd838e8e90face792425"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a357a28a5ec78cd838e8e90face792425">operator+</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a357a28a5ec78cd838e8e90face792425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6b67d073431ddbbc9df286683b6391"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:a8e6b67d073431ddbbc9df286683b6391"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8e6b67d073431ddbbc9df286683b6391">operator-</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a8e6b67d073431ddbbc9df286683b6391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab209688d56c7888c7fb173e06b4a63b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab209688d56c7888c7fb173e06b4a63b8"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab209688d56c7888c7fb173e06b4a63b8">operator-</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:ab209688d56c7888c7fb173e06b4a63b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ab9137952e574434bb5457b5e7624b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa0ab9137952e574434bb5457b5e7624b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; T2, <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa0ab9137952e574434bb5457b5e7624b">operator-</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:aa0ab9137952e574434bb5457b5e7624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1113b35a5588af8a55453fbd5e1b2651"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1113b35a5588af8a55453fbd5e1b2651">operator-</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:a1113b35a5588af8a55453fbd5e1b2651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b7a7b4b2afa53b5b17883d43c6635b"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a28b7a7b4b2afa53b5b17883d43c6635b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a28b7a7b4b2afa53b5b17883d43c6635b">operator-</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a28b7a7b4b2afa53b5b17883d43c6635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950f2d5dc4356f6c6c13b9fc3bc7c0ef"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a950f2d5dc4356f6c6c13b9fc3bc7c0ef">operator-</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:a950f2d5dc4356f6c6c13b9fc3bc7c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68375d62444cb2341ade99f0ac15972f"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a68375d62444cb2341ade99f0ac15972f">operator-</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a68375d62444cb2341ade99f0ac15972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c46e4c59a5208f5d495b4ddaf3af75"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a07c46e4c59a5208f5d495b4ddaf3af75">operator-</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a07c46e4c59a5208f5d495b4ddaf3af75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247f457807559c67d34c5b9d15c0b4b4"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a247f457807559c67d34c5b9d15c0b4b4">operator-</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par2)</td></tr>
<tr class="separator:a247f457807559c67d34c5b9d15c0b4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa3a711732edb66303a415b0053ab30"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:a0fa3a711732edb66303a415b0053ab30"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0fa3a711732edb66303a415b0053ab30">operator/</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a0fa3a711732edb66303a415b0053ab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51adfe83d6139c094696c576cac08eb9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a51adfe83d6139c094696c576cac08eb9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a51adfe83d6139c094696c576cac08eb9">operator/</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:a51adfe83d6139c094696c576cac08eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f958068c4dcdbb79b40925e2da4b24"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a73f958068c4dcdbb79b40925e2da4b24"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; T2, <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a73f958068c4dcdbb79b40925e2da4b24">operator/</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:a73f958068c4dcdbb79b40925e2da4b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cb4a79113148abd78aa8e4d6f7e41d"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a94cb4a79113148abd78aa8e4d6f7e41d">operator/</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a94cb4a79113148abd78aa8e4d6f7e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db4d6d0e3fe03dccf661b7ac0751fe7"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4db4d6d0e3fe03dccf661b7ac0751fe7">operator/</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a4db4d6d0e3fe03dccf661b7ac0751fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61779a5f2bd6e73c2808fc388b3aa496"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a61779a5f2bd6e73c2808fc388b3aa496"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a61779a5f2bd6e73c2808fc388b3aa496">operator/</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a61779a5f2bd6e73c2808fc388b3aa496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b1664e58d41d5f8e7ec6d1c20bf9c0"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9b1664e58d41d5f8e7ec6d1c20bf9c0">operator/</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const par2)</td></tr>
<tr class="separator:ac9b1664e58d41d5f8e7ec6d1c20bf9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4133d480d7e9f3f5e85286e47a3709"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0a4133d480d7e9f3f5e85286e47a3709">operator/</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a0a4133d480d7e9f3f5e85286e47a3709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29cde1e70c62bec6f1fa1ee52940887"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af29cde1e70c62bec6f1fa1ee52940887">operator/</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par2)</td></tr>
<tr class="separator:af29cde1e70c62bec6f1fa1ee52940887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a15cdb083719133399edb77f5ef3eb547">operator&lt;&lt;</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a15cdb083719133399edb77f5ef3eb547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6fab8d226ee701c0755c60202fc30f6c">operator&lt;&lt;</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:a6fab8d226ee701c0755c60202fc30f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad4d7f13d811f0d63d4ce49d31b6cfbe0">operator&lt;&lt;</a> (std::ostream &amp;os, std::pair&lt; T1, T2 &gt; const &amp;obj)</td></tr>
<tr class="separator:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa8037907332bf633dfc1bc3b40865c"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3fa8037907332bf633dfc1bc3b40865c">operator&lt;&lt;</a> (ostream &amp;s, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v)</td></tr>
<tr class="separator:a3fa8037907332bf633dfc1bc3b40865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacce78528c9499de97312cbe606ece4"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aaacce78528c9499de97312cbe606ece4">operator&lt;&lt;</a> (ostream &amp;s, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v)</td></tr>
<tr class="separator:aaacce78528c9499de97312cbe606ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3be8e63c60c604b927f9638600a598b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad3be8e63c60c604b927f9638600a598b">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a> const &amp;par)</td></tr>
<tr class="memdesc:ad3be8e63c60c604b927f9638600a598b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhydra_1_1Print.html">Print</a> the ROOT::Minuit2 state to stream.  <a href="#ad3be8e63c60c604b927f9638600a598b">More...</a><br /></td></tr>
<tr class="separator:ad3be8e63c60c604b927f9638600a598b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , class charT , class traits &gt; </td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a21d7262b80d73f956ed1a477607b9053">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a21d7262b80d73f956ed1a477607b9053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb57654e359a17e312e9aef986f956a8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adb57654e359a17e312e9aef986f956a8">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;var)</td></tr>
<tr class="separator:adb57654e359a17e312e9aef986f956a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea70aec01321527f54717a004a3df99d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea70aec01321527f54717a004a3df99d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aea70aec01321527f54717a004a3df99d">operator==</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aea70aec01321527f54717a004a3df99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227370a3dddcea864f09490bc65b93ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a227370a3dddcea864f09490bc65b93ad"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a227370a3dddcea864f09490bc65b93ad">operator==</a> (const T &amp;lhs, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a227370a3dddcea864f09490bc65b93ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a99bf5390aa3ab39e8ac0cd109ef6b7c9">operator==</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc9da09d22eae43ed970a123baa27f1"><td class="memTemplParams" colspan="2">template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:aebc9da09d22eae43ed970a123baa27f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aebc9da09d22eae43ed970a123baa27f1">operator==</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;lhs, const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:aebc9da09d22eae43ed970a123baa27f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab3bafbf7fa6e97bc40b02d74d7d596ea">operator==</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a49a0907b93c595507fbd2ea319f2f5d6">operator==</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename charT , class traits &gt; </td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a63ad8f84031200c3161c889507d3a9c0">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;is, <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a63ad8f84031200c3161c889507d3a9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84130bc318145449957a91e45dea963"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ac84130bc318145449957a91e45dea963"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; const Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac84130bc318145449957a91e45dea963">operator|</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ac84130bc318145449957a91e45dea963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab959ec5340fe7f85b886795bc75debc4"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ab959ec5340fe7f85b886795bc75debc4"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab959ec5340fe7f85b886795bc75debc4">operator|</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ab959ec5340fe7f85b886795bc75debc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedbe70d8eee7cd7fc27e1b7710e3d99"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:acedbe70d8eee7cd7fc27e1b7710e3d99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1GenerateDecay.html">detail::GenerateDecay</a>&lt; N, HYDRA_EXTERNAL_NS::thrust::random::default_random_engine &gt;, HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt; size_t &gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type</a>&lt; N, <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &gt;::type &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acedbe70d8eee7cd7fc27e1b7710e3d99">phase_space_range</a> (<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> const &amp;mother, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; masses, size_t nentries)</td></tr>
<tr class="separator:acedbe70d8eee7cd7fc27e1b7710e3d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85d86e6980bcf24de91a003711b3224"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae85d86e6980bcf24de91a003711b3224">pmf</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> mother_mass, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> daughter1_mass, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> daughter2_mass)</td></tr>
<tr class="memdesc:ae85d86e6980bcf24de91a003711b3224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum in mother frame of daughter particle in two-body-decay.  <a href="#ae85d86e6980bcf24de91a003711b3224">More...</a><br /></td></tr>
<tr class="separator:ae85d86e6980bcf24de91a003711b3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae3cc52fabc8882be13d9a6ca92fc648e">polar</a> (const T &amp;m, const T &amp;theta=0)</td></tr>
<tr class="separator:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a95aad7e7e244a3cb3c71a4d57e695511">pow</a> (T x)</td></tr>
<tr class="memdesc:a95aad7e7e244a3cb3c71a4d57e695511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power with integer exponent.  <a href="#a95aad7e7e244a3cb3c71a4d57e695511">More...</a><br /></td></tr>
<tr class="separator:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2256bff965f5a7359591579a97114ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2256bff965f5a7359591579a97114ec"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ac2256bff965f5a7359591579a97114ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf806d100f53f6d281b8b826697e10f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cf806d100f53f6d281b8b826697e10f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4cf806d100f53f6d281b8b826697e10f">pow</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:a4cf806d100f53f6d281b8b826697e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2e9146d77dfa5b6c0fcbcb31557f6854">pow</a> (const T &amp;x, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e9dc190c08a69b225d320ab8da1582"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab5e9dc190c08a69b225d320ab8da1582"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab5e9dc190c08a69b225d320ab8da1582">pow</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:ab5e9dc190c08a69b225d320ab8da1582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddd0dd31b59ee6d761eccb6cd78b452"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:adddd0dd31b59ee6d761eccb6cd78b452"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adddd0dd31b59ee6d761eccb6cd78b452">pow</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const U &amp;y)</td></tr>
<tr class="separator:adddd0dd31b59ee6d761eccb6cd78b452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57b4e7a8e408d4e545f46a2c1923cd5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab57b4e7a8e408d4e545f46a2c1923cd5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab57b4e7a8e408d4e545f46a2c1923cd5">pow</a> (const T &amp;x, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:ab57b4e7a8e408d4e545f46a2c1923cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acb0c9817024c69efe44c2d9653928519">PrintToStream</a> (std::ostream &amp;ostream, const char *format, Args... args)</td></tr>
<tr class="separator:acb0c9817024c69efe44c2d9653928519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0454750e3561d390ee18b96824227c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace0454750e3561d390ee18b96824227c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ace0454750e3561d390ee18b96824227c">proj</a> (const T &amp;z)</td></tr>
<tr class="separator:ace0454750e3561d390ee18b96824227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea894534fd9a24f2369d9b71d9f586f"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:a9ea894534fd9a24f2369d9b71d9f586f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndExp.html">detail::RndExp</a>&lt; Value_Type, HYDRA_EXTERNAL_NS::thrust::random::default_random_engine &gt;,HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt; size_t &gt;, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9ea894534fd9a24f2369d9b71d9f586f">random_exp_range</a> (const Value_Type &amp;tau, size_t seed)</td></tr>
<tr class="separator:a9ea894534fd9a24f2369d9b71d9f586f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70f8b5bd9c76734b552d9b1ecf7dbce"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:af70f8b5bd9c76734b552d9b1ecf7dbce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndGauss.html">detail::RndGauss</a>&lt; Value_Type, HYDRA_EXTERNAL_NS::thrust::random::default_random_engine &gt;,HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt; size_t &gt;, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af70f8b5bd9c76734b552d9b1ecf7dbce">random_gauss_range</a> (const Value_Type &amp;mean, const Value_Type &amp;width, size_t seed)</td></tr>
<tr class="separator:af70f8b5bd9c76734b552d9b1ecf7dbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb2860f22ab94494447bacfcdd01ebc"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:a2eb2860f22ab94494447bacfcdd01ebc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndUniform.html">detail::RndUniform</a>&lt; Value_Type, HYDRA_EXTERNAL_NS::thrust::random::default_random_engine &gt;,HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt; size_t &gt;, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2eb2860f22ab94494447bacfcdd01ebc">random_uniform_range</a> (const Value_Type &amp;min, const Value_Type &amp;max, size_t seed)</td></tr>
<tr class="separator:a2eb2860f22ab94494447bacfcdd01ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd814fb01cd9d4d7ca9fa8c289627d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt; long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0cd814fb01cd9d4d7ca9fa8c289627d9">range</a> (long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> first, long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> last)</td></tr>
<tr class="separator:a0cd814fb01cd9d4d7ca9fa8c289627d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e3fc7f3e94613126a8198bf90dd59"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a589e3fc7f3e94613126a8198bf90dd59">Range&lt; iterator_type &gt;</a> (other.begin(cls...), other.end(cls...))</td></tr>
<tr class="separator:a589e3fc7f3e94613126a8198bf90dd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcca49207bf7ab79088f28cddb8f21d"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:aadcca49207bf7ab79088f28cddb8f21d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a> (C &amp;&amp;c) -&gt; decltype(std::forward&lt; C &gt;(c).rbegin())</td></tr>
<tr class="separator:aadcca49207bf7ab79088f28cddb8f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434c6a6c1a24dbd8ca880af38694803d"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a434c6a6c1a24dbd8ca880af38694803d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a434c6a6c1a24dbd8ca880af38694803d">rbegin</a> (const C &amp;c) -&gt; decltype(c.rbegin())</td></tr>
<tr class="separator:a434c6a6c1a24dbd8ca880af38694803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0d87c9638b5f275d1fbbef560a3c0197">rbegin</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69daea4927958e8a666ee6ed3a795cbd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a69daea4927958e8a666ee6ed3a795cbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a69daea4927958e8a666ee6ed3a795cbd">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a69daea4927958e8a666ee6ed3a795cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932ef4185794129e04c9a4220db464eb"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a932ef4185794129e04c9a4220db464eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a932ef4185794129e04c9a4220db464eb">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a932ef4185794129e04c9a4220db464eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b257293c03a3475bb28e9575e941ad"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a68b257293c03a3475bb28e9575e941ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a68b257293c03a3475bb28e9575e941ad">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a68b257293c03a3475bb28e9575e941ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2906e8baa707b7e3cbe3ab1c1aa3fa7c">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb5af6bb519cee99d2be4238767f8f3"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:aabb5af6bb519cee99d2be4238767f8f3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, typename HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aabb5af6bb519cee99d2be4238767f8f3">reduce</a> (Iterable &amp;&amp;iterable)</td></tr>
<tr class="separator:aabb5af6bb519cee99d2be4238767f8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor , typename T  = typename HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt;		     decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt; </td></tr>
<tr class="memitem:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a63b9d5a2744d5acc0852b40f5262eb17">reduce</a> (Iterable &amp;&amp;iterable, T const &amp;init, Functor const &amp;binary_functor)</td></tr>
<tr class="separator:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e00797465282d00eeaf0cd82d1c076"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a58e00797465282d00eeaf0cd82d1c076"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a58e00797465282d00eeaf0cd82d1c076">rend</a> (C &amp;&amp;c) -&gt; decltype(std::forward&lt; C &gt;(c).rend())</td></tr>
<tr class="separator:a58e00797465282d00eeaf0cd82d1c076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48be0e2a44047208c68e2c096683db35"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a48be0e2a44047208c68e2c096683db35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a48be0e2a44047208c68e2c096683db35">rend</a> (const C &amp;c) -&gt; decltype(c.rend())</td></tr>
<tr class="separator:a48be0e2a44047208c68e2c096683db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7f3625ffa0bf89a7d056a0d2b226e882">rend</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79366fdc5ac96950ef240f03e0321b5"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad79366fdc5ac96950ef240f03e0321b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad79366fdc5ac96950ef240f03e0321b5">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ad79366fdc5ac96950ef240f03e0321b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175fc3749a8859251e455ea11b8739f8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a175fc3749a8859251e455ea11b8739f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a175fc3749a8859251e455ea11b8739f8">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a175fc3749a8859251e455ea11b8739f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53513fea217a83151a1c98692a1bdbc7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a53513fea217a83151a1c98692a1bdbc7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a53513fea217a83151a1c98692a1bdbc7">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a53513fea217a83151a1c98692a1bdbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc64d77a9d74b4606c449937491181"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a96fc64d77a9d74b4606c449937491181"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a96fc64d77a9d74b4606c449937491181">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a96fc64d77a9d74b4606c449937491181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dff93eff6900d6a3aa93db92e8ba065"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a3dff93eff6900d6a3aa93db92e8ba065"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::reverse_iterator&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3dff93eff6900d6a3aa93db92e8ba065">reverse</a> (Iterable &amp;&amp;iterable)</td></tr>
<tr class="separator:a3dff93eff6900d6a3aa93db92e8ba065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad27ce158f82bfcf3ba0855a224a3f626">rint</a> (T x)</td></tr>
<tr class="separator:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9e21c7083ea65e58667297a801f0c0"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4a9e21c7083ea65e58667297a801f0c0">rotateEuler</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;rs, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> alpha, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> beta, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> gamma)</td></tr>
<tr class="separator:a4a9e21c7083ea65e58667297a801f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9637ed446b2f89c3514f57bac1fd1be"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab9637ed446b2f89c3514f57bac1fd1be">rotateEuler</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> phi, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> theta, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> ksi)</td></tr>
<tr class="separator:ab9637ed446b2f89c3514f57bac1fd1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </td></tr>
<tr class="memitem:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Map &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7b62f11052cf4a8e258b21b9f64f0c6d">scatter</a> (Iterable_Source &amp;&amp;source, Iterable_Map &amp;&amp;map, Iterable_Target &amp;&amp;target)</td></tr>
<tr class="separator:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7d0e5da38544692eb3545e81617e19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb7d0e5da38544692eb3545e81617e19"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acb7d0e5da38544692eb3545e81617e19">sin</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:acb7d0e5da38544692eb3545e81617e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59c474655ecd14c6748391d80e2e4c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af59c474655ecd14c6748391d80e2e4c2"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af59c474655ecd14c6748391d80e2e4c2">sinh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:af59c474655ecd14c6748391d80e2e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </td></tr>
<tr class="memitem:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5b6b3a330b6d16d3221bb7b994b9329b">sort</a> (Iterable &amp;iterable)</td></tr>
<tr class="separator:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64c757c35da63a927af0ad5147ac7c5"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </td></tr>
<tr class="memitem:ac64c757c35da63a927af0ad5147ac7c5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac64c757c35da63a927af0ad5147ac7c5">sort</a> (Iterable &amp;iterable, Functor const &amp;comparator)</td></tr>
<tr class="separator:ac64c757c35da63a927af0ad5147ac7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34662231e9292fda55e3a182ea5d342a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterable_Key , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Iterator_Key  = decltype(std::declval&lt;Iterable_Key&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Iterator_Key&gt;().begin())&gt; </td></tr>
<tr class="memitem:a34662231e9292fda55e3a182ea5d342a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a34662231e9292fda55e3a182ea5d342a">sort_by_key</a> (Iterable &amp;iterable, Iterable_Key &amp;keys)</td></tr>
<tr class="separator:a34662231e9292fda55e3a182ea5d342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af234f162ec15ef9dc4b42cbe31039487"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterator_Key , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Range&lt;Iterator_Key,Functor&gt;&gt;().begin())&gt; </td></tr>
<tr class="memitem:af234f162ec15ef9dc4b42cbe31039487"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af234f162ec15ef9dc4b42cbe31039487">sort_by_key</a> (Iterable &amp;iterable, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator_Key, Functor &gt; &amp;&amp;keys)</td></tr>
<tr class="separator:af234f162ec15ef9dc4b42cbe31039487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74988a829019bf111e7f51d81b33eec7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74988a829019bf111e7f51d81b33eec7"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74988a829019bf111e7f51d81b33eec7">sqrt</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a74988a829019bf111e7f51d81b33eec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa792627bbf68dd5d3c3d969c3462808f"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I&gt; </td></tr>
<tr class="memitem:aa792627bbf68dd5d3c3d969c3462808f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa792627bbf68dd5d3c3d969c3462808f">stream_array_helper</a> (std::ostream &amp;, std::array&lt; T, N &gt; const &amp;)</td></tr>
<tr class="memdesc:aa792627bbf68dd5d3c3d969c3462808f"><td class="mdescLeft">&#160;</td><td class="mdescRight">array streamer helper  <a href="#aa792627bbf68dd5d3c3d969c3462808f">More...</a><br /></td></tr>
<tr class="separator:aa792627bbf68dd5d3c3d969c3462808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6b2446e6e58a2466b66c1277d67075ad">stream_array_helper</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a6b2446e6e58a2466b66c1277d67075ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8b42796ae70a6c34b6871a8755b382"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:afa8b42796ae70a6c34b6871a8755b382"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afa8b42796ae70a6c34b6871a8755b382">stream_tuple_helper</a> (std::ostream &amp;, std::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="memdesc:afa8b42796ae70a6c34b6871a8755b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">tuple streamer helper  <a href="#afa8b42796ae70a6c34b6871a8755b382">More...</a><br /></td></tr>
<tr class="separator:afa8b42796ae70a6c34b6871a8755b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af0ba407638beac5920ac997d3021b413">stream_tuple_helper</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:af0ba407638beac5920ac997d3021b413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d22c1daecb87a2e29aae2703bac16"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:ae69d22c1daecb87a2e29aae2703bac16"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; F1, F2, Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae69d22c1daecb87a2e29aae2703bac16">sum</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:ae69d22c1daecb87a2e29aae2703bac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d619f99868f45f5e06b9040bcc68b7"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa7d619f99868f45f5e06b9040bcc68b7">swap</a> (<a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:aa7d619f99868f45f5e06b9040bcc68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67385a5afc562279b4419a11ab79e3d6"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a67385a5afc562279b4419a11ab79e3d6">swap</a> (<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v1, <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:a67385a5afc562279b4419a11ab79e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110443bb149efe88b6713bc5aca89b7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a110443bb149efe88b6713bc5aca89b7c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a110443bb149efe88b6713bc5aca89b7c">tan</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a110443bb149efe88b6713bc5aca89b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5c39f4b7fa2b8b0c1e4066e9d059b435">tanh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16e05c122a0b3b48937b89de17b621"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a0e16e05c122a0b3b48937b89de17b621"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0e16e05c122a0b3b48937b89de17b621">tie</a> (T &amp;&amp;...t) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::tie(std::forward&lt; T &gt;(t)...))</td></tr>
<tr class="memdesc:a0e16e05c122a0b3b48937b89de17b621"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments.  <a href="#a0e16e05c122a0b3b48937b89de17b621">More...</a><br /></td></tr>
<tr class="separator:a0e16e05c122a0b3b48937b89de17b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e3f95285aed29c7f62df05eecf2f00"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Input , typename Iterable_Output , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable_Output&gt;().begin())&gt; </td></tr>
<tr class="memitem:a66e3f95285aed29c7f62df05eecf2f00"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Output &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Output &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a66e3f95285aed29c7f62df05eecf2f00">transform</a> (Iterable_Input &amp;&amp;iterable_input, Iterable_Output &amp;&amp;iterable_output, Functor const &amp;unary_functor)</td></tr>
<tr class="separator:a66e3f95285aed29c7f62df05eecf2f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab81f5dd96aa2b2ad0373dafa102eaada"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:gab81f5dd96aa2b2ad0373dafa102eaada"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gab81f5dd96aa2b2ad0373dafa102eaada">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator1 wbegin, Iterator1 wend, Iterator2 <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>)</td></tr>
<tr class="memdesc:gab81f5dd96aa2b2ad0373dafa102eaada"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to put produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gab81f5dd96aa2b2ad0373dafa102eaada">More...</a><br /></td></tr>
<tr class="separator:gab81f5dd96aa2b2ad0373dafa102eaada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d220371c79722ad3f1a551a4d1c48f7"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:ga2d220371c79722ad3f1a551a4d1c48f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">hydra::detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga2d220371c79722ad3f1a551a4d1c48f7">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const  &amp;functor)</td></tr>
<tr class="memdesc:ga2d220371c79722ad3f1a551a4d1c48f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to put produce a unweighted sample according to.  <a href="group__random.html#ga2d220371c79722ad3f1a551a4d1c48f7">More...</a><br /></td></tr>
<tr class="separator:ga2d220371c79722ad3f1a551a4d1c48f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dc1871a5b27614eaaf85914458761f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac5dc1871a5b27614eaaf85914458761f">WIGNER_D_FUNCTION</a> (1, 1, 1, <a class="el" href="namespacehydra.html#a9a047a920de59b2ead160699c18bee67">unit</a>, 0.5 *(1.0+::<a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a>(theta))) WIGNER_D_FUNCTION(1</td></tr>
<tr class="separator:ac5dc1871a5b27614eaaf85914458761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df298b5af72bd35d3059f9cf35fff4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2df298b5af72bd35d3059f9cf35fff4f">WIGNER_D_FUNCTION</a> (2, -2, -2, <a class="el" href="namespacehydra.html#a9a047a920de59b2ead160699c18bee67">unit</a>, 0.25 *::<a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a>((1.0+::<a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a>(theta)), 2.0)) WIGNER_D_FUNCTION(2</td></tr>
<tr class="separator:a2df298b5af72bd35d3059f9cf35fff4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81b041e40b15f480c530d137dd2648c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad81b041e40b15f480c530d137dd2648c">WIGNER_D_FUNCTION</a> (5, -5, -5, <a class="el" href="namespacehydra.html#ad4cdde998c768ff10b49ccf19a1d77c8">half</a>, ::<a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a>(::<a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a>(0.5 *theta), 5)) WIGNER_D_FUNCTION(5</td></tr>
<tr class="separator:ad81b041e40b15f480c530d137dd2648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5031c4182811760549bfc06753335a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7b5031c4182811760549bfc06753335a">WIGNER_D_FUNCTION</a> (3, -3, -3, <a class="el" href="namespacehydra.html#ad4cdde998c768ff10b49ccf19a1d77c8">half</a>, ::<a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a>(::<a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a>(0.5 *theta), 3)) WIGNER_D_FUNCTION(3</td></tr>
<tr class="separator:a7b5031c4182811760549bfc06753335a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee74c74056102b0d1e82bc90b8daddb8"><td class="memTemplParams" colspan="2">template&lt;typename J , typename M , typename N &gt; </td></tr>
<tr class="memitem:aee74c74056102b0d1e82bc90b8daddb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aee74c74056102b0d1e82bc90b8daddb8">wigner_d_function</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> theta)</td></tr>
<tr class="separator:aee74c74056102b0d1e82bc90b8daddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831858c15b02a5120473e14ae8953f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac831858c15b02a5120473e14ae8953f0">WIGNER_D_FUNCTION</a> (3, 0, 0, <a class="el" href="namespacehydra.html#a9a047a920de59b2ead160699c18bee67">unit</a>, -0.5 *::<a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a>(theta) *(3.0 - 5.0 *::<a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a>(::<a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a>(theta), 2.0))) WIGNER_D_FUNCTION(3</td></tr>
<tr class="separator:ac831858c15b02a5120473e14ae8953f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ec0c1895bfa4a66a8f672b41b126e0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a18ec0c1895bfa4a66a8f672b41b126e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a18ec0c1895bfa4a66a8f672b41b126e0">wigner_d_function&lt; _half&lt; 1 &gt;, _half&lt; 1 &gt;, _half&lt; 1 &gt; &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> theta)</td></tr>
<tr class="separator:a18ec0c1895bfa4a66a8f672b41b126e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cde280d59cc81116baf574e9f80311"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af0cde280d59cc81116baf574e9f80311"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af0cde280d59cc81116baf574e9f80311">wigner_d_function&lt; _half&lt; 1 &gt;, _half&lt; 1 &gt;, _half&lt;-1 &gt; &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> theta)</td></tr>
<tr class="separator:af0cde280d59cc81116baf574e9f80311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5559b4291adb15c0e1a66b4215a4f00"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae5559b4291adb15c0e1a66b4215a4f00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5559b4291adb15c0e1a66b4215a4f00">wigner_d_function&lt; _half&lt; 1 &gt;, _half&lt;-1 &gt;, _half&lt; 1 &gt; &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> theta)</td></tr>
<tr class="separator:ae5559b4291adb15c0e1a66b4215a4f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55f35301e426a4cfaa1e408970f9972"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af55f35301e426a4cfaa1e408970f9972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af55f35301e426a4cfaa1e408970f9972">wigner_d_function&lt; _half&lt; 1 &gt;, _half&lt;-1 &gt;, _half&lt;-1 &gt; &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> theta)</td></tr>
<tr class="separator:af55f35301e426a4cfaa1e408970f9972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cc58cf433d121a37c54f965023d49a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16cc58cf433d121a37c54f965023d49a"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a16cc58cf433d121a37c54f965023d49a">wigner_d_matrix</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> j, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> m, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> n, const T theta)</td></tr>
<tr class="separator:a16cc58cf433d121a37c54f965023d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6f8e5354bb7e586f34b1d4659ca8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaec6f8e5354bb7e586f34b1d4659ca8c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aaec6f8e5354bb7e586f34b1d4659ca8c">wigner_d_matrix</a> (unsigned j, unsigned m, unsigned n, const T theta)</td></tr>
<tr class="separator:aaec6f8e5354bb7e586f34b1d4659ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed4b0fb2957a3933162b9fc3f386203"><td class="memTemplParams" colspan="2">template&lt;typename L , typename ... T&gt; </td></tr>
<tr class="memitem:ga1ed4b0fb2957a3933162b9fc3f386203"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functor.html#ga1ed4b0fb2957a3933162b9fc3f386203">wrap_lambda</a> (L const &amp;f, T const &amp;...pars) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a34f5637c265f0432130b335c2590345b">detail::wrap_lambda_helper</a>(std::declval&lt; L &gt;(), std::declval&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">detail::function_traits</a>&lt; L &gt;::return_type &gt;(), std::declval&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">detail::function_traits</a>&lt; L &gt;::args_type &gt;(), std::declval&lt; std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(T)&gt;&gt;()))</td></tr>
<tr class="memdesc:ga1ed4b0fb2957a3933162b9fc3f386203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template for wrap a C++11 lambda into a hydra lambda with a certain number of parameters.  <a href="group__functor.html#ga1ed4b0fb2957a3933162b9fc3f386203">More...</a><br /></td></tr>
<tr class="separator:ga1ed4b0fb2957a3933162b9fc3f386203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa81f25675f16b161be78aa2b0cfb307"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:gaaa81f25675f16b161be78aa2b0cfb307"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functor.html#gaaa81f25675f16b161be78aa2b0cfb307">wrap_lambda</a> (L const &amp;f) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a34f5637c265f0432130b335c2590345b">detail::wrap_lambda_helper</a>(std::declval&lt; L &gt;(), std::declval&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">detail::function_traits</a>&lt; L &gt;::return_type &gt;(), std::declval&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">detail::function_traits</a>&lt; L &gt;::args_type &gt;()))</td></tr>
<tr class="memdesc:gaaa81f25675f16b161be78aa2b0cfb307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template for wrap a C++11 lambda into a hydra lambda.  <a href="group__functor.html#gaaa81f25675f16b161be78aa2b0cfb307">More...</a><br /></td></tr>
<tr class="separator:gaaa81f25675f16b161be78aa2b0cfb307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac404982a144cb8c5f101f7cdf503ed7d"><td class="memTemplParams" colspan="2">template&lt;typename ... Iterables&gt; </td></tr>
<tr class="memitem:ac404982a144cb8c5f101f7cdf503ed7d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterables &gt;::value... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(std::declval&lt; Iterables &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()...))&gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac404982a144cb8c5f101f7cdf503ed7d">zip</a> (Iterables &amp;&amp;... iterables)</td></tr>
<tr class="separator:ac404982a144cb8c5f101f7cdf503ed7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad4cdde998c768ff10b49ccf19a1d77c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad4cdde998c768ff10b49ccf19a1d77c8">half</a></td></tr>
<tr class="separator:ad4cdde998c768ff10b49ccf19a1d77c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14adaa26f703b8c130df530167ebd23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab14adaa26f703b8c130df530167ebd23">kFalse</a> = false</td></tr>
<tr class="separator:ab14adaa26f703b8c130df530167ebd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1556536d7a73fa95e5a9c9610f76a3c1">kTrue</a> = true</td></tr>
<tr class="separator:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8371bd525078a66b90577586cd712c"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterable , typename ... Iterables, typename U  = typename std::conditional&lt;sizeof...(Iterables)==0, std::true_type, detail::all_true&lt; detail::is_iterable&lt;Iterables&gt;::value...&gt; &gt;::type&gt; </td></tr>
<tr class="memitem:ga7e8371bd525078a66b90577586cd712c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; Iterable &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; Iterable &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;U::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt;, decltype(std::declval&lt; const Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Iterables &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7e8371bd525078a66b90577586cd712c">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt; const &amp;pdf, Iterable const &amp;points, Iterables const &amp;... weights)</td></tr>
<tr class="memdesc:ga7e8371bd525078a66b90577586cd712c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga7e8371bd525078a66b90577586cd712c">More...</a><br /></td></tr>
<tr class="separator:ga7e8371bd525078a66b90577586cd712c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5afb8f1b6ea1ba2b8fc79444e5d20f20">PrintLevel</a> = <a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td></tr>
<tr class="separator:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a047a920de59b2ead160699c18bee67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9a047a920de59b2ead160699c18bee67">unit</a></td></tr>
<tr class="separator:a9a047a920de59b2ead160699c18bee67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic policies definition. </p>
<p>namespace thrust</p>
<p><code>thrust</code> is the top-level namespace which contains all Hydra functions and types.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>: fix compile error in nvcc adding variants to vectors</dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structhydra_1_1__half" id="structhydra_1_1__half"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1__half">&#9670;&nbsp;</a></span>hydra::_half</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::_half</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;int I&gt;<br />
struct hydra::_half&lt; I &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::_half&lt; I &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1__half__coll__graph.svg" width="130" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a name="structhydra_1_1__unit" id="structhydra_1_1__unit"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1__unit">&#9670;&nbsp;</a></span>hydra::_unit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::_unit</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;int I&gt;<br />
struct hydra::_unit&lt; I &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::_unit&lt; I &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1__unit__coll__graph.svg" width="130" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a name="classhydra_1_1Cache" id="classhydra_1_1Cache"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Cache">&#9670;&nbsp;</a></span>hydra::Cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Cache</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Backend, typename ... Functors&gt;<br />
class hydra::Cache&lt; Backend, Functors &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Cache&lt; Backend, Functors &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Cache__coll__graph.svg" width="178" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GaussKronrodAdaptiveQuadrature" id="classhydra_1_1GaussKronrodAdaptiveQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GaussKronrodAdaptiveQuadrature">&#9670;&nbsp;</a></span>hydra::GaussKronrodAdaptiveQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodAdaptiveQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#_a6">adaptive_gauss_kronrod.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GaussKronrodAdaptiveQuadrature__coll__graph.svg" width="207" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GaussKronrodQuadrature" id="classhydra_1_1GaussKronrodQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GaussKronrodQuadrature">&#9670;&nbsp;</a></span>hydra::GaussKronrodQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="gauss_kronrod_8inl-example.html#_a7">gauss_kronrod.inl</a>, and <a class="el" href="splot_8inl-example.html#_a12">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GaussKronrodQuadrature__coll__graph.svg" width="220" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1GaussKronrodRuleSelector" id="structhydra_1_1GaussKronrodRuleSelector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1GaussKronrodRuleSelector">&#9670;&nbsp;</a></span>hydra::GaussKronrodRuleSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::GaussKronrodRuleSelector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N&gt;<br />
struct hydra::GaussKronrodRuleSelector&lt; N &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodRuleSelector&lt; N &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1GaussKronrodRuleSelector__coll__graph.svg" width="263" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenzMalikQuadrature" id="classhydra_1_1GenzMalikQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenzMalikQuadrature">&#9670;&nbsp;</a></span>hydra::GenzMalikQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND&gt;<br />
class hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multidimensional_fit_8inl-example.html#_a14">multidimensional_fit.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikQuadrature__coll__graph.svg" width="199" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenzMalikRule" id="classhydra_1_1GenzMalikRule"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenzMalikRule">&#9670;&nbsp;</a></span>hydra::GenzMalikRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikRule</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t DIM, typename BACKEND&gt;<br />
class hydra::GenzMalikRule&lt; DIM, BACKEND &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikRule__inherit__graph.svg" width="296" height="287"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikRule__coll__graph.svg" width="162" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1LambdaWrapper" id="classhydra_1_1LambdaWrapper"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1LambdaWrapper">&#9670;&nbsp;</a></span>hydra::LambdaWrapper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::LambdaWrapper</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Sig, typename L, size_t N, typename = typename std::enable_if&lt;std::is_constructible&lt;std::function&lt;Sig&gt;, L&gt;::value&gt;::type&gt;<br />
class hydra::LambdaWrapper&lt; Sig, L, N, typename &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::LambdaWrapper&lt; Sig, L, N, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1LambdaWrapper__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1LogLikelihoodFCN" id="classhydra_1_1LogLikelihoodFCN"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1LogLikelihoodFCN">&#9670;&nbsp;</a></span>hydra::LogLikelihoodFCN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::LogLikelihoodFCN</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename PDF, typename Iterator, typename... Extensions&gt;<br />
class hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1LogLikelihoodFCN__coll__graph.svg" width="206" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1multiarray" id="classhydra_1_1multiarray"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1multiarray">&#9670;&nbsp;</a></span>hydra::multiarray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multiarray</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, size_t N, typename BACKEND&gt;<br />
class hydra::multiarray&lt; T, N, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dense_histogram_8inl-example.html#_a7">dense_histogram.inl</a>, <a class="el" href="multiarray_container_8inl-example.html#_a3">multiarray_container.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#_a16">multidimensional_fit.inl</a>, <a class="el" href="range_semantics_8inl-example.html#_a3">range_semantics.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#_a7">sample_distribution.inl</a>, <a class="el" href="sparse_histogram_8inl-example.html#_a7">sparse_histogram.inl</a>, and <a class="el" href="splot_8inl-example.html#_a15">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Inheritance diagram for hydra::multiarray&lt; T, N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multiarray__inherit__graph.svg" width="246" height="287"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::multiarray&lt; T, N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multiarray__coll__graph.svg" width="146" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1multivector" id="classhydra_1_1multivector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1multivector">&#9670;&nbsp;</a></span>hydra::multivector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multivector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename BACKEND&gt;<br />
class hydra::multivector&lt; T, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multivector_container_8inl-example.html#_a3">multivector_container.inl</a>.</dd>
</dl></div><div class="dynheader">
Inheritance diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector__inherit__graph.svg" width="100%" height="537"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector__coll__graph.svg" width="138" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1null__type" id="structhydra_1_1null__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1null__type">&#9670;&nbsp;</a></span>hydra::null_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::null_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::null_type:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1null__type__coll__graph.svg" width="126" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1Plain" id="structhydra_1_1Plain"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1Plain">&#9670;&nbsp;</a></span>hydra::Plain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::Plain</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt;<br />
struct hydra::Plain&lt; N, BACKEND, GRND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="plain_mc_8inl-example.html#_a6">plain_mc.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Plain&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1Plain__coll__graph.svg" width="198" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Range" id="classhydra_1_1Range"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Range">&#9670;&nbsp;</a></span>hydra::Range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Range</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
class hydra::Range&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Range&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Range__coll__graph.svg" width="142" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Vegas" id="classhydra_1_1Vegas"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Vegas">&#9670;&nbsp;</a></span>hydra::Vegas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Vegas</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt;<br />
class hydra::Vegas&lt; N, BACKEND, GRND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="vegas_8inl-example.html#_a7">vegas.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Vegas&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Vegas__coll__graph.svg" width="206" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Weights" id="classhydra_1_1Weights"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Weights">&#9670;&nbsp;</a></span>hydra::Weights</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Weights</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Backend&gt;<br />
class hydra::Weights&lt; Backend &gt;</h3>

<p>FIXME : add filler methods... </p>
</div><div class="dynheader">
Collaboration diagram for hydra::Weights&lt; Backend &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Weights__coll__graph.svg" width="195" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1WignerD" id="classhydra_1_1WignerD"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1WignerD">&#9670;&nbsp;</a></span>hydra::WignerD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::WignerD</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T1, typename T2, typename T3, unsigned int ArgIndex = 0&gt;<br />
class hydra::WignerD&lt; T1, T2, T3, ArgIndex &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::WignerD&lt; T1, T2, T3, ArgIndex &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1WignerD__coll__graph.svg" width="154" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">&#9670;&nbsp;</a></span>BoolVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&gt; <a class="el" href="namespacehydra.html#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">hydra::BoolVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="group__phsp.html#classhydra_1_1Vector4R" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector. </p>

</div>
</div>
<a id="a274b1c32d255fc13e78a08e96de133f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b1c32d255fc13e78a08e96de133f0">&#9670;&nbsp;</a></span>BoolVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&gt; <a class="el" href="namespacehydra.html#a274b1c32d255fc13e78a08e96de133f0">hydra::BoolVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__phsp.html#classhydra_1_1Vector3R" title="This class represents three-dimensional Euclidian vectors and implements common operation performed o...">Vector3R</a> host vector. </p>
<p>Use it to store four-vectors at <b>hydra_host</b>. </p>

</div>
</div>
<a id="a4f9af1aefe36fa4f80f57289ffb84dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9af1aefe36fa4f80f57289ffb84dca">&#9670;&nbsp;</a></span>complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">hydra::complex</a> = typedef HYDRA_EXTERNAL_NS::thrust::complex&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a10">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a10">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a7670b2993eb064d9c192d9200ab82b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7670b2993eb064d9c192d9200ab82b89">&#9670;&nbsp;</a></span>ComplexVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a>&gt; <a class="el" href="namespacehydra.html#a7670b2993eb064d9c192d9200ab82b89">hydra::ComplexVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GReal_t device vector. </p>

</div>
</div>
<a id="af30019aaf18d88f73acd61f2f363f9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30019aaf18d88f73acd61f2f363f9f6">&#9670;&nbsp;</a></span>ComplexVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a>&gt; <a class="el" href="namespacehydra.html#af30019aaf18d88f73acd61f2f363f9f6">hydra::ComplexVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GReal_t host vector. </p>

</div>
</div>
<a id="a1e747e9ec41024e3efe0349f8ac10062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e747e9ec41024e3efe0349f8ac10062">&#9670;&nbsp;</a></span>default_random_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a1e747e9ec41024e3efe0349f8ac10062">hydra::default_random_engine</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation-defined "default" random number engine. </p>
<dl class="section note"><dt>Note</dt><dd><code>default_random_engine</code> is currently an alias for <code>minstd_rand</code>, and may change in a future version. </dd></dl>

</div>
</div>
<a id="ada2d81895ace081c5204b9adc76a2808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2d81895ace081c5204b9adc76a2808">&#9670;&nbsp;</a></span>FourVectors_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&gt; <a class="el" href="namespacehydra.html#ada2d81895ace081c5204b9adc76a2808">hydra::FourVectors_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for complex number. </p>

</div>
</div>
<a id="aa8c251ed5017d0638da929130062bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c251ed5017d0638da929130062bcad">&#9670;&nbsp;</a></span>GBool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">hydra::GBool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean (0=false, 1=true) (bool) </p>

</div>
</div>
<a id="ae2da2ab0037e6bca3cb7c15adc5c4125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">&#9670;&nbsp;</a></span>GByte_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacehydra.html#ae2da2ab0037e6bca3cb7c15adc5c4125">hydra::GByte_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte (8 bits) (unsigned char) </p>

</div>
</div>
<a id="a7ab04a199389c4989174dc115507fa89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab04a199389c4989174dc115507fa89">&#9670;&nbsp;</a></span>GChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacehydra.html#a7ab04a199389c4989174dc115507fa89">hydra::GChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Character 1 byte (char) </p>

</div>
</div>
<a id="a7ab78a78009fd9969bce04250387d13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab78a78009fd9969bce04250387d13e">&#9670;&nbsp;</a></span>GComplex_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::complex&lt;<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">hydra::GComplex_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af986267d40d932c5cbf0ae874a506f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af986267d40d932c5cbf0ae874a506f83">&#9670;&nbsp;</a></span>GDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#af986267d40d932c5cbf0ae874a506f83">hydra::GDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 8 bytes. </p>

</div>
</div>
<a id="a71bab7b854d7b3c3042fe47201b765eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bab7b854d7b3c3042fe47201b765eb">&#9670;&nbsp;</a></span>GFloat_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="namespacehydra.html#a71bab7b854d7b3c3042fe47201b765eb">hydra::GFloat_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Float 4 bytes (float) </p>

</div>
</div>
<a id="a0c9fb4d7195ab952da10a82d5c4ad30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">&#9670;&nbsp;</a></span>GInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="namespacehydra.html#a0c9fb4d7195ab952da10a82d5c4ad30e">hydra::GInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer 4 bytes (int) </p>

</div>
</div>
<a id="a9d68c21fb715bbfb1edc5b1933b173e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d68c21fb715bbfb1edc5b1933b173e9">&#9670;&nbsp;</a></span>GLong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long long <a class="el" href="namespacehydra.html#a9d68c21fb715bbfb1edc5b1933b173e9">hydra::GLong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable signed long integer 8 bytes. </p>

</div>
</div>
<a id="a5f57a4025b40929c2708cd544c3a1ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f57a4025b40929c2708cd544c3a1ccd">&#9670;&nbsp;</a></span>GLong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespacehydra.html#a5f57a4025b40929c2708cd544c3a1ccd">hydra::GLong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed long integer 4 bytes (long) </p>

</div>
</div>
<a id="a751abe69b482cde879c718fd4775733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751abe69b482cde879c718fd4775733f">&#9670;&nbsp;</a></span>GLongDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a751abe69b482cde879c718fd4775733f">hydra::GLongDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Long Double. </p>

</div>
</div>
<a id="a971e94bcb8c43741d11f9d8eb98f5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971e94bcb8c43741d11f9d8eb98f5fab">&#9670;&nbsp;</a></span>GReal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">hydra::GReal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 16 bytes or float 4 bytes. </p>

</div>
</div>
<a id="a589c60d92ba893c28d814edd6e149a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589c60d92ba893c28d814edd6e149a9c">&#9670;&nbsp;</a></span>GShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef short <a class="el" href="namespacehydra.html#a589c60d92ba893c28d814edd6e149a9c">hydra::GShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Short integer 2 bytes (short) </p>

</div>
</div>
<a id="abc842c1ec8321e9637dee714dcdaebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc842c1ec8321e9637dee714dcdaebff">&#9670;&nbsp;</a></span>GText_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacehydra.html#abc842c1ec8321e9637dee714dcdaebff">hydra::GText_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General string (char) </p>

</div>
</div>
<a id="a51ef97faee95aa79f3839eb7abdf5238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef97faee95aa79f3839eb7abdf5238">&#9670;&nbsp;</a></span>GUChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacehydra.html#a51ef97faee95aa79f3839eb7abdf5238">hydra::GUChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Character 1 byte (unsigned char) </p>

</div>
</div>
<a id="a251a7b1f515ac1ed9409afd67252a32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251a7b1f515ac1ed9409afd67252a32b">&#9670;&nbsp;</a></span>GUInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="namespacehydra.html#a251a7b1f515ac1ed9409afd67252a32b">hydra::GUInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer 4 bytes (unsigned int) </p>

</div>
</div>
<a id="a55e8443cd746900da90cb1f77807e7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e8443cd746900da90cb1f77807e7c0">&#9670;&nbsp;</a></span>GULong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="namespacehydra.html#a55e8443cd746900da90cb1f77807e7c0">hydra::GULong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable unsigned long integer 8 bytes. </p>

</div>
</div>
<a id="abf9a0d54fd4ed46052939549edd086c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a0d54fd4ed46052939549edd086c5">&#9670;&nbsp;</a></span>GULong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="namespacehydra.html#abf9a0d54fd4ed46052939549edd086c5">hydra::GULong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a911a3042526fac189d0c87a089f52955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911a3042526fac189d0c87a089f52955">&#9670;&nbsp;</a></span>GUShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="namespacehydra.html#a911a3042526fac189d0c87a089f52955">hydra::GUShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Short integer 2 bytes (unsigned short) </p>

</div>
</div>
<a id="a648839818fa9d4a58c2195a55a51e773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648839818fa9d4a58c2195a55a51e773">&#9670;&nbsp;</a></span>mc_device_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">hydra::mc_device_vector</a> = typedef HYDRA_EXTERNAL_NS::thrust::device_vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. </p>

</div>
</div>
<a id="a6de6f086a44380382022dafca75de4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de6f086a44380382022dafca75de4c9">&#9670;&nbsp;</a></span>mc_host_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">hydra::mc_host_vector</a> = typedef HYDRA_EXTERNAL_NS::thrust::host_vector&lt;T, HYDRA_EXTERNAL_NS::thrust::system::cuda::experimental::pinned_allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. mc_host_vectot will always allocate page locked memory on CUDA backends in order to maximize speed in memory transfers to the device. </p>

</div>
</div>
<a id="aeccdd58e3a4c27246dadd0930e3fb569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccdd58e3a4c27246dadd0930e3fb569">&#9670;&nbsp;</a></span>minstd_rand</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#aeccdd58e3a4c27246dadd0930e3fb569">hydra::minstd_rand</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>minstd_rand</code> shall produce the value <code>399268537</code> . </dd></dl>

</div>
</div>
<a id="ab7c3603cf7a6c467176d8be9dd2c82fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c3603cf7a6c467176d8be9dd2c82fd">&#9670;&nbsp;</a></span>minstd_rand0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#ab7c3603cf7a6c467176d8be9dd2c82fd">hydra::minstd_rand0</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>minstd_rand0</code> shall produce the value <code>1043618065</code> . </dd></dl>

</div>
</div>
<a id="acf5241d6a56b2040e9cc9ea860b4cbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5241d6a56b2040e9cc9ea860b4cbff">&#9670;&nbsp;</a></span>pair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#acf5241d6a56b2040e9cc9ea860b4cbff">hydra::pair</a> = typedef HYDRA_EXTERNAL_NS::thrust::pair&lt;T1,T2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pair</code> template is an alias to the HYDRA_EXTERNAL_NS::thrust::pair structure. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of <code>pair's</code> first object type. There are no requirements on the type of <code>T1</code>. <code>T1</code>'s type is provided by <code>pair::first_type</code>.</td></tr>
    <tr><td class="paramname">T2</td><td>The type of <code>pair's</code> second object type. There are no requirements on the type of <code>T2</code>. <code>T2</code>'s type is provided by <code>pair::second_type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34184a169c185689e065d0c30f9ffba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34184a169c185689e065d0c30f9ffba">&#9670;&nbsp;</a></span>Particles_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&gt; <a class="el" href="namespacehydra.html#ae34184a169c185689e065d0c30f9ffba">hydra::Particles_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GComplex_t device vector. </p>

</div>
</div>
<a id="a9df2f3d6dc63cf297b0f74ba228f6c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2f3d6dc63cf297b0f74ba228f6c89">&#9670;&nbsp;</a></span>Particles_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&gt; <a class="el" href="namespacehydra.html#a9df2f3d6dc63cf297b0f74ba228f6c89">hydra::Particles_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GComplex_t host vector. </p>

</div>
</div>
<a id="a943a0571fdadbbb4bc9b17ba7ae4b59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943a0571fdadbbb4bc9b17ba7ae4b59b">&#9670;&nbsp;</a></span>ranlux24</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a943a0571fdadbbb4bc9b17ba7ae4b59b">hydra::ranlux24</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements the RANLUX level-3 random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>ranlux24</code> shall produce the value <code>9901578</code> . </dd></dl>

</div>
</div>
<a id="a6950c5abef4e2015f833501684940b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6950c5abef4e2015f833501684940b5d">&#9670;&nbsp;</a></span>ranlux48</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a6950c5abef4e2015f833501684940b5d">hydra::ranlux48</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements the RANLUX level-4 random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>ranlux48</code> shall produce the value <code>88229545517833</code> . </dd></dl>

</div>
</div>
<a id="a79fd090c6e39cfcdd744f369dacffabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fd090c6e39cfcdd744f369dacffabe">&#9670;&nbsp;</a></span>RealVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="namespacehydra.html#a79fd090c6e39cfcdd744f369dacffabe">hydra::RealVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GBool_t device vector. </p>

</div>
</div>
<a id="a6d21da5996b50a240e6f400025e3b139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d21da5996b50a240e6f400025e3b139">&#9670;&nbsp;</a></span>RealVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="namespacehydra.html#a6d21da5996b50a240e6f400025e3b139">hydra::RealVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GBool_t host vector. </p>

</div>
</div>
<a id="a2633cfe1492c02cfb2aef6a79804f191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2633cfe1492c02cfb2aef6a79804f191">&#9670;&nbsp;</a></span>taus88</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a2633cfe1492c02cfb2aef6a79804f191">hydra::taus88</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements L'Ecuyer's 1996 three-component Tausworthe random number generator. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>taus88</code> shall produce the value <code>3535848941</code> . </dd></dl>

</div>
</div>
<a id="a7dcdb1155222988a4250114d880e8b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcdb1155222988a4250114d880e8b46">&#9670;&nbsp;</a></span>ThreeVectors_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&gt; <a class="el" href="namespacehydra.html#a7dcdb1155222988a4250114d880e8b46">hydra::ThreeVectors_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__phsp.html#classhydra_1_1Vector4R" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector. </p>
<p>Use it to store four-vectors at <b>hydra_host</b>. </p>

</div>
</div>
<a id="a5e59cc0127adfac6b799c5fd6785431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e59cc0127adfac6b799c5fd6785431b">&#9670;&nbsp;</a></span>tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b">hydra::tuple</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>tuple</code> template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can be instantiated with a indefinite number of arguments. </p>
<p>Each template argument specifies the type of element in the <code>tuple</code>. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of <code>tuple</code> with two arguments is similar to an instantiation of <code>pair</code> with the same two arguments. Individual elements of a <code>tuple</code> may be accessed with the <code>get</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TN</td><td>The type of the <code>N</code> <code>tuple</code> element.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to create a new <code>tuple</code> object and inspect and modify the value of its elements.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;hydra/tuple.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">// create a tuple containing an int, a float, and a string</span></div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, float, <span class="keyword">const</span> <span class="keywordtype">char</span>*&gt; t(13, 0.1f, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// individual members are accessed with the free function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The first element&#39;s value is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// or the member function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The second element&#39;s value is &quot;</span> &lt;&lt; t.get&lt;1&gt;() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// we can also modify elements with the same function</span></div><div class="line">hydra::get&lt;0&gt;(t) += 10;</div></div><!-- fragment --> 
</div>
</div>
<a id="a3ecb38ba9198aee2de36f374d07638de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecb38ba9198aee2de36f374d07638de">&#9670;&nbsp;</a></span>tuple_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a3ecb38ba9198aee2de36f374d07638de">hydra::tuple_element</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tuple_8h.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; t(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div></div><!-- fragment --><p>This metafunction returns the type of a <code>tuple's</code> <code>N</code>th element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>This parameter selects the element of interest. </td></tr>
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab06a4451f99b94119ead1dcadf2b8e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06a4451f99b94119ead1dcadf2b8e31">&#9670;&nbsp;</a></span>tuple_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#ab06a4451f99b94119ead1dcadf2b8e31">hydra::tuple_size</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This metafunction returns the number of elements of a <code>tuple</code> type of interest. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aed873b1b84fbec3791e721b22a52d1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed873b1b84fbec3791e721b22a52d1fe">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1fea4517ec382985cb7a39393c0da09e58d5"></a>INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26"></a>WARNING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1feadbc96f88184ea3a51f68df95e2b44851"></a>ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1107488f838687e73b39ddd8245f40d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1107488f838687e73b39ddd8245f40d0">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0aae772e8b4c5ada0e1e4c65495702176a"></a>MODE_IMPORTANCE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0a28550661921a3af1306fa74a26b8569c"></a>MODE_IMPORTANCE_ONLY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0acb2c0124fecbf6c1182f1cf7cd9bc37a"></a>MODE_STRATIFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0aba2629d0445cc7ef401fd6793f047da0"></a>BINS_MAX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5e095cca28f6bec603156fd48914aefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e095cca28f6bec603156fd48914aefe">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a256097a85b1ce0eafa6e497f46d87383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256097a85b1ce0eafa6e497f46d87383">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec91f5ec5ff214023b38f72ec4ac1e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec91f5ec5ff214023b38f72ec4ac1e76">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74342b65e8d5baef11d2518da6fae223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74342b65e8d5baef11d2518da6fae223">&#9670;&nbsp;</a></span>apply_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::apply_filter </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a filter to the range [first, last] and return a pair of iterators for the filtered events. </p>
<p>This function will not change the size of the original range, [first, last], but will reorder the entries to put together the accepted entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the begin of the range to filter. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the range to filter. </td></tr>
    <tr><td class="paramname">filter</td><td>Functor returning bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_8inl-example.html#a15">basic_fit.inl</a>, <a class="el" href="basic_fit_range_semantics_8inl-example.html#a15">basic_fit_range_semantics.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a20">extended_logLL_fit.inl</a>, <a class="el" href="fit_gaussian_8C-example.html#a14">fit_gaussian.C</a>, <a class="el" href="fit_johnson_8C-example.html#a14">fit_johnson.C</a>, <a class="el" href="fractional_logLL_fit_8inl-example.html#a19">fractional_logLL_fit.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a20">multidimensional_fit.inl</a>, and <a class="el" href="splot_8inl-example.html#a22">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae96191cbaa62c58f63b7e58924362c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96191cbaa62c58f63b7e58924362c24">&#9670;&nbsp;</a></span>arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a7e65b9bb4aca1f24356f2d43f91bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7e65b9bb4aca1f24356f2d43f91bda">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd779382ac3242158686664a9a3ca3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd779382ac3242158686664a9a3ca3a0">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9772b7e92ecdf60524cde428c1670bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9772b7e92ecdf60524cde428c1670bd4">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24b7bc13880335fdf6964df5034ade29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b7bc13880335fdf6964df5034ade29">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f4e98f986e55037e1a01fe4d9b8fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f4e98f986e55037e1a01fe4d9b8fc8">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::DWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3">hydra::DWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5a1e302e48427c947ab2084811df1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a1e302e48427c947ab2084811df1df">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::FWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1">hydra::FWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0e0a9c294368d8d5b74fb919e261bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e0a9c294368d8d5b74fb919e261bef">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::GWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032">hydra::GWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae223d417259cf7e660fd89a54438d45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae223d417259cf7e660fd89a54438d45b">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::HWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426">hydra::HWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78649879f76b3b52249830df2482980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78649879f76b3b52249830df2482980">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::PWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45">hydra::PWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab59597f876fc220d388f5911bb9822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab59597f876fc220d388f5911bb9822c">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::SWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd">hydra::SWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9d562f964ef193664077363da8859e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d562f964ef193664077363da8859e2">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.begin())</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multiarray_container_8inl-example.html#a4">multiarray_container.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a7e149bee61e4ddabca7fa0aafa121fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e149bee61e4ddabca7fa0aafa121fe1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; C &gt;(c).begin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c64031cbdf1765fdf74577297ddb758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c64031cbdf1765fdf74577297ddb758">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::begin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd4f46840c85ee014f1d237601913ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4f46840c85ee014f1d237601913ae1">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6483cec578e17112f07ba012a4dc50ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6483cec578e17112f07ba012a4dc50ed">&#9670;&nbsp;</a></span>begin() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe8c272359dca5fb49f5a76d4cf93451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8c272359dca5fb49f5a76d4cf93451">&#9670;&nbsp;</a></span>begin() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f1cb0e2e3473d8e25b079dd72b8bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1cb0e2e3473d8e25b079dd72b8bc8a">&#9670;&nbsp;</a></span>begin() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39ca77c714b3e8b913c37d323cfd5640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ca77c714b3e8b913c37d323cfd5640">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1de9e4fabdb747b9e3352ef6298476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1de9e4fabdb747b9e3352ef6298476">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>boost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae19bb84d35c2b4edaea63abe6c1298ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19bb84d35c2b4edaea63abe6c1298ef">&#9670;&nbsp;</a></span>chebychev_1st_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::chebychev_1st_kind </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of first kind \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[P_{n+1}(x) = 2xP_n(x)-P_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a610d6c3636b0ee33dcebe0f10bb9d7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d6c3636b0ee33dcebe0f10bb9d7d1">&#9670;&nbsp;</a></span>chebychev_2nd_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::chebychev_2nd_kind </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of second kind \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n+1}(x) = 2xP_n(x) - P_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad7e8cd28634fb5e58ded42387beb6703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e8cd28634fb5e58ded42387beb6703">&#9670;&nbsp;</a></span>Chebyshev_polynomial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ std::enable_if&lt;N==0, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; hydra::Chebyshev_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabb49a5479f420438ed05226f53aba61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb49a5479f420438ed05226f53aba61">&#9670;&nbsp;</a></span>Chebyshev_polynomial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ std::enable_if&lt;N==1, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; hydra::Chebyshev_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba2e51621fdfc76eb1b18fb93060eab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2e51621fdfc76eb1b18fb93060eab4">&#9670;&nbsp;</a></span>Chebyshev_polynomial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ std::enable_if&lt; (N&gt;2) , <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; hydra::Chebyshev_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a014b131fb12345722ffb14274f76b8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014b131fb12345722ffb14274f76b8e6">&#9670;&nbsp;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Index , typename Iterable_Values &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::collect </td>
          <td>(</td>
          <td class="paramtype">Iterable_Index &amp;&#160;</td>
          <td class="paramname"><em>indexing_scheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Values &amp;&#160;</td>
          <td class="paramname"><em>collected_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Index&gt;::value
					    &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Values&gt;::value,
<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::permutation_iterator&lt;
		decltype(std::declval&lt;Iterable_Values&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),
		decltype(std::declval&lt;Iterable_Index&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;
&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec19ef09aa95bbdb2230bd31d879b94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec19ef09aa95bbdb2230bd31d879b94d">&#9670;&nbsp;</a></span>columns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;	<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt;T,N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;const&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a7">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac897e7fcbfbb068d5d29122253491201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac897e7fcbfbb068d5d29122253491201">&#9670;&nbsp;</a></span>columns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt;T,N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;&amp;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a361c44c79db73248056ed6b5dec531e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361c44c79db73248056ed6b5dec531e3">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 , typename ... Ts, typename  = typename std::enable_if&lt;T0::is_functor::value &amp;&amp;								 T1::is_functor::value &amp;&amp;								 detail::all_true&lt;Ts::is_functor::value...&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1Compose.html">Compose</a>&lt;T0,T1,Ts...&gt; hydra::compose </td>
          <td>(</td>
          <td class="paramtype">T0 const &amp;&#160;</td>
          <td class="paramname"><em>F0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts const &amp;...&#160;</td>
          <td class="paramname"><em>Fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a27">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a27">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ad2ffe3ace108474a31b8cb84ceae7f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ffe3ace108474a31b8cb84ceae7f14">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab52f376acf56fca42cc13e010498c668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52f376acf56fca42cc13e010498c668">&#9670;&nbsp;</a></span>constant_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::constant_iterator&lt;Value_Type&gt; &gt; hydra::constant_range </td>
          <td>(</td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e92ed315afaaf9c66edd4739e345daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e92ed315afaaf9c66edd4739e345daf">&#9670;&nbsp;</a></span>convolute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int ArgIndex, typename Functor , typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::convolute </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kernel const &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>kmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nsamples</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classhydra_1_1Convolution.html">Convolution</a>&lt;Functor, Kernel, ArgIndex&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b928198a46f83eb9d2793e8e079ba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b928198a46f83eb9d2793e8e079ba5a">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value&amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::copy </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_distributions_8inl-example.html#a3">basic_distributions.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a9">sample_distribution.inl</a>, and <a class="el" href="splot_8inl-example.html#a19">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a82497912f037617b630d048bfcc515c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82497912f037617b630d048bfcc515c0">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a17">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a17">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac9aa7456a15f61cd1ed2b5ef7227409e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9aa7456a15f61cd1ed2b5ef7227409e">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d55d71b4eca1da2fac83a615ea4b990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d55d71b4eca1da2fac83a615ea4b990">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31ec2838ed0b3d9f3e77d8b51f270c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ec2838ed0b3d9f3e77d8b51f270c81">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::distance </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( HYDRA_EXTERNAL_NS::thrust::distance&lt;Iterator&gt;(first,last))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd869e5bd355b1c4646e2c5e1f4ed332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd869e5bd355b1c4646e2c5e1f4ed332">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;T1,T2&gt; hydra::divide </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4274268d147e9a988f379326b73682b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4274268d147e9a988f379326b73682b0">&#9670;&nbsp;</a></span>end() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.end())</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a7">adaptive_gauss_kronrod.inl</a>, <a class="el" href="dalitz_plot_8C-example.html#a33">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a33">dalitz_plot.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a8">gauss_kronrod.inl</a>, <a class="el" href="multiarray_container_8inl-example.html#a6">multiarray_container.inl</a>, <a class="el" href="phsp_averaging_functor_8inl-example.html#a8">phsp_averaging_functor.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a7">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a15">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a7">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a6">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#a7">phsp_unweighting_functor.inl</a>, and <a class="el" href="plain_mc_8inl-example.html#a7">plain_mc.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a1d1cd86c2f2c422730b87a5890dbaee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1cd86c2f2c422730b87a5890dbaee3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; C &gt;(c).end())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e7ed93e81eae920f0c85fea012dc23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7ed93e81eae920f0c85fea012dc23c">&#9670;&nbsp;</a></span>end() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::end </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f64a7db637f2f1865093311d69f0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f64a7db637f2f1865093311d69f0bc">&#9670;&nbsp;</a></span>end() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab07ef1a981144fec2ec0227a346bedf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07ef1a981144fec2ec0227a346bedf8">&#9670;&nbsp;</a></span>end() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f434b6fb7d95b6ca2a386e25e6b6733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f434b6fb7d95b6ca2a386e25e6b6733">&#9670;&nbsp;</a></span>end() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4f44ac4277e27b370317451862a091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f44ac4277e27b370317451862a091d">&#9670;&nbsp;</a></span>end() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5acb87c4eb594ddbf0c4322a11cf4d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb87c4eb594ddbf0c4322a11cf4d8a">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a2">adaptive_gauss_kronrod.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a1">dense_histogram.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a2">gauss_kronrod.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a11">multidimensional_fit.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a2">plain_mc.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a1">sample_distribution.inl</a>, <a class="el" href="sparse_histogram_8inl-example.html#a1">sparse_histogram.inl</a>, and <a class="el" href="vegas_8inl-example.html#a2">vegas.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ab056ed3df61b0755f67d96f8537c657f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab056ed3df61b0755f67d96f8537c657f">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::for_each </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a10">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a75feeef216747fa3b7c90b590f2761e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75feeef216747fa3b7c90b590f2761e8">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Map&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::gather </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Map &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a878a4b407da6caf1173b3939f3943d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878a4b407da6caf1173b3939f3943d33">&#9670;&nbsp;</a></span>get() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tuple_8h.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; t(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
<a id="a7c5d06da4c888dd9915f5b9b68ff324d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5d06da4c888dd9915f5b9b68ff324d">&#9670;&nbsp;</a></span>get() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b44fb8fa5030736b4603699cf172253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b44fb8fa5030736b4603699cf172253">&#9670;&nbsp;</a></span>get() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::pair&lt;T1,T2&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2658beb74af1f617373f6f640e2949e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2658beb74af1f617373f6f640e2949e4">&#9670;&nbsp;</a></span>get() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af63079c411073c082f1099994bd539af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63079c411073c082f1099994bd539af">&#9670;&nbsp;</a></span>get() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9bd95a2e510a972665cc8e93abb7ad00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd95a2e510a972665cc8e93abb7ad00">&#9670;&nbsp;</a></span>get() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7582acf570b53c033d52c6ff0fecb43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7582acf570b53c033d52c6ff0fecb43e">&#9670;&nbsp;</a></span>GetFormatedString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hydra::GetFormatedString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7640497da0f9e58a93fbb73a130008af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7640497da0f9e58a93fbb73a130008af">&#9670;&nbsp;</a></span>hermite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::hermite </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Hermite polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n + 1}(x) = 2xP_n(x) - 2nP_{n - 1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae56f5771a38cd48141f2e02712ac025f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56f5771a38cd48141f2e02712ac025f">&#9670;&nbsp;</a></span>jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>P_{n-1}^{(,)}(z) - 2 (n+ - 1) (n + -1) (2n+ + ) P_{n-2}^{(, )}(z), {align}&lt;/math&gt; </p>
<p>for ''n'' = 2, 3, .... </p>

</div>
</div>
<a id="a9fcbd1b972dcec1554ce96916da38a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcbd1b972dcec1554ce96916da38a6f">&#9670;&nbsp;</a></span>laguerre()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::laguerre </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Laguerre polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n + 1}(x) = \frac{(2n + 1 - x)P_n(x) - n P_{n - 1}(x)}{n + 1} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a17470c2d2376f96c63d7c89ed6b6cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17470c2d2376f96c63d7c89ed6b6cd5c">&#9670;&nbsp;</a></span>legendre() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::legendre </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Legendre polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ (n+1)P_{n+1}(x) = (2n+1)xP_{n}(x) - nP_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a35a58122210680157c763df0d84203f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a58122210680157c763df0d84203f2">&#9670;&nbsp;</a></span>legendre() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T hydra::legendre </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Legendre polynomials \( P_n(n) \) using the recursive relation (Bonnet’s recursion formula) </p>
<p class="formulaDsp">
\[ (n+1)P_{n+1}(x) = (2n+1)xP_{n}(x) - nP_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a2725e178af11595cbeba053c1f84dfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2725e178af11595cbeba053c1f84dfa8">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64d53a33e43032b9e482284fd1a38b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d53a33e43032b9e482284fd1a38b08">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a245247898bcad6233daf9f9fe49bbffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245247898bcad6233daf9f9fe49bbffa">&#9670;&nbsp;</a></span>make_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Functors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::make_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functors &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Cache">Cache</a>&lt;<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, Functors...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9c36400392fc1613db3bcabd7c74575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c36400392fc1613db3bcabd7c74575">&#9670;&nbsp;</a></span>make_chain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ... N, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__phsp.html#classhydra_1_1Chains">Chains</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt;N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;...&gt; hydra::make_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2864fe6d4fb9b0015aeda0dd27b6389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2864fe6d4fb9b0015aeda0dd27b6389">&#9670;&nbsp;</a></span>make_decays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt;N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt; &gt; hydra::make_decays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a956732407bfa5db6dd53fb7a1bb7062b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956732407bfa5db6dd53fb7a1bb7062b">&#9670;&nbsp;</a></span>make_loglikehood_fcn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename Integrator , typename Iterable , typename ... Iterables, typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt;Iterable&gt;::value) &amp;&amp; (!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt;Iterable&gt;::value) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; U::value,<a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt;Functor,Integrator&gt;, decltype(std::declval&lt; const Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Iterables&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type hydra::make_loglikehood_fcn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, Integrator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterables const &amp;...&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b9fd25a44634ab41c7c102a97e42cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b9fd25a44634ab41c7c102a97e42cb">&#9670;&nbsp;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::make_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_pair( std::forward&lt;T1&gt;(t1),std::forward&lt;T2&gt;(t2) ))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>The first object to copy from. </td></tr>
    <tr><td class="paramname">T2</td><td>The second object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> object with members which are copies of <code>t</code>. </dd></dl>

</div>
</div>
<a id="aca7f979949a9340e95660a70b83358dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7f979949a9340e95660a70b83358dd">&#9670;&nbsp;</a></span>make_range() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator, Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed731c061feb7b22667628e351da610b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed731c061feb7b22667628e351da610b">&#9670;&nbsp;</a></span>make_range() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt; hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a34">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a34">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a848831bc77a005363d36d66a5a76dab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848831bc77a005363d36d66a5a76dab9">&#9670;&nbsp;</a></span>make_range() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb94a482290a0c2c1764865e7d16dcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb94a482290a0c2c1764865e7d16dcf8">&#9670;&nbsp;</a></span>make_range() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a997423cc7da26ee78b795e07a6910c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997423cc7da26ee78b795e07a6910c29">&#9670;&nbsp;</a></span>make_range() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad41a92d68bff7650655ef587d27611c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41a92d68bff7650655ef587d27611c4">&#9670;&nbsp;</a></span>make_range() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8920bd6c86e10092b7f5f0a3ac594f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8920bd6c86e10092b7f5f0a3ac594f0c">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::reverse_iterator&lt;Iterator&gt;, Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b6560e735b887aef4c3e73e342f5994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6560e735b887aef4c3e73e342f5994">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::reverse_iterator&lt;Iterator&gt; &gt; hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8be66889f53db6bbae8365d509c13cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be66889f53db6bbae8365d509c13cd1">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bd548971df59145c8bcf4db33538645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd548971df59145c8bcf4db33538645">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdb731a7ec634ab03b448a6cc6230d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb731a7ec634ab03b448a6cc6230d68">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1391215774750e4ae5daf419b5768c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1391215774750e4ae5daf419b5768c7b">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2f3da2c2a9505237640a47c3e088fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f3da2c2a9505237640a47c3e088fae">&#9670;&nbsp;</a></span>make_sparse_histogram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;::type hydra::make_sparse_histogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; size_t, N &gt;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lowerlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>upperlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34c92f763d48eb14a538692a07da5e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c92f763d48eb14a538692a07da5e38">&#9670;&nbsp;</a></span>make_sparse_histogram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;::type hydra::make_sparse_histogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lowerlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>upperlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5314ace45b4baa7084a9addb625ca99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5314ace45b4baa7084a9addb625ca99">&#9670;&nbsp;</a></span>make_splot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1SPlot.html">SPlot</a>&lt;PDF1, PDF2, PDFs...&gt; hydra::make_splot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="splot_8inl-example.html#a26">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac70a2baeff9ebf89f64ebd08ebaab2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70a2baeff9ebf89f64ebd08ebaab2d7">&#9670;&nbsp;</a></span>make_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(t...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The first object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are copies of <code>t</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a29">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a29">dalitz_plot.inl</a>, <a class="el" href="multiarray_container_8inl-example.html#a1">multiarray_container.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a25">multidimensional_fit.inl</a>, <a class="el" href="multivector_container_8inl-example.html#a1">multivector_container.inl</a>, and <a class="el" href="phsp_basic_8inl-example.html#a5">phsp_basic.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a16ca94258b9800a2b2fe700f7012f545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ca94258b9800a2b2fe700f7012f545">&#9670;&nbsp;</a></span>make_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple( std::forward&lt;T&gt;(t)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The first object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are copies of <code>t</code>. </dd></dl>

</div>
</div>
<a id="a42b91350feefa178d4403a6e8b92e97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b91350feefa178d4403a6e8b92e97b">&#9670;&nbsp;</a></span>Make_WignerD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int ArgIndex = 0, template&lt; int &gt; class T, int J, int M, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1WignerD">WignerD</a>&lt;T&lt;J&gt;, T&lt;M&gt;, T&lt;N&gt;, ArgIndex&gt; hydra::Make_WignerD </td>
          <td>(</td>
          <td class="paramtype">T&lt; J &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&lt; M &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdb8665ee28f5e766b614992c0491dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb8665ee28f5e766b614992c0491dd7">&#9670;&nbsp;</a></span>minus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;T1,T2&gt; hydra::minus </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a237ae37875016b34f82e3664703be679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237ae37875016b34f82e3664703be679">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;F1,F2,Fs...&gt; hydra::multiply </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f06ee4cd16c4cd697a380053748bf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f06ee4cd16c4cd697a380053748bf67">&#9670;&nbsp;</a></span>nint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classint">int</a> hydra::nint </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round to nearest integer. </p>
<p>Rounds half integers to the nearest even integer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab5fd2d8f62c3075ccdd36241e8dc6881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fd2d8f62c3075ccdd36241e8dc6881">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a26">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a26">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a24943c0d2419a40a68f0fb61e0a1b05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24943c0d2419a40a68f0fb61e0a1b05f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a716c80436ab96c757325cae3cd517960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716c80436ab96c757325cae3cd517960">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91d952f42e31697e4b457b1a58424cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d952f42e31697e4b457b1a58424cb5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74f09f60eaa232f756f2e5ee0ccb5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f09f60eaa232f756f2e5ee0ccb5326">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa51499fa04d39681eb6244313d32a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51499fa04d39681eb6244313d32a16c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a258cacce52e3670d4880af1576a16a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258cacce52e3670d4880af1576a16a22">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad01febd59c4dfebc87b5d363955d65db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01febd59c4dfebc87b5d363955d65db">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa868eaf400c854297996c269f401e69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa868eaf400c854297996c269f401e69e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;T1,T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dce6130507b07eaac142c1815ade3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dce6130507b07eaac142c1815ade3f2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2021f911a26d3c79b62d1a2f1fa9dcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2021f911a26d3c79b62d1a2f1fa9dcf0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd42c2a636a5bfb4e605ddd9f1ea069a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd42c2a636a5bfb4e605ddd9f1ea069a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa9d6d9136eecf2c929dd9b12356d833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9d6d9136eecf2c929dd9b12356d833">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5bae5caa4d9b5c0190220e55f650859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bae5caa4d9b5c0190220e55f650859">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2b0be1f22ac4914bd6ce0bc97411bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0be1f22ac4914bd6ce0bc97411bff">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb096b020e55914fe7a1e885dd66b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb096b020e55914fe7a1e885dd66b17e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31bdba87b791f8a68e8571eaa00788cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bdba87b791f8a68e8571eaa00788cd">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b98f3604eca3a6023551cd4ce98020a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b98f3604eca3a6023551cd4ce98020a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac480ecaec81a0040f3b466ca5904ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac480ecaec81a0040f3b466ca5904ed5b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0bc15a0070c95cad2a9b6e300b430cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bc15a0070c95cad2a9b6e300b430cc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81ab71f63c56b41e970fee5c7fa48915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ab71f63c56b41e970fee5c7fa48915">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;T1, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58bc87dddca38c44ed5276eedb78a176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bc87dddca38c44ed5276eedb78a176">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd8f4a42269c2f7b4316a413efe5190e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8f4a42269c2f7b4316a413efe5190e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1fc13eb2a4a440f72991b4347a472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1fc13eb2a4a440f72991b4347a472c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a781df21a8dca74210f8dc39b340b58ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781df21a8dca74210f8dc39b340b58ec">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af68a4c9bed0e1a2cf2ed9ba9ab057dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68a4c9bed0e1a2cf2ed9ba9ab057dd0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26e3492eb046c39e1b578738cd5ad7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e3492eb046c39e1b578738cd5ad7b7">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a357a28a5ec78cd838e8e90face792425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357a28a5ec78cd838e8e90face792425">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e6b67d073431ddbbc9df286683b6391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6b67d073431ddbbc9df286683b6391">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;T1,T2&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab209688d56c7888c7fb173e06b4a63b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab209688d56c7888c7fb173e06b4a63b8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0ab9137952e574434bb5457b5e7624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ab9137952e574434bb5457b5e7624b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;T2,<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt; &gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1113b35a5588af8a55453fbd5e1b2651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1113b35a5588af8a55453fbd5e1b2651">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28b7a7b4b2afa53b5b17883d43c6635b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b7a7b4b2afa53b5b17883d43c6635b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a950f2d5dc4356f6c6c13b9fc3bc7c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950f2d5dc4356f6c6c13b9fc3bc7c0ef">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68375d62444cb2341ade99f0ac15972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68375d62444cb2341ade99f0ac15972f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07c46e4c59a5208f5d495b4ddaf3af75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c46e4c59a5208f5d495b4ddaf3af75">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a247f457807559c67d34c5b9d15c0b4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247f457807559c67d34c5b9d15c0b4b4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fa3a711732edb66303a415b0053ab30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa3a711732edb66303a415b0053ab30">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;T1,T2&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51adfe83d6139c094696c576cac08eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51adfe83d6139c094696c576cac08eb9">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73f958068c4dcdbb79b40925e2da4b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f958068c4dcdbb79b40925e2da4b24">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;T2,<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt; &gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94cb4a79113148abd78aa8e4d6f7e41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cb4a79113148abd78aa8e4d6f7e41d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4db4d6d0e3fe03dccf661b7ac0751fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db4d6d0e3fe03dccf661b7ac0751fe7">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61779a5f2bd6e73c2808fc388b3aa496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61779a5f2bd6e73c2808fc388b3aa496">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9b1664e58d41d5f8e7ec6d1c20bf9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b1664e58d41d5f8e7ec6d1c20bf9c0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a4133d480d7e9f3f5e85286e47a3709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4133d480d7e9f3f5e85286e47a3709">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af29cde1e70c62bec6f1fa1ee52940887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29cde1e70c62bec6f1fa1ee52940887">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15cdb083719133399edb77f5ef3eb547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cdb083719133399edb77f5ef3eb547">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fab8d226ee701c0755c60202fc30f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fab8d226ee701c0755c60202fc30f6c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d7f13d811f0d63d4ce49d31b6cfbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d7f13d811f0d63d4ce49d31b6cfbe0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa8037907332bf633dfc1bc3b40865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa8037907332bf633dfc1bc3b40865c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaacce78528c9499de97312cbe606ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacce78528c9499de97312cbe606ece4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3be8e63c60c604b927f9638600a598b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3be8e63c60c604b927f9638600a598b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a> const &amp;&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classhydra_1_1Print.html">Print</a> the ROOT::Minuit2 state to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>std::ostream </td></tr>
    <tr><td class="paramname">par</td><td><a class="el" href="group__fit.html#classhydra_1_1UserParameters" title="Class implementing a interface to ROOT::Minuit2::MnUserParameters. ">hydra::UserParameters</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a21d7262b80d73f956ed1a477607b9053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d7262b80d73f956ed1a477607b9053">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , class charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT,traits &gt;&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb57654e359a17e312e9aef986f956a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb57654e359a17e312e9aef986f956a8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea70aec01321527f54717a004a3df99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea70aec01321527f54717a004a3df99d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a227370a3dddcea864f09490bc65b93ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227370a3dddcea864f09490bc65b93ad">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99bf5390aa3ab39e8ac0cd109ef6b7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bf5390aa3ab39e8ac0cd109ef6b7c9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc9da09d22eae43ed970a123baa27f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc9da09d22eae43ed970a123baa27f1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3bafbf7fa6e97bc40b02d74d7d596ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bafbf7fa6e97bc40b02d74d7d596ea">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a0907b93c595507fbd2ea319f2f5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a0907b93c595507fbd2ea319f2f5d6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ad8f84031200c3161c889507d3a9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ad8f84031200c3161c889507d3a9c0">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; charT,traits &gt;&amp; hydra::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac84130bc318145449957a91e45dea963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84130bc318145449957a91e45dea963">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt; const Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::operator| </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab959ec5340fe7f85b886795bc75debc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab959ec5340fe7f85b886795bc75debc4">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::operator| </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acedbe70d8eee7cd7fc27e1b7710e3d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedbe70d8eee7cd7fc27e1b7710e3d99">&#9670;&nbsp;</a></span>phase_space_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1GenerateDecay.html">detail::GenerateDecay</a>&lt;N,HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt;, HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt;size_t&gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt;<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type</a>&lt;N,<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&gt;::type&gt;::type&gt; &gt; hydra::phase_space_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> const &amp;&#160;</td>
          <td class="paramname"><em>mother</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;&#160;</td>
          <td class="paramname"><em>masses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nentries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a11">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae85d86e6980bcf24de91a003711b3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85d86e6980bcf24de91a003711b3224">&#9670;&nbsp;</a></span>pmf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::pmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>mother_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>daughter1_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>daughter2_mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Momentum in mother frame of daughter particle in two-body-decay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mother_mass</td><td></td></tr>
    <tr><td class="paramname">daughter1_mass</td><td></td></tr>
    <tr><td class="paramname">daughter2_mass</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae3cc52fabc8882be13d9a6ca92fc648e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cc52fabc8882be13d9a6ca92fc648e">&#9670;&nbsp;</a></span>polar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::polar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95aad7e7e244a3cb3c71a4d57e695511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95aad7e7e244a3cb3c71a4d57e695511">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power with integer exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac2256bff965f5a7359591579a97114ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2256bff965f5a7359591579a97114ec">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a30">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a30">dalitz_plot.inl</a>, <a class="el" href="gaussian_plus_argus_8inl-example.html#a15">gaussian_plus_argus.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a1">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a1">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a1">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a1">phsp_unweighting.inl</a>, and <a class="el" href="phsp_unweighting_functor_8inl-example.html#a1">phsp_unweighting_functor.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a4cf806d100f53f6d281b8b826697e10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf806d100f53f6d281b8b826697e10f">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e9146d77dfa5b6c0fcbcb31557f6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9146d77dfa5b6c0fcbcb31557f6854">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5e9dc190c08a69b225d320ab8da1582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e9dc190c08a69b225d320ab8da1582">&#9670;&nbsp;</a></span>pow() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adddd0dd31b59ee6d761eccb6cd78b452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddd0dd31b59ee6d761eccb6cd78b452">&#9670;&nbsp;</a></span>pow() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab57b4e7a8e408d4e545f46a2c1923cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57b4e7a8e408d4e545f46a2c1923cd5">&#9670;&nbsp;</a></span>pow() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb0c9817024c69efe44c2d9653928519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0c9817024c69efe44c2d9653928519">&#9670;&nbsp;</a></span>PrintToStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::PrintToStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace0454750e3561d390ee18b96824227c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0454750e3561d390ee18b96824227c">&#9670;&nbsp;</a></span>proj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::proj </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ea894534fd9a24f2369d9b71d9f586f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea894534fd9a24f2369d9b71d9f586f">&#9670;&nbsp;</a></span>random_exp_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt;<a class="el" href="structhydra_1_1detail_1_1RndExp.html">detail::RndExp</a>&lt;Value_Type, HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt; ,HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt;size_t&gt;, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt; hydra::random_exp_range </td>
          <td>(</td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af70f8b5bd9c76734b552d9b1ecf7dbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70f8b5bd9c76734b552d9b1ecf7dbce">&#9670;&nbsp;</a></span>random_gauss_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt;<a class="el" href="structhydra_1_1detail_1_1RndGauss.html">detail::RndGauss</a>&lt;Value_Type, HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt; ,HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt;size_t&gt;, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt; hydra::random_gauss_range </td>
          <td>(</td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eb2860f22ab94494447bacfcdd01ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb2860f22ab94494447bacfcdd01ebc">&#9670;&nbsp;</a></span>random_uniform_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::transform_iterator&lt;<a class="el" href="structhydra_1_1detail_1_1RndUniform.html">detail::RndUniform</a>&lt;Value_Type, HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt; ,HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt;size_t&gt;, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt; hydra::random_uniform_range </td>
          <td>(</td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cd814fb01cd9d4d7ca9fa8c289627d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd814fb01cd9d4d7ca9fa8c289627d9">&#9670;&nbsp;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;HYDRA_EXTERNAL_NS::thrust::counting_iterator&lt;long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&gt; &gt; hydra::range </td>
          <td>(</td>
          <td class="paramtype">long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_8inl-example.html#a14">basic_fit.inl</a>, <a class="el" href="basic_fit_range_semantics_8inl-example.html#a14">basic_fit_range_semantics.inl</a>, <a class="el" href="breit_wigner_plus_polynomial_8inl-example.html#a14">breit_wigner_plus_polynomial.inl</a>, <a class="el" href="crystal_ball_plus_exponential_8inl-example.html#a15">crystal_ball_plus_exponential.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a8">dense_histogram.inl</a>, <a class="el" href="double_gaussian_plus_exponential_8inl-example.html#a14">double_gaussian_plus_exponential.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a19">extended_logLL_fit.inl</a>, <a class="el" href="fit_gaussian_8C-example.html#a13">fit_gaussian.C</a>, <a class="el" href="fit_johnson_8C-example.html#a13">fit_johnson.C</a>, <a class="el" href="fractional_logLL_fit_8inl-example.html#a18">fractional_logLL_fit.inl</a>, <a class="el" href="gaussian_plus_argus_8inl-example.html#a16">gaussian_plus_argus.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a19">multidimensional_fit.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a8">sample_distribution.inl</a>, <a class="el" href="sparse_histogram_8inl-example.html#a8">sparse_histogram.inl</a>, and <a class="el" href="splot_8inl-example.html#a21">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a589e3fc7f3e94613126a8198bf90dd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e3fc7f3e94613126a8198bf90dd59">&#9670;&nbsp;</a></span>Range&lt; iterator_type &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; iterator_type &gt; </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>begin</em>cls..., </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>end</em>cls...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> decltype( other.begin(cls...)) iterator_type</div></div><!-- fragment -->
</div>
</div>
<a id="aadcca49207bf7ab79088f28cddb8f21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcca49207bf7ab79088f28cddb8f21d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; C &gt;(c).rbegin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a434c6a6c1a24dbd8ca880af38694803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434c6a6c1a24dbd8ca880af38694803d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.rbegin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d87c9638b5f275d1fbbef560a3c0197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d87c9638b5f275d1fbbef560a3c0197">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69daea4927958e8a666ee6ed3a795cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69daea4927958e8a666ee6ed3a795cbd">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a932ef4185794129e04c9a4220db464eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932ef4185794129e04c9a4220db464eb">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68b257293c03a3475bb28e9575e941ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b257293c03a3475bb28e9575e941ad">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2906e8baa707b7e3cbe3ab1c1aa3fa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2906e8baa707b7e3cbe3ab1c1aa3fa7c">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabb5af6bb519cee99d2be4238767f8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb5af6bb519cee99d2be4238767f8f3">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,typename HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value_type &gt;::type hydra::reduce </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b9d5a2744d5acc0852b40f5262eb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b9d5a2744d5acc0852b40f5262eb17">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor , typename T  = typename HYDRA_EXTERNAL_NS::thrust::iterator_traits&lt;		     decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, T &gt;::type hydra::reduce </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>binary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58e00797465282d00eeaf0cd82d1c076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e00797465282d00eeaf0cd82d1c076">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; C &gt;(c).rend())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48be0e2a44047208c68e2c096683db35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48be0e2a44047208c68e2c096683db35">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.rend())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f3625ffa0bf89a7d056a0d2b226e882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3625ffa0bf89a7d056a0d2b226e882">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::rend </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad79366fdc5ac96950ef240f03e0321b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79366fdc5ac96950ef240f03e0321b5">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a175fc3749a8859251e455ea11b8739f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175fc3749a8859251e455ea11b8739f8">&#9670;&nbsp;</a></span>rend() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53513fea217a83151a1c98692a1bdbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53513fea217a83151a1c98692a1bdbc7">&#9670;&nbsp;</a></span>rend() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96fc64d77a9d74b4606c449937491181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fc64d77a9d74b4606c449937491181">&#9670;&nbsp;</a></span>rend() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dff93eff6900d6a3aa93db92e8ba065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dff93eff6900d6a3aa93db92e8ba065">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::reverse_iterator&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt; &gt;::type hydra::reverse </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad27ce158f82bfcf3ba0855a224a3f626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27ce158f82bfcf3ba0855a224a3f626">&#9670;&nbsp;</a></span>rint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::rint </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a9e21c7083ea65e58667297a801f0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9e21c7083ea65e58667297a801f0c0">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9637ed446b2f89c3514f57bac1fd1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9637ed446b2f89c3514f57bac1fd1be">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>ksi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b62f11052cf4a8e258b21b9f64f0c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b62f11052cf4a8e258b21b9f64f0c6d">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Map&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::scatter </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Map &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb7d0e5da38544692eb3545e81617e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7d0e5da38544692eb3545e81617e19">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a18">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a18">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="af59c474655ecd14c6748391d80e2e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59c474655ecd14c6748391d80e2e4c2">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b6b3a330b6d16d3221bb7b994b9329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b3a330b6d16d3221bb7b994b9329b">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac64c757c35da63a927af0ad5147ac7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64c757c35da63a927af0ad5147ac7c5">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34662231e9292fda55e3a182ea5d342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34662231e9292fda55e3a182ea5d342a">&#9670;&nbsp;</a></span>sort_by_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterable_Key , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Iterator_Key  = decltype(std::declval&lt;Iterable_Key&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Iterator_Key&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Key &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a6">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="af234f162ec15ef9dc4b42cbe31039487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af234f162ec15ef9dc4b42cbe31039487">&#9670;&nbsp;</a></span>sort_by_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterator_Key , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Range&lt;Iterator_Key,Functor&gt;&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator_Key, Functor &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74988a829019bf111e7f51d81b33eec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74988a829019bf111e7f51d81b33eec7">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a3">adaptive_gauss_kronrod.inl</a>, <a class="el" href="binned_extended_logLL_fit_8inl-example.html#a13">binned_extended_logLL_fit.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a2">dense_histogram.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a13">extended_logLL_fit.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a3">gauss_kronrod.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a12">multidimensional_fit.inl</a>, <a class="el" href="phsp_averaging_functor_8inl-example.html#a3">phsp_averaging_functor.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a4">phsp_chain.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a3">plain_mc.inl</a>, <a class="el" href="range_semantics_8inl-example.html#a2">range_semantics.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a2">sample_distribution.inl</a>, <a class="el" href="sparse_histogram_8inl-example.html#a2">sparse_histogram.inl</a>, <a class="el" href="splot_8inl-example.html#a11">splot.inl</a>, and <a class="el" href="vegas_8inl-example.html#a3">vegas.inl</a>.</dd>
</dl>
</div>
</div>
<a id="aa792627bbf68dd5d3c3d969c3462808f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa792627bbf68dd5d3c3d969c3462808f">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array streamer helper </p>

</div>
</div>
<a id="a6b2446e6e58a2466b66c1277d67075ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2446e6e58a2466b66c1277d67075ad">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa8b42796ae70a6c34b6871a8755b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8b42796ae70a6c34b6871a8755b382">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tuple streamer helper </p>

</div>
</div>
<a id="af0ba407638beac5920ac997d3021b413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba407638beac5920ac997d3021b413">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae69d22c1daecb87a2e29aae2703bac16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69d22c1daecb87a2e29aae2703bac16">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;F1, F2,Fs...&gt; hydra::sum </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7d619f99868f45f5e06b9040bcc68b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d619f99868f45f5e06b9040bcc68b7">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ void hydra::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67385a5afc562279b4419a11ab79e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67385a5afc562279b4419a11ab79e3d6">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ void hydra::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a110443bb149efe88b6713bc5aca89b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110443bb149efe88b6713bc5aca89b7c">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c39f4b7fa2b8b0c1e4066e9d059b435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c39f4b7fa2b8b0c1e4066e9d059b435">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e16e05c122a0b3b48937b89de17b621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e16e05c122a0b3b48937b89de17b621">&#9670;&nbsp;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::tie </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::tie(std::forward&lt;T&gt;(t)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The objects to reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are references to <code>t</code>. </dd></dl>

</div>
</div>
<a id="a66e3f95285aed29c7f62df05eecf2f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e3f95285aed29c7f62df05eecf2f00">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Input , typename Iterable_Output , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable_Output&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Output&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Output&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::transform </td>
          <td>(</td>
          <td class="paramtype">Iterable_Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>unary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5dc1871a5b27614eaaf85914458761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5dc1871a5b27614eaaf85914458761f">&#9670;&nbsp;</a></span>WIGNER_D_FUNCTION() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hydra::WIGNER_D_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9a047a920de59b2ead160699c18bee67">unit</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0.5 *&#160;</td>
          <td class="paramname">1.0+::cos(theta)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2df298b5af72bd35d3059f9cf35fff4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df298b5af72bd35d3059f9cf35fff4f">&#9670;&nbsp;</a></span>WIGNER_D_FUNCTION() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hydra::WIGNER_D_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">-&#160;</td>
          <td class="paramname"><em>2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">-&#160;</td>
          <td class="paramname"><em>2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9a047a920de59b2ead160699c18bee67">unit</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0.25 *&#160;</td>
          <td class="paramname"><em>::pow</em>(1.0+::cos(theta)), 2.0&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad81b041e40b15f480c530d137dd2648c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81b041e40b15f480c530d137dd2648c">&#9670;&nbsp;</a></span>WIGNER_D_FUNCTION() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hydra::WIGNER_D_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">5&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">-&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">-&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#ad4cdde998c768ff10b49ccf19a1d77c8">half</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a>(::<a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a>(0.5 *theta), 5)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b5031c4182811760549bfc06753335a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5031c4182811760549bfc06753335a">&#9670;&nbsp;</a></span>WIGNER_D_FUNCTION() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hydra::WIGNER_D_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">3&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">-&#160;</td>
          <td class="paramname"><em>3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">-&#160;</td>
          <td class="paramname"><em>3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#ad4cdde998c768ff10b49ccf19a1d77c8">half</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a>(::<a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a>(0.5 *theta), 3)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee74c74056102b0d1e82bc90b8daddb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee74c74056102b0d1e82bc90b8daddb8">&#9670;&nbsp;</a></span>wigner_d_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename J , typename M , typename N &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::wigner_d_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac831858c15b02a5120473e14ae8953f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac831858c15b02a5120473e14ae8953f0">&#9670;&nbsp;</a></span>WIGNER_D_FUNCTION() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hydra::WIGNER_D_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">3&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9a047a920de59b2ead160699c18bee67">unit</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">-0.5 *&#160;</td>
          <td class="paramname"><em>::cos</em>theta) *(3.0 - 5.0 *::pow(::cos(theta), 2.0)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18ec0c1895bfa4a66a8f672b41b126e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ec0c1895bfa4a66a8f672b41b126e0">&#9670;&nbsp;</a></span>wigner_d_function&lt; _half&lt; 1 &gt;, _half&lt; 1 &gt;, _half&lt; 1 &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#aee74c74056102b0d1e82bc90b8daddb8">hydra::wigner_d_function</a>&lt; <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt; 1 &gt;, <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt; 1 &gt;, <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt; 1 &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0cde280d59cc81116baf574e9f80311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cde280d59cc81116baf574e9f80311">&#9670;&nbsp;</a></span>wigner_d_function&lt; _half&lt; 1 &gt;, _half&lt; 1 &gt;, _half&lt;-1 &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#aee74c74056102b0d1e82bc90b8daddb8">hydra::wigner_d_function</a>&lt; <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt; 1 &gt;, <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt; 1 &gt;, <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt;-1 &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5559b4291adb15c0e1a66b4215a4f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5559b4291adb15c0e1a66b4215a4f00">&#9670;&nbsp;</a></span>wigner_d_function&lt; _half&lt; 1 &gt;, _half&lt;-1 &gt;, _half&lt; 1 &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#aee74c74056102b0d1e82bc90b8daddb8">hydra::wigner_d_function</a>&lt; <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt; 1 &gt;, <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt;-1 &gt;, <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt; 1 &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af55f35301e426a4cfaa1e408970f9972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55f35301e426a4cfaa1e408970f9972">&#9670;&nbsp;</a></span>wigner_d_function&lt; _half&lt; 1 &gt;, _half&lt;-1 &gt;, _half&lt;-1 &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#aee74c74056102b0d1e82bc90b8daddb8">hydra::wigner_d_function</a>&lt; <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt; 1 &gt;, <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt;-1 &gt;, <a class="el" href="namespacehydra.html#structhydra_1_1__half">_half</a>&lt;-1 &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16cc58cf433d121a37c54f965023d49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cc58cf433d121a37c54f965023d49a">&#9670;&nbsp;</a></span>wigner_d_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::wigner_d_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaec6f8e5354bb7e586f34b1d4659ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6f8e5354bb7e586f34b1d4659ca8c">&#9670;&nbsp;</a></span>wigner_d_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::wigner_d_matrix </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac404982a144cb8c5f101f7cdf503ed7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac404982a144cb8c5f101f7cdf503ed7d">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Iterables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterables&gt;::value...&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; HYDRA_EXTERNAL_NS::thrust::zip_iterator&lt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(std::declval&lt;Iterables&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()...))&gt; &gt; &gt;::type hydra::zip </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad4cdde998c768ff10b49ccf19a1d77c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cdde998c768ff10b49ccf19a1d77c8">&#9670;&nbsp;</a></span>half</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hydra::half</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab14adaa26f703b8c130df530167ebd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14adaa26f703b8c130df530167ebd23">&#9670;&nbsp;</a></span>kFalse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kFalse = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1556536d7a73fa95e5a9c9610f76a3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1556536d7a73fa95e5a9c9610f76a3c1">&#9670;&nbsp;</a></span>kTrue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kTrue = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5afb8f1b6ea1ba2b8fc79444e5d20f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afb8f1b6ea1ba2b8fc79444e5d20f20">&#9670;&nbsp;</a></span>PrintLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classint">int</a> hydra::PrintLevel = <a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a047a920de59b2ead160699c18bee67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a047a920de59b2ead160699c18bee67">&#9670;&nbsp;</a></span>unit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hydra::unit</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li>
    <li class="footer">Generated on Sat Nov 3 2018 02:26:24 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
